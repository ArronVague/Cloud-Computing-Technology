为什么使用websocket？

http：请求——响应。无状态。单向，服务器不能主动向客户端发送消息，只能在响应客户端请求时发送消息。完成一系列请求后关闭。

websocket：全双工。有状态。长连接，只有在客户端或服务器决定关闭时才关闭。

---

mysql中存放图片元信息的表（唯一文件表）

- id（primary key）
- 图片元信息
  - 图片哈希值（unique key）
  - 图片名称
  - 图片大小
  - 图片地址
- 创建日期
- 更新日期
- 状态（可用/删除）（key）

mysql主从服务器

mysql主从模式是什么？为什么使用主从模式？有什么好处？

数据同步，将主服务器的所有数据更改复制到一个或多个从服务器。

工作原理：主服务器执行所有写操作，并记录这些操作在二进制日志（Binary Log）中。从服务器将主服务器的二进制日志复制到自己的中继日志（Relay Log），然后从该中继日志中重放这些操作，从而保持与主服务器的数据同步。

好处：

- 负载均衡：读写分离
- 数据备份：防止单点崩溃
- 高可用性和故障恢复：可以将任何一个从服务器提升为主服务器
- 可以在从服务器上进行数据分析，不会影响到主服务器。

---

ceph存储图片的好处：

完全兼容s3和swift的restful api，可以很容易地用http或https访问。

存储非结构化数据，如图片、文件，且适合读多写少的场景

可靠性：通过数据复制或纠删码来提供数据冗余，保护数据免受单点故障的影响。



ceph和minio、cdn

ceph提供强一致性，而minio只是最终一致性

ceph功能更加齐全

cdn将数据缓存在离用户最近的边缘节点上

---

redis

1. **提高性能**：即时通信系统通常需要处理大量的并发请求。通过将频繁访问的数据（群聊消息）缓存在Redis中，可以显著提高系统的响应速度，从而提供更好的用户体验。
2. **减轻数据库压力**：在高流量的即时通信系统中，数据库可能会成为性能瓶颈。通过使用Redis缓存，可以减少对数据库的请求，从而降低数据库的压力。
3. **消息缓存**：在某些场景下，可以使用Redis来缓存最近的消息，如最近的聊天记录。这可以提供快速的消息加载和历史消息查询。

对于消息缓存：

1. **离线消息**：对于离线的用户，你可以将他们的消息存储在Redis中，当用户上线时，再将消息推送给他们。
2. **最近的聊天记录**：你可以将用户的最近聊天记录缓存在Redis中。当用户打开聊天窗口时，系统可以先从Redis中读取聊天记录，如果Redis中没有数据，再从数据库中读取。这样可以减少对数据库的访问，提高系统的响应速度。

缓存失效策略：

FIFO

LFU

LRU

TTL

Random

缓存击穿：

缓存击穿是指一个热点key（非常频繁地被访问）在缓存中过期的瞬间，大量的请求就落到了数据库上。这种现象就像是在一个点上集中击穿了缓存层，让原本应该被缓存承载的请求直接请求到了数据库，可能导致数据库瞬间压力过大。

为了解决缓存击穿的问题，常见的几种策略包括：

1. **设置热点数据永不过期**：这是最简单的方式，但需要保证更新缓存的操作比较及时，否则可能会出现缓存数据和数据库数据不一致的情况。
2. **使用互斥锁或分布式锁**：当缓存失效的时候，第一个访问数据的线程（或进程）获得锁并开始加载数据，其他线程（或进程）等待，当数据加载完成后释放锁，其他等待的线程（或进程）再从缓存中获取数据。这样可以避免多个线程（或进程）同时从数据库加载数据，但可能会导致线程（或进程）阻塞。
3. **使用缓存预热策略**：缓存预热就是系统上线后，将可能成为热点的数据直接加载到缓存中，这样可以避免缓存系统在处理大量请求时突然崩溃。这需要根据业务情况预判哪些数据可能成为热点。
4. 使用数据库代理限制连接数

**缓存穿透**：缓存穿透是指用户查询的数据既不在缓存中，也不在数据库中，导致每次查询都要去数据库中查询，然后返回空结果，这样会给数据库带来很大的压力。这种情况通常发生在恶意用户使用不存在的查询条件攻击系统时。解决缓存穿透的常见策略有：对查询条件进行校验，例如，ID为正整数，不符合条件的直接拒绝；或者即使数据库查询为空，也将空结果缓存起来，但可以设置较短的过期时间。

**缓存雪崩**：缓存雪崩是指在缓存系统中，如果大量的数据同时过期，而查询数据量巨大，缓存系统受不了压力进而崩溃，导致请求全部转发到数据库，数据库也可能因此崩溃。解决缓存雪崩的常见策略有：设置不同的过期时间，让缓存失效的时间点尽量均匀；利用互斥锁或分布式锁，当缓存失效的时候，不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作，如Redis的SETNX，去set一个mutex key，当操作返回成功时，再去load db（单进程访问）。

redis vs memcached

redis数据类型丰富，memcached单一

| 特性       | Redis                                                        | Memcached                                                    |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据类型   | 支持多种数据类型，如字符串、哈希表、列表、集合、有序集合等   | 仅支持简单的键值数据类型                                     |
| 数据持久化 | 支持，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用（可以保证redis和rabbitmq、mysql间的数据一致性） | 不支持，所有数据都存储在内存中，一旦服务器重启，所有数据都会丢失 |
| 事务支持   | 支持事务，可以保证一系列命令的原子性执行                     | 不支持事务                                                   |
| 多线程     | 单线程模型，无法充分利用多核 CPU                             | 多线程模型，可以更好地利用多核 CPU 的硬件资源                |
| 易用性     | 由于支持多种数据类型和丰富的功能，使用起来可能需要一定的学习成本 | 模型简单，易于理解和使用                                     |

redis为什么用单线程？

- 简单，避免死锁、数据竞争
- 效率高，充分利用cpu。多线程切换可能会抵消并行带来的性能提升。
- 每个操作都是原子性的。

---

为什么使用rabbitmq将上传的图片异步写入ceph，将聊天消息异步写入mysql

在处理大规模数据和高并发的场景下，同步写入往往会遇到性能瓶颈并可能导致用户体验下降。异步写入是解决这个问题的一种常见策略。通过使用消息队列（如RabbitMQ），可以将写入操作放入队列中，然后由后端服务异步地从队列中取出操作并执行。这样做有以下几个优势：

1. **提高响应速度**：当用户上传图片或发送聊天消息时，系统只需将操作放入队列中，然后立即返回，而不需要等待写入操作完成。这可以大大提高系统的响应速度，提升用户体验。
2. **缓解高峰压力**：在流量高峰期，系统可能会收到大量的写入请求。通过使用消息队列，可以将这些请求暂存起来，然后在系统负载较低的时候逐渐处理。这可以有效地缓解系统在高峰期的压力。
3. **保证数据一致性（rabbitmq有失败重写机制）**：如果直接写入存储系统（如Ceph或MySQL）出现失败，可能会导致数据丢失。而通过使用消息队列，即使写入操作失败，也可以重新尝试，直到成功为止。这可以有效地保证数据的一致性。
4. **提高系统的可扩展性**：通过使用消息队列，可以很容易地增加处理消息的后端服务，以应对更大的负载。这使得系统具有很好的可扩展性。

为什么用rabbitmq？

协议支持：支持amqp、stomp、mqtt等协议，兼容性强

可靠性强：持久化、交付确认、发布者确认等机制

灵活的路由

集群和高可用性：容易实现负载均衡和故障切换

多语言客户端支持



那为什么高并发写入rabbitmq的效果会比高并发写入mysql更好？

1. 设计目标：mysql用于存储、查询和处理数据，强调消息一致性和持久性；而rabbitmq用于接收、存储和转发消息，优化了消息的传输和可用性。
2. 写入操作：mysql通常涉及到磁盘I/O、索引更新、事务处理、锁定等。rabbitmq通常是写入内存，然后异步写入磁盘。而且，rabbitmq的消息传输设计为尽可能地减少阻塞和等待。
3. 并发处理：rabbitmq使用了更高效的并发和网络I/O抹胸。
4. 资源使用：



kafka：适合大数据实时处理的场景。

---

go micro提供了微服务开发的核心功能：服务注册发现、负载均衡、rpc、熔断

负载均衡：通过consul、etcd等

- 服务发现
- 选择策略
- 服务调用







盐值加密用户密码



登录时生成token并存入数据库

用户token表

- id（primary key）
- user name（unique key）
- user token（更新的时候仅覆盖token值，最新值为有效）

（或者用session和cookie）



除了登录和注册，都需要带上token

验证token

判断token时效性

从数据库查user name对应的token与当前token是否一致



中间件跟拦截器差不多



文件校验值计算

- CRC（32/64）校验码 安全性最弱 效率最高
- MD5 哈希值
- SHA1（20字节）哈希值 安全性最高 效率最高



秒传原理场景：

1. 用户上传
2. 离线下载
3. 好友分享

关键点：

1. 记录文件hash
2. 用户文件表关联

![image-20240326200307324](temp/image-20240326200307324.png)

hash计算可以做成微服务



用户文件表

- id
- 用户名（key）
- 文件哈希（和用户名一起，unique key）
- 文件大小
- 文件名
- 上传时间
- 最后更新时间
- 状态（可用/删除）（key）



秒传

查询文件hash（通过浏览器计算文件hash）



分块上传与断点续传

几点说明

- 小文件不建议分块上传（如图片）
- 并行上传分块，且无序
- 极大提高传输效率
- 减少传输失败后重试的流量及时间

redis缓存（分块信息只需要上传过程保留）

- 数据操作频繁，存取效率高

redis连接池（cache）



分布式存储系统

ceph是什么

数据分布式存储的问题

基于私有云，实现分布式存储系统

部署简单

可靠性高

性能高

分布式，可扩展性强

客户端支持多语言

![image-20240326203723753](temp/image-20240326203723753.png)



rabbitmq实现异步上传文件

![image-20240327163854660](temp/image-20240327163854660.png)

通常需要依赖任务队列

![image-20240327164021369](temp/image-20240327164021369.png)

RabbitMQ是什么

- 开源的消息代理
- 面向消息的中间件
- 默认遵循AMQP协议的MQ服务

可以解决

- 逻辑解耦，异步任务
- 消息持久化，重启不影响
- 削峰，大规模消息处理

特点

- 可靠性：持久化、传输确认、发布确认
- 可扩展性：多个节点可以组成一个集群，可动态更改
- 多语言客户端：几乎支持所有常用语言
- 管理界面：易用，便于监控和管理

![image-20240327164537537](temp/image-20240327164537537.png)

exchange交换机

- 决定消息按什么规则，路由到哪个队列

queue需要绑定exchange

- 消息载体

routing key：路由关键字，exchange根据这个关键字来投递消息

channel：消息通道，需要和生产者和消费者之间建立

工作模式

fanout广播

c1，c2竞争

![image-20240327165257861](temp/image-20240327165257861.png)

direct单播，和routing key完全匹配

![image-20240327165323267](temp/image-20240327165323267.png)

topic 通配符匹配

![image-20240327165539739](temp/image-20240327165539739.png)



如果**考虑**消息通过rabbitmq存入mysql。这时候就需要主从了，从节点负责读数据，主节点负责写数据。



架构微服务化

微服务是什么：

一种分散治理的开发技术和理念

打包在单体应用 开发维护不容易 崩溃导致整个进程退出 整个服务不可用

打散 独立成微服务 提供单一功能 单独部署 运行 升级

弱耦合，对接接口



应用场景

原有单体应用逻辑复杂，按业务逻辑划分

优点：

- 化繁为简，分散治理
- 服务间松耦合，服务内高内聚
- 服务可独立构建/部署/升级，局部更新
- 提高系统容错性，减少系统整体崩溃概率
- 易于实现异构系统

缺点：

- 运维部署难（docker、k8s）
- 系统间调用逻辑的处理难
- 日志收集和统计难
- 额外引入非业务模块服务（服务注册与发现中心、配置中心、分布式日志收集）



gin框架

- 非常轻巧
- api友好
- 源码注释详细
- 对外部依赖库少

![image-20240327201504555](temp/image-20240327201504555.png)

![image-20240327201535797](temp/image-20240327201535797.png)

go-micro

 ![image-20240327202210191](temp/image-20240327202210191.png)

![image-20240327202345469](temp/image-20240327202345469.png)

broker：一步通讯

codec：编码解码

registry：服务注册发现

selector：负载均衡

transport：通信模块接口





linux查看进程、线程、空闲内存

linux进程的内存分布

死锁 举例

怎么避免

线程安全

c++虚函数的底层

字节流（大小端）

网络字节流

tcp、udp

三次握手

tcp状态机

四次挥手

syn flood? lvs?

有没有抓包过tcp，用的什么命令？

linux下抓包过吗？

线程和协程

常见的查找：二分、哈希、二叉搜索

- 哈希冲突

epoll

epoll和select的区别

红黑树

怎么实现

为什么叫红黑树

redis的跳表

为什么用跳表而不是二叉搜索树

常见的排序

稳定

堆排序

golang defer执行顺序

main里面

println("return", func)

里面还有一些i，defer