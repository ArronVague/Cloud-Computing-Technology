{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/database-system-principles.md","hash":"66a43d025e5335d2f73dc6187b43ef29750a63f5","modified":1710859346580},{"_id":"source/_posts/hello-world.md","hash":"777d9387caf698574064318ecab5c2bb5abe878e","modified":1710854010145},{"_id":"source/_posts/mysql.md","hash":"7d701943d4b5c120a560f3ce7ceabd15fff42a58","modified":1710863077340},{"_id":"source/_posts/socket.md","hash":"f20f738c94a5fa50c061e2b08189e65a4fd1307b","modified":1710911180763},{"_id":"source/img/avatar.jpg","hash":"3307e2fcb0c14e66257dfa918d4a6a77b32a49cd","modified":1701753639323},{"_id":"source/img/favicon.svg","hash":"fddce6f12bcdeb14a122100a4df261ac05a67f58","modified":1710912233239},{"_id":"source/_posts/database-system-principles/image-20240319215933046.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710856773068},{"_id":"source/_posts/database-system-principles/image-20240319220740283.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710857260304},{"_id":"source/_posts/database-system-principles/image-20240319221024695.png","hash":"69b6c0175dac118c71e167c90c33a4e4c4e47757","modified":1710857424710},{"_id":"source/_posts/database-system-principles/image-20240319220943892.png","hash":"bc60779a7c294034e7de4e6be05037b95b659ef2","modified":1710857383912},{"_id":"source/_posts/database-system-principles/image-20240319221128098.png","hash":"28269ef73d73a53ece9fa0df1015be097b0fad25","modified":1710857488129},{"_id":"source/_posts/database-system-principles/image-20240319221109092.png","hash":"bd4b34fb787786b5be792b6517a2c236f7705e0b","modified":1710857469113},{"_id":"source/_posts/database-system-principles/image-20240319221039549.png","hash":"cbf322064326a4abe99ace20077060f2a27aad4d","modified":1710857439571},{"_id":"source/_posts/database-system-principles/image-20240319222609279.png","hash":"225bd2c408a4105dca17e4a59cf266b12d11fb02","modified":1710858369294},{"_id":"source/_posts/database-system-principles/image-20240319222621455.png","hash":"a7b9939d28d10aa06158df97048a5fc3bdd683f9","modified":1710858381475},{"_id":"source/_posts/database-system-principles/image-20240319222801904.png","hash":"634e1a8d7ae85ac963b833bf27488be2e832913a","modified":1710858481926},{"_id":"source/_posts/database-system-principles/image-20240319222832886.png","hash":"96be249738a4b864e738436b19edae3f1f21d8ea","modified":1710858512908},{"_id":"source/_posts/socket/image-20240320110531226.png","hash":"58f971ea6ab24f3e75b5d8a8c4d21b59c87cbf61","modified":1710903931261},{"_id":"source/_posts/mysql/image-20240319231743225.png","hash":"9d372fbdb6b582c5446a56ab11de5d6044670974","modified":1710861463230},{"_id":"source/_posts/mysql/image-20240319231655495.png","hash":"1f4a4feb12d773b0e2ba01d66dc32191c220fffc","modified":1710861415501},{"_id":"source/_posts/database-system-principles/image-20240319222857283.png","hash":"d06e64e0562cf03313a31c9cb24cf3a5b5e37db8","modified":1710858537309},{"_id":"source/_posts/database-system-principles/image-20240319223152453.png","hash":"cb4ef05fc4b820636c20f0b08364f4c5f2aad45b","modified":1710858712480},{"_id":"source/_posts/socket/image-20240320110625558.png","hash":"45f7da1a37207c8255d61dc83e05277de2a1e7a7","modified":1710903985578},{"_id":"source/_posts/socket/image-20240320111122789.png","hash":"712cfd1050ba4fb0504209f09479f87752f6b04b","modified":1710904282827},{"_id":"source/_posts/socket/image-20240320120231930.png","hash":"599cb4eb3ad604fd449f6b2393f67a1cfff101db","modified":1710907351954},{"_id":"source/_posts/socket/image-20240320120005597.png","hash":"bebd03b42c4c96e72496d4538eda9e6a4caa40e8","modified":1710907205617},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755585},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755588},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755592},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755593},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755595},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755559},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755573},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755568},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755576},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755582},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1710909755597},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1710909755968},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"18b3b80cf6456697a675721d957362840c1ab949","modified":1710909755629},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1710909755971},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"e02471f80db87db43aa7d527176e195b60dc4b99","modified":1710909755606},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"040fed1d0d7e4d8003446d1541bc15a2c4b4e500","modified":1710909755612},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1710909756262},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"4b8a3096137e0d879fb17972a69630bde38d8212","modified":1710909755604},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1710909756265},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1710909756263},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1710909756267},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"b992b68705f5050a99de926525b3cb40d95c4769","modified":1710909756266},{"_id":"node_modules/hexo-theme-icarus/languages/it.yml","hash":"b76999994cda6b08b53d34c3dd67947f164de655","modified":1710909756267},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1710909756268},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1710909756269},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1710909756270},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1710909756271},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1710909756272},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1710909756275},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1710909756276},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1710909756277},{"_id":"node_modules/hexo-theme-icarus/languages/sv.yml","hash":"b12eee168c52aac855ffce9f78fe5fd5d6e3970c","modified":1710909756273},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1710909756278},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1710909756274},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"daf8eca64197709a9dc4a4792c403a32d78bdfae","modified":1710909755939},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1710909755943},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1710909755944},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1710909755952},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1710909755953},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1710909755955},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1710909755964},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1710909755965},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1710909755957},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"93a79969c7eb47cfac097893cda36368db56902c","modified":1710909755610},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"a46da71c20fa9d73c1bac26fda77717abae1b308","modified":1710909755613},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"7189efe33d18927d3790e8afb06642fb293b8603","modified":1710909755608},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1710909755615},{"_id":"node_modules/hexo-theme-icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1710909755615},{"_id":"node_modules/hexo-theme-icarus/include/migration/v5_v5.1.js","hash":"073f22bd16e34b56f016633b1676dab2e7d8843d","modified":1710909755616},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"f233678cd656c0e300181ca79dd30cb42fc213b3","modified":1710909755624},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1710909756242},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1710909756241},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"ec54dc24eb4d9802d8fefc44c210558bc1641109","modified":1710909756245},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1710909756243},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1710909756249},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1710909756243},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1710909756248},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1710909756250},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1710909756251},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1710909756251},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1710909756254},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1710909756256},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"084843d5a522029e0f84a4fe791fbcb2cabd4c36","modified":1710909756252},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1710909756253},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1710909755605},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1710909756257},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"0610cadb3976954c6f299d30320a93a1bd2a151c","modified":1710909755946},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"fd52330d582fd122db7f55444c2f3368ff4bd8d7","modified":1710909755947},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"c4fc3c016de42c50614f70538a23359eee905ed3","modified":1710909755941},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"ff049c2837a111da775d1661b605dd417614b84c","modified":1710909755950},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"de966666f1e4ef80e0d15081b2709c3065b246dd","modified":1710909755949},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1710909755954},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"2e27800b2a8a87112c96778db858c3419d890b79","modified":1710909755956},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"eaec7c7b936197247e5acd73a79ca951da4d82ec","modified":1710909755961},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"1409627d98a92b4f5b2ab829f8e6b50b75d60e53","modified":1710909755962},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"7a89ac72a988d13b4714ab78a6dfd5cd8de85d47","modified":1710909755966},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"0fad6f8a91bb5cf678b9ff2d66d2162d61625074","modified":1710909755963},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1710909755641},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1710909755943},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1710909756246},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1710909756247},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1710909755959},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1710909756255},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1710909755973},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1710909756258},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1710909756239},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1710909756259},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1710909756261},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1710909756260},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1710909755600},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1710909755601},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"37f3b16fbd9668b9496d5f2d9bd9fb22fc6cee27","modified":1710909755611},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1710909755602},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1710909755620},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"f49270b619f5d2c3decde6b0b5a0c3bbab4b54a5","modified":1710909755623},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"e85c9d7f2579805beb252a1b6345d5a668a13baa","modified":1710909755626},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1710909755627},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1710909755631},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1710909755625},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1710909755634},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1710909755628},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1710909755636},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1710909755635},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1710909755638},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1710909755639},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1710909755621},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1710909755618},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1710909755633},{"_id":"source/img/favicon.ico","hash":"6b1086f72bad6aa8e5c86d97f203f3b4d584d46d","modified":1710912101653},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1710912314616},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1710912314616},{"_id":"public/content.json","hash":"f56155571a415527f2fcb5d93067cd9a4f8882ff","modified":1710912314616},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1710912314616},{"_id":"public/manifest.json","hash":"8dafbebe1edd21ec9799a37f5c25d2e50f16fe3c","modified":1710912314616},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1710912314616},{"_id":"public/archives/index.html","hash":"aebe0becb475be396c704614d4f07db9ea9d558a","modified":1710912314616},{"_id":"public/archives/2024/index.html","hash":"792dd8bc5e0f0d80c4a4f2042fddddd6c103f077","modified":1710912314616},{"_id":"public/archives/2024/03/index.html","hash":"46e6518ca08341b590cd0daf9cf7360fad87fd66","modified":1710912314616},{"_id":"public/categories/index.html","hash":"cd65d36d068db9698737384fb9e1ee3471862369","modified":1710912314616},{"_id":"public/tags/index.html","hash":"669a7330520603573143ca88a876043ffccca819","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/index.html","hash":"b05297cf90149e544ace5d0353020aadf5b9aea4","modified":1710912314616},{"_id":"public/2024/03/19/mysql/index.html","hash":"8967e292898af95b16f19a4812bebe082d42f120","modified":1710912314616},{"_id":"public/2024/03/20/socket/index.html","hash":"34363e4350671e35c59819ab1e18615cbbb366ae","modified":1710912314616},{"_id":"public/2024/03/19/hello-world/index.html","hash":"836069bc973ffabf7dcc7f4b4103bc674a68c9ee","modified":1710912314616},{"_id":"public/index.html","hash":"08a13202ff3b1dd7b49894a3b2f5411618f8ae55","modified":1710912314616},{"_id":"public/tags/computer-networks/index.html","hash":"6ba688d439e08ead03f3b282e233ef36f03edc15","modified":1710912314616},{"_id":"public/img/favicon.svg","hash":"fddce6f12bcdeb14a122100a4df261ac05a67f58","modified":1710912314616},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1710912314616},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1710912314616},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1710912314616},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1710912314616},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1710912314616},{"_id":"public/img/avatar.jpg","hash":"3307e2fcb0c14e66257dfa918d4a6a77b32a49cd","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319215933046.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319220943892.png","hash":"bc60779a7c294034e7de4e6be05037b95b659ef2","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319221024695.png","hash":"69b6c0175dac118c71e167c90c33a4e4c4e47757","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319220740283.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319221109092.png","hash":"bd4b34fb787786b5be792b6517a2c236f7705e0b","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319221128098.png","hash":"28269ef73d73a53ece9fa0df1015be097b0fad25","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319222609279.png","hash":"225bd2c408a4105dca17e4a59cf266b12d11fb02","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319221039549.png","hash":"cbf322064326a4abe99ace20077060f2a27aad4d","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319222621455.png","hash":"a7b9939d28d10aa06158df97048a5fc3bdd683f9","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319222801904.png","hash":"634e1a8d7ae85ac963b833bf27488be2e832913a","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319222832886.png","hash":"96be249738a4b864e738436b19edae3f1f21d8ea","modified":1710912314616},{"_id":"public/2024/03/19/mysql/image-20240319231655495.png","hash":"1f4a4feb12d773b0e2ba01d66dc32191c220fffc","modified":1710912314616},{"_id":"public/2024/03/19/mysql/image-20240319231743225.png","hash":"9d372fbdb6b582c5446a56ab11de5d6044670974","modified":1710912314616},{"_id":"public/2024/03/20/socket/image-20240320110531226.png","hash":"58f971ea6ab24f3e75b5d8a8c4d21b59c87cbf61","modified":1710912314616},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1710912314616},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1710912314616},{"_id":"public/js/main.js","hash":"37f3b16fbd9668b9496d5f2d9bd9fb22fc6cee27","modified":1710912314616},{"_id":"public/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1710912314616},{"_id":"public/css/cyberpunk.css","hash":"b462177bee11f76e84e649f8192d5a68cb4b1402","modified":1710912314616},{"_id":"public/css/default.css","hash":"8717dd0ed1fe2a4237fbfb4f4f6e566cb1ee16b7","modified":1710912314616},{"_id":"public/css/style.css","hash":"8717dd0ed1fe2a4237fbfb4f4f6e566cb1ee16b7","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319222857283.png","hash":"d06e64e0562cf03313a31c9cb24cf3a5b5e37db8","modified":1710912314616},{"_id":"public/2024/03/19/database-system-principles/image-20240319223152453.png","hash":"cb4ef05fc4b820636c20f0b08364f4c5f2aad45b","modified":1710912314616},{"_id":"public/2024/03/20/socket/image-20240320110625558.png","hash":"45f7da1a37207c8255d61dc83e05277de2a1e7a7","modified":1710912314616},{"_id":"public/2024/03/20/socket/image-20240320120231930.png","hash":"599cb4eb3ad604fd449f6b2393f67a1cfff101db","modified":1710912314616},{"_id":"public/2024/03/20/socket/image-20240320111122789.png","hash":"712cfd1050ba4fb0504209f09479f87752f6b04b","modified":1710912314616},{"_id":"public/2024/03/20/socket/image-20240320120005597.png","hash":"bebd03b42c4c96e72496d4538eda9e6a4caa40e8","modified":1710912314616},{"_id":"public/img/favicon.ico","hash":"6b1086f72bad6aa8e5c86d97f203f3b4d584d46d","modified":1710912314616}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"database-system-principles","date":"2024-03-19T13:54:44.000Z","_content":"\n# 数据库系统原理\n\nhttps://zhuanlan.zhihu.com/p/476601594\n\nhttps://blog.csdn.net/Xupixel/article/details/120405501\n\nhttps://www.hwpo.top/posts/d87f7e0c/index.html\n\nhttps://developer.aliyun.com/article/815625\n\n## 一、事务\n\n### 概念\n\n事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\n![image-20240319220740283](database-system-principles/image-20240319220740283.png)\n\n#### 1. 原子性（Atomicity）\n\n事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\n#### 2. 一致性（Consistency）\n\n数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）\n\n#### 3. 隔离性（Isolation）\n\n一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\n#### 4. 持久性（Durability）\n\n一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n\n系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n\n---\n\n事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n\n- 只有满足一致性，事务的执行结果才是正确的。\n- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n- 事务满足持久化是为了能应对系统崩溃的情况。\n\n![image-20240319220943892](database-system-principles/image-20240319220943892.png)\n\n### AUTOCOMMIT\n\nMySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n\n## 二、并发一致性问题\n\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n\n### 丢失修改\n\n丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。\n\n![image-20240319221024695](database-system-principles/image-20240319221024695.png)\n\n### 读脏数据\n\n读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n\n![image-20240319221039549](database-system-principles/image-20240319221039549.png)\n\n### 不可重复读（读已提交导致）\n\n不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。\n\n![image-20240319221109092](database-system-principles/image-20240319221109092.png)\n\n### 幻影读\n\n幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n![image-20240319221128098](database-system-principles/image-20240319221128098.png)\n\n解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n\n## 三、封锁\n\n### 封锁粒度\n\nMySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n\n### 封锁类型\n\n#### 1. 读写锁\n\n- 互斥锁（Exclusive），简写为 X 锁，又称写锁。\n- 共享锁（Shared），简写为 S 锁，又称读锁。\n\n有以下两个规定：\n\n- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n锁的兼容关系如下：\n\n![image-20240319222609279](database-system-principles/image-20240319222609279.png)\n\n#### 2. 意向锁\n\n使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n\n- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n\n各种锁的兼容关系如下：\n\n![image-20240319222621455](database-system-principles/image-20240319222621455.png)\n\n### 封锁协议\n\n#### 1. 三级封锁协议\n\n**一级封锁协议**\n\n事务 T 要修改数据 A 时必须加**X 锁**，直到 **T 结束**才释放锁。\n\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n\n![image-20240319222801904](database-system-principles/image-20240319222801904.png)\n\n**二级封锁协议**\n\n在一级的基础上，要求读取数据 A 时必须加 **S 锁**，**读取完**马上释放 S 锁。\n\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\n![image-20240319222832886](database-system-principles/image-20240319222832886.png)\n\n**三级封锁协议**\n\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n![image-20240319222857283](database-system-principles/image-20240319222857283.png)\n\n#### 2. 两段锁协议\n\n加锁和解锁分为两个阶段进行。\n\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\n\n```\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n```\n\n但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\n\n```\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\n```\n\n### MySQL 隐式与显式锁定\n\nMySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\n\nInnoDB 也可以使用特定的语句进行显示锁定：\n\n```\nSELECT ... LOCK In SHARE MODE;\nSELECT ... FOR UPDATE;\n```\n\n## 四、隔离级别\n\n### 未提交读（READ UNCOMMITTED）\n\n事务中的修改即使没有提交，对其它事务也是可见的。\n\n### 提交读（READ COMMITTED）\n\n一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n### 可重复读（REPEATABLE READ）\n\n保证在同一个事务中多次读取同一数据的结果是一样的。\n\n### 可串行化（SERIALIZABLE）\n\n强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n![image-20240319223152453](database-system-principles/image-20240319223152453.png)\n\n## 五、多版本并发控制（暂时没见过）\n\n## 六、Next-Key Locks（暂时没见过）\n\n## 七、关系数据库设计理论（以后补充完整）\n\n### 函数依赖\n\n记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n\n如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n\n对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。\n\n对于 A->B，B->C，则 A->C 是一个传递函数依赖。\n\n#### 1. 第一范式 (1NF)\n\n属性不可分。满足原子性。\n\n#### 2. 第二范式 (2NF)\n\n每个非主属性完全函数依赖于键码。消除部分依赖。\n\n#### 3. 第三范式 (3NF)\n\n非主属性不传递函数依赖于键码。消除传递依赖。\n\n## 八、ER 图（以后再补充）\n","source":"_posts/database-system-principles.md","raw":"---\ntitle: database-system-principles\ndate: 2024-03-19 21:54:44\ntags:\n\n---\n\n# 数据库系统原理\n\nhttps://zhuanlan.zhihu.com/p/476601594\n\nhttps://blog.csdn.net/Xupixel/article/details/120405501\n\nhttps://www.hwpo.top/posts/d87f7e0c/index.html\n\nhttps://developer.aliyun.com/article/815625\n\n## 一、事务\n\n### 概念\n\n事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\n![image-20240319220740283](database-system-principles/image-20240319220740283.png)\n\n#### 1. 原子性（Atomicity）\n\n事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\n#### 2. 一致性（Consistency）\n\n数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）\n\n#### 3. 隔离性（Isolation）\n\n一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\n#### 4. 持久性（Durability）\n\n一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n\n系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n\n---\n\n事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n\n- 只有满足一致性，事务的执行结果才是正确的。\n- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n- 事务满足持久化是为了能应对系统崩溃的情况。\n\n![image-20240319220943892](database-system-principles/image-20240319220943892.png)\n\n### AUTOCOMMIT\n\nMySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n\n## 二、并发一致性问题\n\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n\n### 丢失修改\n\n丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。\n\n![image-20240319221024695](database-system-principles/image-20240319221024695.png)\n\n### 读脏数据\n\n读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n\n![image-20240319221039549](database-system-principles/image-20240319221039549.png)\n\n### 不可重复读（读已提交导致）\n\n不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。\n\n![image-20240319221109092](database-system-principles/image-20240319221109092.png)\n\n### 幻影读\n\n幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n![image-20240319221128098](database-system-principles/image-20240319221128098.png)\n\n解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n\n## 三、封锁\n\n### 封锁粒度\n\nMySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n\n### 封锁类型\n\n#### 1. 读写锁\n\n- 互斥锁（Exclusive），简写为 X 锁，又称写锁。\n- 共享锁（Shared），简写为 S 锁，又称读锁。\n\n有以下两个规定：\n\n- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n锁的兼容关系如下：\n\n![image-20240319222609279](database-system-principles/image-20240319222609279.png)\n\n#### 2. 意向锁\n\n使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n\n- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n\n各种锁的兼容关系如下：\n\n![image-20240319222621455](database-system-principles/image-20240319222621455.png)\n\n### 封锁协议\n\n#### 1. 三级封锁协议\n\n**一级封锁协议**\n\n事务 T 要修改数据 A 时必须加**X 锁**，直到 **T 结束**才释放锁。\n\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n\n![image-20240319222801904](database-system-principles/image-20240319222801904.png)\n\n**二级封锁协议**\n\n在一级的基础上，要求读取数据 A 时必须加 **S 锁**，**读取完**马上释放 S 锁。\n\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\n![image-20240319222832886](database-system-principles/image-20240319222832886.png)\n\n**三级封锁协议**\n\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n![image-20240319222857283](database-system-principles/image-20240319222857283.png)\n\n#### 2. 两段锁协议\n\n加锁和解锁分为两个阶段进行。\n\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\n\n```\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n```\n\n但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\n\n```\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\n```\n\n### MySQL 隐式与显式锁定\n\nMySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\n\nInnoDB 也可以使用特定的语句进行显示锁定：\n\n```\nSELECT ... LOCK In SHARE MODE;\nSELECT ... FOR UPDATE;\n```\n\n## 四、隔离级别\n\n### 未提交读（READ UNCOMMITTED）\n\n事务中的修改即使没有提交，对其它事务也是可见的。\n\n### 提交读（READ COMMITTED）\n\n一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n### 可重复读（REPEATABLE READ）\n\n保证在同一个事务中多次读取同一数据的结果是一样的。\n\n### 可串行化（SERIALIZABLE）\n\n强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n![image-20240319223152453](database-system-principles/image-20240319223152453.png)\n\n## 五、多版本并发控制（暂时没见过）\n\n## 六、Next-Key Locks（暂时没见过）\n\n## 七、关系数据库设计理论（以后补充完整）\n\n### 函数依赖\n\n记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n\n如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n\n对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。\n\n对于 A->B，B->C，则 A->C 是一个传递函数依赖。\n\n#### 1. 第一范式 (1NF)\n\n属性不可分。满足原子性。\n\n#### 2. 第二范式 (2NF)\n\n每个非主属性完全函数依赖于键码。消除部分依赖。\n\n#### 3. 第三范式 (3NF)\n\n非主属性不传递函数依赖于键码。消除传递依赖。\n\n## 八、ER 图（以后再补充）\n","slug":"database-system-principles","published":1,"updated":"2024-03-19T14:42:26.580Z","comments":1,"layout":"post","photos":[],"_id":"cltzd0ony00001kcg97lge4gq","content":"<h1 id=\"数据库系统原理\"><a href=\"#数据库系统原理\" class=\"headerlink\" title=\"数据库系统原理\"></a>数据库系统原理</h1><p><a href=\"https://zhuanlan.zhihu.com/p/476601594\">https://zhuanlan.zhihu.com/p/476601594</a></p>\n<p><a href=\"https://blog.csdn.net/Xupixel/article/details/120405501\">https://blog.csdn.net/Xupixel/article/details/120405501</a></p>\n<p><a href=\"https://www.hwpo.top/posts/d87f7e0c/index.html\">https://www.hwpo.top/posts/d87f7e0c/index.html</a></p>\n<p><a href=\"https://developer.aliyun.com/article/815625\">https://developer.aliyun.com/article/815625</a></p>\n<h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220740283.png\"></p>\n<h4 id=\"1-原子性（Atomicity）\"><a href=\"#1-原子性（Atomicity）\" class=\"headerlink\" title=\"1. 原子性（Atomicity）\"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>\n<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>\n<h4 id=\"2-一致性（Consistency）\"><a href=\"#2-一致性（Consistency）\" class=\"headerlink\" title=\"2. 一致性（Consistency）\"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）</p>\n<h4 id=\"3-隔离性（Isolation）\"><a href=\"#3-隔离性（Isolation）\" class=\"headerlink\" title=\"3. 隔离性（Isolation）\"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>\n<h4 id=\"4-持久性（Durability）\"><a href=\"#4-持久性（Durability）\" class=\"headerlink\" title=\"4. 持久性（Durability）\"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>\n<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>\n<hr>\n<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>\n<ul>\n<li>只有满足一致性，事务的执行结果才是正确的。</li>\n<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>\n<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>\n<li>事务满足持久化是为了能应对系统崩溃的情况。</li>\n</ul>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220943892.png\"></p>\n<h3 id=\"AUTOCOMMIT\"><a href=\"#AUTOCOMMIT\" class=\"headerlink\" title=\"AUTOCOMMIT\"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>\n<h2 id=\"二、并发一致性问题\"><a href=\"#二、并发一致性问题\" class=\"headerlink\" title=\"二、并发一致性问题\"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221024695.png\"></p>\n<h3 id=\"读脏数据\"><a href=\"#读脏数据\" class=\"headerlink\" title=\"读脏数据\"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221039549.png\"></p>\n<h3 id=\"不可重复读（读已提交导致）\"><a href=\"#不可重复读（读已提交导致）\" class=\"headerlink\" title=\"不可重复读（读已提交导致）\"></a>不可重复读（读已提交导致）</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221109092.png\"></p>\n<h3 id=\"幻影读\"><a href=\"#幻影读\" class=\"headerlink\" title=\"幻影读\"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221128098.png\"></p>\n<p>解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>\n<h2 id=\"三、封锁\"><a href=\"#三、封锁\" class=\"headerlink\" title=\"三、封锁\"></a>三、封锁</h2><h3 id=\"封锁粒度\"><a href=\"#封锁粒度\" class=\"headerlink\" title=\"封锁粒度\"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>\n<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>\n<h3 id=\"封锁类型\"><a href=\"#封锁类型\" class=\"headerlink\" title=\"封锁类型\"></a>封锁类型</h3><h4 id=\"1-读写锁\"><a href=\"#1-读写锁\" class=\"headerlink\" title=\"1. 读写锁\"></a>1. 读写锁</h4><ul>\n<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>\n<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>\n</ul>\n<p>有以下两个规定：</p>\n<ul>\n<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>\n</ul>\n<p>锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222609279.png\"></p>\n<h4 id=\"2-意向锁\"><a href=\"#2-意向锁\" class=\"headerlink\" title=\"2. 意向锁\"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>\n<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>\n<p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，IX&#x2F;IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>\n<ul>\n<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>\n<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>\n</ul>\n<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>\n<p>各种锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222621455.png\"></p>\n<h3 id=\"封锁协议\"><a href=\"#封锁协议\" class=\"headerlink\" title=\"封锁协议\"></a>封锁协议</h3><h4 id=\"1-三级封锁协议\"><a href=\"#1-三级封锁协议\" class=\"headerlink\" title=\"1. 三级封锁协议\"></a>1. 三级封锁协议</h4><p><strong>一级封锁协议</strong></p>\n<p>事务 T 要修改数据 A 时必须加<strong>X 锁</strong>，直到 <strong>T 结束</strong>才释放锁。</p>\n<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222801904.png\"></p>\n<p><strong>二级封锁协议</strong></p>\n<p>在一级的基础上，要求读取数据 A 时必须加 <strong>S 锁</strong>，<strong>读取完</strong>马上释放 S 锁。</p>\n<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222832886.png\"></p>\n<p><strong>三级封锁协议</strong></p>\n<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>\n<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222857283.png\"></p>\n<h4 id=\"2-两段锁协议\"><a href=\"#2-两段锁协议\" class=\"headerlink\" title=\"2. 两段锁协议\"></a>2. 两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>\n<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>\n<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>\n\n<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MySQL-隐式与显式锁定\"><a href=\"#MySQL-隐式与显式锁定\" class=\"headerlink\" title=\"MySQL 隐式与显式锁定\"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>\n<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ... LOCK In SHARE MODE;</span><br><span class=\"line\">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、隔离级别\"><a href=\"#四、隔离级别\" class=\"headerlink\" title=\"四、隔离级别\"></a>四、隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>\n<h3 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319223152453.png\"></p>\n<h2 id=\"五、多版本并发控制（暂时没见过）\"><a href=\"#五、多版本并发控制（暂时没见过）\" class=\"headerlink\" title=\"五、多版本并发控制（暂时没见过）\"></a>五、多版本并发控制（暂时没见过）</h2><h2 id=\"六、Next-Key-Locks（暂时没见过）\"><a href=\"#六、Next-Key-Locks（暂时没见过）\" class=\"headerlink\" title=\"六、Next-Key Locks（暂时没见过）\"></a>六、Next-Key Locks（暂时没见过）</h2><h2 id=\"七、关系数据库设计理论（以后补充完整）\"><a href=\"#七、关系数据库设计理论（以后补充完整）\" class=\"headerlink\" title=\"七、关系数据库设计理论（以后补充完整）\"></a>七、关系数据库设计理论（以后补充完整）</h2><h3 id=\"函数依赖\"><a href=\"#函数依赖\" class=\"headerlink\" title=\"函数依赖\"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>\n<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>\n<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>\n<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>\n<h4 id=\"1-第一范式-1NF\"><a href=\"#1-第一范式-1NF\" class=\"headerlink\" title=\"1. 第一范式 (1NF)\"></a>1. 第一范式 (1NF)</h4><p>属性不可分。满足原子性。</p>\n<h4 id=\"2-第二范式-2NF\"><a href=\"#2-第二范式-2NF\" class=\"headerlink\" title=\"2. 第二范式 (2NF)\"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。消除部分依赖。</p>\n<h4 id=\"3-第三范式-3NF\"><a href=\"#3-第三范式-3NF\" class=\"headerlink\" title=\"3. 第三范式 (3NF)\"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。消除传递依赖。</p>\n<h2 id=\"八、ER-图（以后再补充）\"><a href=\"#八、ER-图（以后再补充）\" class=\"headerlink\" title=\"八、ER 图（以后再补充）\"></a>八、ER 图（以后再补充）</h2>","excerpt":"","more":"<h1 id=\"数据库系统原理\"><a href=\"#数据库系统原理\" class=\"headerlink\" title=\"数据库系统原理\"></a>数据库系统原理</h1><p><a href=\"https://zhuanlan.zhihu.com/p/476601594\">https://zhuanlan.zhihu.com/p/476601594</a></p>\n<p><a href=\"https://blog.csdn.net/Xupixel/article/details/120405501\">https://blog.csdn.net/Xupixel/article/details/120405501</a></p>\n<p><a href=\"https://www.hwpo.top/posts/d87f7e0c/index.html\">https://www.hwpo.top/posts/d87f7e0c/index.html</a></p>\n<p><a href=\"https://developer.aliyun.com/article/815625\">https://developer.aliyun.com/article/815625</a></p>\n<h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220740283.png\"></p>\n<h4 id=\"1-原子性（Atomicity）\"><a href=\"#1-原子性（Atomicity）\" class=\"headerlink\" title=\"1. 原子性（Atomicity）\"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>\n<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>\n<h4 id=\"2-一致性（Consistency）\"><a href=\"#2-一致性（Consistency）\" class=\"headerlink\" title=\"2. 一致性（Consistency）\"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）</p>\n<h4 id=\"3-隔离性（Isolation）\"><a href=\"#3-隔离性（Isolation）\" class=\"headerlink\" title=\"3. 隔离性（Isolation）\"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>\n<h4 id=\"4-持久性（Durability）\"><a href=\"#4-持久性（Durability）\" class=\"headerlink\" title=\"4. 持久性（Durability）\"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>\n<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>\n<hr>\n<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>\n<ul>\n<li>只有满足一致性，事务的执行结果才是正确的。</li>\n<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>\n<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>\n<li>事务满足持久化是为了能应对系统崩溃的情况。</li>\n</ul>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220943892.png\"></p>\n<h3 id=\"AUTOCOMMIT\"><a href=\"#AUTOCOMMIT\" class=\"headerlink\" title=\"AUTOCOMMIT\"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>\n<h2 id=\"二、并发一致性问题\"><a href=\"#二、并发一致性问题\" class=\"headerlink\" title=\"二、并发一致性问题\"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221024695.png\"></p>\n<h3 id=\"读脏数据\"><a href=\"#读脏数据\" class=\"headerlink\" title=\"读脏数据\"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221039549.png\"></p>\n<h3 id=\"不可重复读（读已提交导致）\"><a href=\"#不可重复读（读已提交导致）\" class=\"headerlink\" title=\"不可重复读（读已提交导致）\"></a>不可重复读（读已提交导致）</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221109092.png\"></p>\n<h3 id=\"幻影读\"><a href=\"#幻影读\" class=\"headerlink\" title=\"幻影读\"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221128098.png\"></p>\n<p>解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>\n<h2 id=\"三、封锁\"><a href=\"#三、封锁\" class=\"headerlink\" title=\"三、封锁\"></a>三、封锁</h2><h3 id=\"封锁粒度\"><a href=\"#封锁粒度\" class=\"headerlink\" title=\"封锁粒度\"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>\n<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>\n<h3 id=\"封锁类型\"><a href=\"#封锁类型\" class=\"headerlink\" title=\"封锁类型\"></a>封锁类型</h3><h4 id=\"1-读写锁\"><a href=\"#1-读写锁\" class=\"headerlink\" title=\"1. 读写锁\"></a>1. 读写锁</h4><ul>\n<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>\n<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>\n</ul>\n<p>有以下两个规定：</p>\n<ul>\n<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>\n</ul>\n<p>锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222609279.png\"></p>\n<h4 id=\"2-意向锁\"><a href=\"#2-意向锁\" class=\"headerlink\" title=\"2. 意向锁\"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>\n<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>\n<p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，IX&#x2F;IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>\n<ul>\n<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>\n<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>\n</ul>\n<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>\n<p>各种锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222621455.png\"></p>\n<h3 id=\"封锁协议\"><a href=\"#封锁协议\" class=\"headerlink\" title=\"封锁协议\"></a>封锁协议</h3><h4 id=\"1-三级封锁协议\"><a href=\"#1-三级封锁协议\" class=\"headerlink\" title=\"1. 三级封锁协议\"></a>1. 三级封锁协议</h4><p><strong>一级封锁协议</strong></p>\n<p>事务 T 要修改数据 A 时必须加<strong>X 锁</strong>，直到 <strong>T 结束</strong>才释放锁。</p>\n<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222801904.png\"></p>\n<p><strong>二级封锁协议</strong></p>\n<p>在一级的基础上，要求读取数据 A 时必须加 <strong>S 锁</strong>，<strong>读取完</strong>马上释放 S 锁。</p>\n<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222832886.png\"></p>\n<p><strong>三级封锁协议</strong></p>\n<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>\n<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222857283.png\"></p>\n<h4 id=\"2-两段锁协议\"><a href=\"#2-两段锁协议\" class=\"headerlink\" title=\"2. 两段锁协议\"></a>2. 两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>\n<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>\n<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>\n\n<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MySQL-隐式与显式锁定\"><a href=\"#MySQL-隐式与显式锁定\" class=\"headerlink\" title=\"MySQL 隐式与显式锁定\"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>\n<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ... LOCK In SHARE MODE;</span><br><span class=\"line\">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、隔离级别\"><a href=\"#四、隔离级别\" class=\"headerlink\" title=\"四、隔离级别\"></a>四、隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>\n<h3 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319223152453.png\"></p>\n<h2 id=\"五、多版本并发控制（暂时没见过）\"><a href=\"#五、多版本并发控制（暂时没见过）\" class=\"headerlink\" title=\"五、多版本并发控制（暂时没见过）\"></a>五、多版本并发控制（暂时没见过）</h2><h2 id=\"六、Next-Key-Locks（暂时没见过）\"><a href=\"#六、Next-Key-Locks（暂时没见过）\" class=\"headerlink\" title=\"六、Next-Key Locks（暂时没见过）\"></a>六、Next-Key Locks（暂时没见过）</h2><h2 id=\"七、关系数据库设计理论（以后补充完整）\"><a href=\"#七、关系数据库设计理论（以后补充完整）\" class=\"headerlink\" title=\"七、关系数据库设计理论（以后补充完整）\"></a>七、关系数据库设计理论（以后补充完整）</h2><h3 id=\"函数依赖\"><a href=\"#函数依赖\" class=\"headerlink\" title=\"函数依赖\"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>\n<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>\n<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>\n<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>\n<h4 id=\"1-第一范式-1NF\"><a href=\"#1-第一范式-1NF\" class=\"headerlink\" title=\"1. 第一范式 (1NF)\"></a>1. 第一范式 (1NF)</h4><p>属性不可分。满足原子性。</p>\n<h4 id=\"2-第二范式-2NF\"><a href=\"#2-第二范式-2NF\" class=\"headerlink\" title=\"2. 第二范式 (2NF)\"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。消除部分依赖。</p>\n<h4 id=\"3-第三范式-3NF\"><a href=\"#3-第三范式-3NF\" class=\"headerlink\" title=\"3. 第三范式 (3NF)\"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。消除传递依赖。</p>\n<h2 id=\"八、ER-图（以后再补充）\"><a href=\"#八、ER-图（以后再补充）\" class=\"headerlink\" title=\"八、ER 图（以后再补充）\"></a>八、ER 图（以后再补充）</h2>"},{"title":"what the fuck","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: what the fuck\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-03-19T13:00:06.749Z","updated":"2024-03-19T13:13:30.145Z","comments":1,"layout":"post","photos":[],"_id":"cltzd0oo600011kcg6jyxgrm1","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"mysql","date":"2024-03-19T15:02:31.000Z","_content":"\n# MySQL\n\n## 一、索引\n\n### B+ Tree原理\n\n#### 1. 数据结构\n\nB Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n#### 2. 操作\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。\n\n#### 3. 与红黑树的比较\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。\n\n（一）B+ 树有更低的树高\n\n平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。\n\n（二）磁盘访问原理\n\n一次I/O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n\n寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。\n\n（三）磁盘预读特性\n\n能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n### MySQL 索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\n#### 1. B+ Tree索引\n\n是大多数 MySQL 存储引擎的默认索引类型。\n\n查找速度快：只需要对树进行搜索。\n\n可用于排序和分组：B+ Tree的有序性。\n\n适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\n\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。\n\n主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n![image-20240319231655495](mysql/image-20240319231655495.png)\n\n辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n![image-20240319231743225](mysql/image-20240319231743225.png)\n\n#### 2. 哈希索引\n\n哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n\n- 无法用于排序与分组；\n- 只支持精确查找，无法用于部分查找和范围查找。\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n#### 3. 全文索引（没见过，韩了）\n\nInnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n\n查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n\n全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\n\n#### 4. 空间数据索引（没见过，韩了）\n\nMyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n\n必须使用 GIS 相关的函数来维护数据。\n\n### 索引优化\n\n#### 1. 独立的列\n\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n\n例如下面的查询不能使用 actor_id 列的索引：\n\n```mysql\nSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n```\n\n#### 2. 多列索引\n\n在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\n\n```mysql\nSELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id = 1 AND film_id = 1;\n```\n\n#### 3. 索引列的顺序\n\n让选择性最强的索引列放在前面。\n\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\n```mysql\nSELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n```\n\n```powershell\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049\n```\n\n#### 4. 前缀索引\n\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n\n前缀长度的选取需要根据索引选择性来确定。\n\n#### 5. 覆盖索引\n\n创建包含所有需要查询的字段的索引。\n\n具有以下优点：\n\n- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n### 索引的优点\n\n- 减少服务器扫描的行数\n- 帮助服务器避免排序和分组，以及避免创建临时表。\n- 将随机I/O变为顺序I/O（B+ Tree特性）。\n\n### 索引的使用条件\n\n跟快排差不多，数据量小的时候反而不如暴力。\n\n- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n- 对于中到大型的表，索引就非常有效；\n- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n## 二、查询性能优化\n\n### 使用 Explain 进行分析\n\nExplain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。\n\n比较重要的字段有：\n\n- select_type : 查询类型，有简单查询、联合查询、子查询等\n- key : 使用的索引\n- rows : 扫描的行数\n\n### 优化数据访问\n\n#### 1. 减少请求的数据量\n\n- 只返回必要的列：最好不要使用 SELECT * 语句。\n- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。\n- **缓存**重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。\n\n#### 2. 减少服务器端扫描的行数\n\n索引覆盖查询。\n\n### 重构查询方式\n\n#### 1. 切分大查询\n\n将大查询切分成多个小查询。\n\n一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。\n\n```mysql\nDELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);\n```\n\n```c++\nrows_affected = 0\ndo {\n    rows_affected = do_query(\n    \"DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\")\n} while rows_affected > 0\n```\n\n#### 2. 分解大连接查询\n\n将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：\n\n- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。\n- 减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。\n- 减少锁竞争。\n- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。\n- 查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。\n\n```mysql\nSELECT * FROM tag\nJOIN tag_post ON tag_post.tag_id=tag.id\nJOIN post ON tag_post.post_id=post.id\nWHERE tag.tag='mysql';\n```\n\n```mysql\nSELECT * FROM tag WHERE tag='mysql';\nSELECT * FROM tag_post WHERE tag_id=1234;\nSELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);\n```\n\n## 三、存储引擎\n\n### InnoDB\n\n是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n\n实现了四个标准的隔离级别，默认级别是可重复读。\n\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n","source":"_posts/mysql.md","raw":"---\ntitle: mysql\ndate: 2024-03-19 23:02:31\ntags:\n---\n\n# MySQL\n\n## 一、索引\n\n### B+ Tree原理\n\n#### 1. 数据结构\n\nB Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n#### 2. 操作\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。\n\n#### 3. 与红黑树的比较\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。\n\n（一）B+ 树有更低的树高\n\n平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。\n\n（二）磁盘访问原理\n\n一次I/O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n\n寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。\n\n（三）磁盘预读特性\n\n能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n### MySQL 索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\n#### 1. B+ Tree索引\n\n是大多数 MySQL 存储引擎的默认索引类型。\n\n查找速度快：只需要对树进行搜索。\n\n可用于排序和分组：B+ Tree的有序性。\n\n适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\n\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。\n\n主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n![image-20240319231655495](mysql/image-20240319231655495.png)\n\n辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n![image-20240319231743225](mysql/image-20240319231743225.png)\n\n#### 2. 哈希索引\n\n哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n\n- 无法用于排序与分组；\n- 只支持精确查找，无法用于部分查找和范围查找。\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n#### 3. 全文索引（没见过，韩了）\n\nInnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n\n查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n\n全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\n\n#### 4. 空间数据索引（没见过，韩了）\n\nMyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n\n必须使用 GIS 相关的函数来维护数据。\n\n### 索引优化\n\n#### 1. 独立的列\n\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n\n例如下面的查询不能使用 actor_id 列的索引：\n\n```mysql\nSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n```\n\n#### 2. 多列索引\n\n在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\n\n```mysql\nSELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id = 1 AND film_id = 1;\n```\n\n#### 3. 索引列的顺序\n\n让选择性最强的索引列放在前面。\n\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\n```mysql\nSELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n```\n\n```powershell\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049\n```\n\n#### 4. 前缀索引\n\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n\n前缀长度的选取需要根据索引选择性来确定。\n\n#### 5. 覆盖索引\n\n创建包含所有需要查询的字段的索引。\n\n具有以下优点：\n\n- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n### 索引的优点\n\n- 减少服务器扫描的行数\n- 帮助服务器避免排序和分组，以及避免创建临时表。\n- 将随机I/O变为顺序I/O（B+ Tree特性）。\n\n### 索引的使用条件\n\n跟快排差不多，数据量小的时候反而不如暴力。\n\n- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n- 对于中到大型的表，索引就非常有效；\n- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n## 二、查询性能优化\n\n### 使用 Explain 进行分析\n\nExplain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。\n\n比较重要的字段有：\n\n- select_type : 查询类型，有简单查询、联合查询、子查询等\n- key : 使用的索引\n- rows : 扫描的行数\n\n### 优化数据访问\n\n#### 1. 减少请求的数据量\n\n- 只返回必要的列：最好不要使用 SELECT * 语句。\n- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。\n- **缓存**重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。\n\n#### 2. 减少服务器端扫描的行数\n\n索引覆盖查询。\n\n### 重构查询方式\n\n#### 1. 切分大查询\n\n将大查询切分成多个小查询。\n\n一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。\n\n```mysql\nDELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);\n```\n\n```c++\nrows_affected = 0\ndo {\n    rows_affected = do_query(\n    \"DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\")\n} while rows_affected > 0\n```\n\n#### 2. 分解大连接查询\n\n将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：\n\n- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。\n- 减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。\n- 减少锁竞争。\n- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。\n- 查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。\n\n```mysql\nSELECT * FROM tag\nJOIN tag_post ON tag_post.tag_id=tag.id\nJOIN post ON tag_post.post_id=post.id\nWHERE tag.tag='mysql';\n```\n\n```mysql\nSELECT * FROM tag WHERE tag='mysql';\nSELECT * FROM tag_post WHERE tag_id=1234;\nSELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);\n```\n\n## 三、存储引擎\n\n### InnoDB\n\n是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n\n实现了四个标准的隔离级别，默认级别是可重复读。\n\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n","slug":"mysql","published":1,"updated":"2024-03-19T15:44:37.340Z","comments":1,"layout":"post","photos":[],"_id":"cltzd0oo800021kcgh5ag9gnx","content":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"一、索引\"><a href=\"#一、索引\" class=\"headerlink\" title=\"一、索引\"></a>一、索引</h2><h3 id=\"B-Tree原理\"><a href=\"#B-Tree原理\" class=\"headerlink\" title=\"B+ Tree原理\"></a>B+ Tree原理</h3><h4 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1. 数据结构\"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<h4 id=\"2-操作\"><a href=\"#2-操作\" class=\"headerlink\" title=\"2. 操作\"></a>2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>\n<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>\n<h4 id=\"3-与红黑树的比较\"><a href=\"#3-与红黑树的比较\" class=\"headerlink\" title=\"3. 与红黑树的比较\"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。</p>\n<p>（一）B+ 树有更低的树高</p>\n<p>平衡树的树高 O(h)&#x3D;O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>\n<p>（二）磁盘访问原理</p>\n<p>一次I&#x2F;O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。</p>\n<p>寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>\n<p>（三）磁盘预读特性</p>\n<p>能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I&#x2F;O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<h3 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>\n<h4 id=\"1-B-Tree索引\"><a href=\"#1-B-Tree索引\" class=\"headerlink\" title=\"1. B+ Tree索引\"></a>1. B+ Tree索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p>\n<p>查找速度快：只需要对树进行搜索。</p>\n<p>可用于排序和分组：B+ Tree的有序性。</p>\n<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>\n<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>\n<p>主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231655495.png\"></p>\n<p>辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231743225.png\"></p>\n<h4 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>\n<ul>\n<li>无法用于排序与分组；</li>\n<li>只支持精确查找，无法用于部分查找和范围查找。</li>\n</ul>\n<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n<h4 id=\"3-全文索引（没见过，韩了）\"><a href=\"#3-全文索引（没见过，韩了）\" class=\"headerlink\" title=\"3. 全文索引（没见过，韩了）\"></a>3. 全文索引（没见过，韩了）</h4><p>InnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>\n<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>\n<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>\n<h4 id=\"4-空间数据索引（没见过，韩了）\"><a href=\"#4-空间数据索引（没见过，韩了）\" class=\"headerlink\" title=\"4. 空间数据索引（没见过，韩了）\"></a>4. 空间数据索引（没见过，韩了）</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>\n<p>必须使用 GIS 相关的函数来维护数据。</p>\n<h3 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h3><h4 id=\"1-独立的列\"><a href=\"#1-独立的列\" class=\"headerlink\" title=\"1. 独立的列\"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>\n<p>例如下面的查询不能使用 actor_id 列的索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-多列索引\"><a href=\"#2-多列索引\" class=\"headerlink\" title=\"2. 多列索引\"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class=\"line\">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-索引列的顺序\"><a href=\"#3-索引列的顺序\" class=\"headerlink\" title=\"3. 索引列的顺序\"></a>3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p>\n<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>\n<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class=\"line\">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class=\"line\">COUNT(*)</span><br><span class=\"line\">FROM payment;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   staff_id_selectivity: <span class=\"number\">0.0001</span></span><br><span class=\"line\">customer_id_selectivity: <span class=\"number\">0.0373</span></span><br><span class=\"line\">               COUNT(*): <span class=\"number\">16049</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-前缀索引\"><a href=\"#4-前缀索引\" class=\"headerlink\" title=\"4. 前缀索引\"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>\n<p>前缀长度的选取需要根据索引选择性来确定。</p>\n<h4 id=\"5-覆盖索引\"><a href=\"#5-覆盖索引\" class=\"headerlink\" title=\"5. 覆盖索引\"></a>5. 覆盖索引</h4><p>创建包含所有需要查询的字段的索引。</p>\n<p>具有以下优点：</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>\n<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>\n<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>\n</ul>\n<h3 id=\"索引的优点\"><a href=\"#索引的优点\" class=\"headerlink\" title=\"索引的优点\"></a>索引的优点</h3><ul>\n<li>减少服务器扫描的行数</li>\n<li>帮助服务器避免排序和分组，以及避免创建临时表。</li>\n<li>将随机I&#x2F;O变为顺序I&#x2F;O（B+ Tree特性）。</li>\n</ul>\n<h3 id=\"索引的使用条件\"><a href=\"#索引的使用条件\" class=\"headerlink\" title=\"索引的使用条件\"></a>索引的使用条件</h3><p>跟快排差不多，数据量小的时候反而不如暴力。</p>\n<ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>\n</ul>\n<h2 id=\"二、查询性能优化\"><a href=\"#二、查询性能优化\" class=\"headerlink\" title=\"二、查询性能优化\"></a>二、查询性能优化</h2><h3 id=\"使用-Explain-进行分析\"><a href=\"#使用-Explain-进行分析\" class=\"headerlink\" title=\"使用 Explain 进行分析\"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>\n<p>比较重要的字段有：</p>\n<ul>\n<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>\n<li>key : 使用的索引</li>\n<li>rows : 扫描的行数</li>\n</ul>\n<h3 id=\"优化数据访问\"><a href=\"#优化数据访问\" class=\"headerlink\" title=\"优化数据访问\"></a>优化数据访问</h3><h4 id=\"1-减少请求的数据量\"><a href=\"#1-减少请求的数据量\" class=\"headerlink\" title=\"1. 减少请求的数据量\"></a>1. 减少请求的数据量</h4><ul>\n<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>\n<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>\n<li><strong>缓存</strong>重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>\n</ul>\n<h4 id=\"2-减少服务器端扫描的行数\"><a href=\"#2-减少服务器端扫描的行数\" class=\"headerlink\" title=\"2. 减少服务器端扫描的行数\"></a>2. 减少服务器端扫描的行数</h4><p>索引覆盖查询。</p>\n<h3 id=\"重构查询方式\"><a href=\"#重构查询方式\" class=\"headerlink\" title=\"重构查询方式\"></a>重构查询方式</h3><h4 id=\"1-切分大查询\"><a href=\"#1-切分大查询\" class=\"headerlink\" title=\"1. 切分大查询\"></a>1. 切分大查询</h4><p>将大查询切分成多个小查询。</p>\n<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rows_affected = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    rows_affected = <span class=\"built_in\">do_query</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> rows_affected &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-分解大连接查询\"><a href=\"#2-分解大连接查询\" class=\"headerlink\" title=\"2. 分解大连接查询\"></a>2. 分解大连接查询</h4><p>将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：</p>\n<ul>\n<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>\n<li>减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。</li>\n<li>减少锁竞争。</li>\n<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>\n<li>查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag</span><br><span class=\"line\">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class=\"line\">JOIN post ON tag_post.post_id=post.id</span><br><span class=\"line\">WHERE tag.tag=&#x27;mysql&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;</span><br><span class=\"line\">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class=\"line\">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、存储引擎\"><a href=\"#三、存储引擎\" class=\"headerlink\" title=\"三、存储引擎\"></a>三、存储引擎</h2><h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>\n<p>实现了四个标准的隔离级别，默认级别是可重复读。</p>\n<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>\n<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>\n<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>\n","excerpt":"","more":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"一、索引\"><a href=\"#一、索引\" class=\"headerlink\" title=\"一、索引\"></a>一、索引</h2><h3 id=\"B-Tree原理\"><a href=\"#B-Tree原理\" class=\"headerlink\" title=\"B+ Tree原理\"></a>B+ Tree原理</h3><h4 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1. 数据结构\"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<h4 id=\"2-操作\"><a href=\"#2-操作\" class=\"headerlink\" title=\"2. 操作\"></a>2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>\n<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>\n<h4 id=\"3-与红黑树的比较\"><a href=\"#3-与红黑树的比较\" class=\"headerlink\" title=\"3. 与红黑树的比较\"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。</p>\n<p>（一）B+ 树有更低的树高</p>\n<p>平衡树的树高 O(h)&#x3D;O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>\n<p>（二）磁盘访问原理</p>\n<p>一次I&#x2F;O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。</p>\n<p>寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>\n<p>（三）磁盘预读特性</p>\n<p>能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I&#x2F;O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<h3 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>\n<h4 id=\"1-B-Tree索引\"><a href=\"#1-B-Tree索引\" class=\"headerlink\" title=\"1. B+ Tree索引\"></a>1. B+ Tree索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p>\n<p>查找速度快：只需要对树进行搜索。</p>\n<p>可用于排序和分组：B+ Tree的有序性。</p>\n<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>\n<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>\n<p>主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231655495.png\"></p>\n<p>辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231743225.png\"></p>\n<h4 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>\n<ul>\n<li>无法用于排序与分组；</li>\n<li>只支持精确查找，无法用于部分查找和范围查找。</li>\n</ul>\n<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n<h4 id=\"3-全文索引（没见过，韩了）\"><a href=\"#3-全文索引（没见过，韩了）\" class=\"headerlink\" title=\"3. 全文索引（没见过，韩了）\"></a>3. 全文索引（没见过，韩了）</h4><p>InnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>\n<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>\n<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>\n<h4 id=\"4-空间数据索引（没见过，韩了）\"><a href=\"#4-空间数据索引（没见过，韩了）\" class=\"headerlink\" title=\"4. 空间数据索引（没见过，韩了）\"></a>4. 空间数据索引（没见过，韩了）</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>\n<p>必须使用 GIS 相关的函数来维护数据。</p>\n<h3 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h3><h4 id=\"1-独立的列\"><a href=\"#1-独立的列\" class=\"headerlink\" title=\"1. 独立的列\"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>\n<p>例如下面的查询不能使用 actor_id 列的索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-多列索引\"><a href=\"#2-多列索引\" class=\"headerlink\" title=\"2. 多列索引\"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class=\"line\">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-索引列的顺序\"><a href=\"#3-索引列的顺序\" class=\"headerlink\" title=\"3. 索引列的顺序\"></a>3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p>\n<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>\n<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class=\"line\">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class=\"line\">COUNT(*)</span><br><span class=\"line\">FROM payment;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   staff_id_selectivity: <span class=\"number\">0.0001</span></span><br><span class=\"line\">customer_id_selectivity: <span class=\"number\">0.0373</span></span><br><span class=\"line\">               COUNT(*): <span class=\"number\">16049</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-前缀索引\"><a href=\"#4-前缀索引\" class=\"headerlink\" title=\"4. 前缀索引\"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>\n<p>前缀长度的选取需要根据索引选择性来确定。</p>\n<h4 id=\"5-覆盖索引\"><a href=\"#5-覆盖索引\" class=\"headerlink\" title=\"5. 覆盖索引\"></a>5. 覆盖索引</h4><p>创建包含所有需要查询的字段的索引。</p>\n<p>具有以下优点：</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>\n<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>\n<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>\n</ul>\n<h3 id=\"索引的优点\"><a href=\"#索引的优点\" class=\"headerlink\" title=\"索引的优点\"></a>索引的优点</h3><ul>\n<li>减少服务器扫描的行数</li>\n<li>帮助服务器避免排序和分组，以及避免创建临时表。</li>\n<li>将随机I&#x2F;O变为顺序I&#x2F;O（B+ Tree特性）。</li>\n</ul>\n<h3 id=\"索引的使用条件\"><a href=\"#索引的使用条件\" class=\"headerlink\" title=\"索引的使用条件\"></a>索引的使用条件</h3><p>跟快排差不多，数据量小的时候反而不如暴力。</p>\n<ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>\n</ul>\n<h2 id=\"二、查询性能优化\"><a href=\"#二、查询性能优化\" class=\"headerlink\" title=\"二、查询性能优化\"></a>二、查询性能优化</h2><h3 id=\"使用-Explain-进行分析\"><a href=\"#使用-Explain-进行分析\" class=\"headerlink\" title=\"使用 Explain 进行分析\"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>\n<p>比较重要的字段有：</p>\n<ul>\n<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>\n<li>key : 使用的索引</li>\n<li>rows : 扫描的行数</li>\n</ul>\n<h3 id=\"优化数据访问\"><a href=\"#优化数据访问\" class=\"headerlink\" title=\"优化数据访问\"></a>优化数据访问</h3><h4 id=\"1-减少请求的数据量\"><a href=\"#1-减少请求的数据量\" class=\"headerlink\" title=\"1. 减少请求的数据量\"></a>1. 减少请求的数据量</h4><ul>\n<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>\n<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>\n<li><strong>缓存</strong>重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>\n</ul>\n<h4 id=\"2-减少服务器端扫描的行数\"><a href=\"#2-减少服务器端扫描的行数\" class=\"headerlink\" title=\"2. 减少服务器端扫描的行数\"></a>2. 减少服务器端扫描的行数</h4><p>索引覆盖查询。</p>\n<h3 id=\"重构查询方式\"><a href=\"#重构查询方式\" class=\"headerlink\" title=\"重构查询方式\"></a>重构查询方式</h3><h4 id=\"1-切分大查询\"><a href=\"#1-切分大查询\" class=\"headerlink\" title=\"1. 切分大查询\"></a>1. 切分大查询</h4><p>将大查询切分成多个小查询。</p>\n<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rows_affected = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    rows_affected = <span class=\"built_in\">do_query</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> rows_affected &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-分解大连接查询\"><a href=\"#2-分解大连接查询\" class=\"headerlink\" title=\"2. 分解大连接查询\"></a>2. 分解大连接查询</h4><p>将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：</p>\n<ul>\n<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>\n<li>减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。</li>\n<li>减少锁竞争。</li>\n<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>\n<li>查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag</span><br><span class=\"line\">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class=\"line\">JOIN post ON tag_post.post_id=post.id</span><br><span class=\"line\">WHERE tag.tag=&#x27;mysql&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;</span><br><span class=\"line\">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class=\"line\">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、存储引擎\"><a href=\"#三、存储引擎\" class=\"headerlink\" title=\"三、存储引擎\"></a>三、存储引擎</h2><h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>\n<p>实现了四个标准的隔离级别，默认级别是可重复读。</p>\n<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>\n<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>\n<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>\n"},{"title":"socket","date":"2024-03-20T03:01:14.000Z","toc":true,"_content":"\n# Socket\n\n## 一、I/O 模型\n\n一个输入操作通常包括两个阶段：\n\n- 等待数据准备好\n- 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nUnix 有五种 I/O 模型：\n\n- 阻塞式I/O\n- 非阻塞式I/O\n- I/O多路复用（select和poll）\n- 信号驱动式I/O（SIGIO）\n- 异步I/O（AIO）\n\n### 阻塞式I/O\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。\n\n下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\n```c\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n```\n\n![image-20240320110531226](socket/image-20240320110531226.png)\n\n### 非阻塞式 I/O\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为**轮询（polling）**。\n\n由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。\n\n![image-20240320110625558](socket/image-20240320110625558.png)\n\n### I/O 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O（对这句保持质疑）。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n![image-20240320111122789](socket/image-20240320111122789.png)\n\n### 信号驱动 I/O\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n![image-20240320120005597](socket/image-20240320120005597.png)\n\n### 异步 I/O\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步是通知应用进程I/O完成，信号驱动是通知可以开始I/O。\n\n### 五大 I/O 模型比较\n\n- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。\n- 异步 I/O：第二阶段应用进程不会阻塞。\n\n除了异步I/O，其它的都是同步I/O。\n\n非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。\n\n![image-20240320120231930](socket/image-20240320120231930.png)\n\n## 二、I/O 复用\n\nselect/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n### select\n\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n```\n\nselect 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。\n\n- fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听**少于 FD_SETSIZE 数量**的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。\n- timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。\n- 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。\n\n### poll\n\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout);\n```\n\npoll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。\n\n### 比较\n\n#### 1. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n- select 会修改描述符，而 poll 不会；\n- select监听的描述符数量比poll少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；\n- poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n- 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n#### 2. 速度\n\nselect 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n\n#### 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n### epoll\n\n```c\nint epoll_create(int size);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵**红黑树**上，通过回调函数内核会将 I/O **准备好的描述符加入到一个链表中**管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。\n\n从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 Linux OS。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n### 工作模式\n\nepoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。\n\n#### 1. LT 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以**不立即处理**该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n#### 2. ET 模式\n\n和 LT 模式不同的是，通知之后进程必须**立即处理**事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n### 应用场景\n\n#### 1. select 应用场景\n\n实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。\n\n可移植性。几乎被所有主流平台所支持。\n\n#### 2. poll 应用场景\n\n实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。\n\n#### 3. epoll 应用场景\n\n只需要运行在Linux上，有大量描述符需要监控，并且连接为长连接。\n\n少于1000的描述符没必要用。\n\n描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。\n","source":"_posts/socket.md","raw":"---\ntitle: socket\ndate: 2024-03-20 11:01:14\ntags: computer-networks\ntoc: true\n---\n\n# Socket\n\n## 一、I/O 模型\n\n一个输入操作通常包括两个阶段：\n\n- 等待数据准备好\n- 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nUnix 有五种 I/O 模型：\n\n- 阻塞式I/O\n- 非阻塞式I/O\n- I/O多路复用（select和poll）\n- 信号驱动式I/O（SIGIO）\n- 异步I/O（AIO）\n\n### 阻塞式I/O\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。\n\n下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\n```c\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n```\n\n![image-20240320110531226](socket/image-20240320110531226.png)\n\n### 非阻塞式 I/O\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为**轮询（polling）**。\n\n由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。\n\n![image-20240320110625558](socket/image-20240320110625558.png)\n\n### I/O 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O（对这句保持质疑）。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n![image-20240320111122789](socket/image-20240320111122789.png)\n\n### 信号驱动 I/O\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n![image-20240320120005597](socket/image-20240320120005597.png)\n\n### 异步 I/O\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步是通知应用进程I/O完成，信号驱动是通知可以开始I/O。\n\n### 五大 I/O 模型比较\n\n- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。\n- 异步 I/O：第二阶段应用进程不会阻塞。\n\n除了异步I/O，其它的都是同步I/O。\n\n非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。\n\n![image-20240320120231930](socket/image-20240320120231930.png)\n\n## 二、I/O 复用\n\nselect/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n### select\n\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n```\n\nselect 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。\n\n- fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听**少于 FD_SETSIZE 数量**的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。\n- timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。\n- 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。\n\n### poll\n\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout);\n```\n\npoll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。\n\n### 比较\n\n#### 1. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n- select 会修改描述符，而 poll 不会；\n- select监听的描述符数量比poll少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；\n- poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n- 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n#### 2. 速度\n\nselect 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n\n#### 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n### epoll\n\n```c\nint epoll_create(int size);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵**红黑树**上，通过回调函数内核会将 I/O **准备好的描述符加入到一个链表中**管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。\n\n从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 Linux OS。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n### 工作模式\n\nepoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。\n\n#### 1. LT 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以**不立即处理**该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n#### 2. ET 模式\n\n和 LT 模式不同的是，通知之后进程必须**立即处理**事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n### 应用场景\n\n#### 1. select 应用场景\n\n实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。\n\n可移植性。几乎被所有主流平台所支持。\n\n#### 2. poll 应用场景\n\n实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。\n\n#### 3. epoll 应用场景\n\n只需要运行在Linux上，有大量描述符需要监控，并且连接为长连接。\n\n少于1000的描述符没必要用。\n\n描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。\n","slug":"socket","published":1,"updated":"2024-03-20T05:06:20.763Z","comments":1,"layout":"post","photos":[],"_id":"cltzd0oo900031kcgd1up0s6o","content":"<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1><h2 id=\"一、I-O-模型\"><a href=\"#一、I-O-模型\" class=\"headerlink\" title=\"一、I&#x2F;O 模型\"></a>一、I&#x2F;O 模型</h2><p>一个输入操作通常包括两个阶段：</p>\n<ul>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ul>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p>Unix 有五种 I&#x2F;O 模型：</p>\n<ul>\n<li>阻塞式I&#x2F;O</li>\n<li>非阻塞式I&#x2F;O</li>\n<li>I&#x2F;O多路复用（select和poll）</li>\n<li>信号驱动式I&#x2F;O（SIGIO）</li>\n<li>异步I&#x2F;O（AIO）</li>\n</ul>\n<h3 id=\"阻塞式I-O\"><a href=\"#阻塞式I-O\" class=\"headerlink\" title=\"阻塞式I&#x2F;O\"></a>阻塞式I&#x2F;O</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>\n<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>\n<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">recvfrom</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags, <span class=\"keyword\">struct</span> sockaddr *src_addr, <span class=\"type\">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/03/20/socket/image-20240320110531226.png\"></p>\n<h3 id=\"非阻塞式-I-O\"><a href=\"#非阻塞式-I-O\" class=\"headerlink\" title=\"非阻塞式 I&#x2F;O\"></a>非阻塞式 I&#x2F;O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为<strong>轮询（polling）</strong>。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320110625558.png\"></p>\n<h3 id=\"I-O-复用\"><a href=\"#I-O-复用\" class=\"headerlink\" title=\"I&#x2F;O 复用\"></a>I&#x2F;O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。</p>\n<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O（对这句保持质疑）。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320111122789.png\"></p>\n<h3 id=\"信号驱动-I-O\"><a href=\"#信号驱动-I-O\" class=\"headerlink\" title=\"信号驱动 I&#x2F;O\"></a>信号驱动 I&#x2F;O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120005597.png\"></p>\n<h3 id=\"异步-I-O\"><a href=\"#异步-I-O\" class=\"headerlink\" title=\"异步 I&#x2F;O\"></a>异步 I&#x2F;O</h3><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步是通知应用进程I&#x2F;O完成，信号驱动是通知可以开始I&#x2F;O。</p>\n<h3 id=\"五大-I-O-模型比较\"><a href=\"#五大-I-O-模型比较\" class=\"headerlink\" title=\"五大 I&#x2F;O 模型比较\"></a>五大 I&#x2F;O 模型比较</h3><ul>\n<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>\n<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li>\n</ul>\n<p>除了异步I&#x2F;O，其它的都是同步I&#x2F;O。</p>\n<p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120231930.png\"></p>\n<h2 id=\"二、I-O-复用\"><a href=\"#二、I-O-复用\" class=\"headerlink\" title=\"二、I&#x2F;O 复用\"></a>二、I&#x2F;O 复用</h2><p>select&#x2F;poll&#x2F;epoll 都是 I&#x2F;O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>\n<h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I&#x2F;O 操作。</p>\n<ul>\n<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听<strong>少于 FD_SETSIZE 数量</strong>的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>\n<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>\n<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>\n</ul>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><h4 id=\"1-功能\"><a href=\"#1-功能\" class=\"headerlink\" title=\"1. 功能\"></a>1. 功能</h4><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>\n<ul>\n<li>select 会修改描述符，而 poll 不会；</li>\n<li>select监听的描述符数量比poll少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>\n<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>\n<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>\n</ul>\n<h4 id=\"2-速度\"><a href=\"#2-速度\" class=\"headerlink\" title=\"2. 速度\"></a>2. 速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>\n<h4 id=\"3-可移植性\"><a href=\"#3-可移植性\" class=\"headerlink\" title=\"3. 可移植性\"></a>3. 可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>\n<h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>；</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，通过回调函数内核会将 I&#x2F;O <strong>准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>\n<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>\n<p>epoll 仅适用于 Linux OS。</p>\n<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>\n<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>\n<h3 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>\n<h4 id=\"1-LT-模式\"><a href=\"#1-LT-模式\" class=\"headerlink\" title=\"1. LT 模式\"></a>1. LT 模式</h4><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以<strong>不立即处理</strong>该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>\n<h4 id=\"2-ET-模式\"><a href=\"#2-ET-模式\" class=\"headerlink\" title=\"2. ET 模式\"></a>2. ET 模式</h4><p>和 LT 模式不同的是，通知之后进程必须<strong>立即处理</strong>事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>\n<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-select-应用场景\"><a href=\"#1-select-应用场景\" class=\"headerlink\" title=\"1. select 应用场景\"></a>1. select 应用场景</h4><p>实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。</p>\n<p>可移植性。几乎被所有主流平台所支持。</p>\n<h4 id=\"2-poll-应用场景\"><a href=\"#2-poll-应用场景\" class=\"headerlink\" title=\"2. poll 应用场景\"></a>2. poll 应用场景</h4><p>实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。</p>\n<h4 id=\"3-epoll-应用场景\"><a href=\"#3-epoll-应用场景\" class=\"headerlink\" title=\"3. epoll 应用场景\"></a>3. epoll 应用场景</h4><p>只需要运行在Linux上，有大量描述符需要监控，并且连接为长连接。</p>\n<p>少于1000的描述符没必要用。</p>\n<p>描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>\n","excerpt":"","more":"<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1><h2 id=\"一、I-O-模型\"><a href=\"#一、I-O-模型\" class=\"headerlink\" title=\"一、I&#x2F;O 模型\"></a>一、I&#x2F;O 模型</h2><p>一个输入操作通常包括两个阶段：</p>\n<ul>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ul>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p>Unix 有五种 I&#x2F;O 模型：</p>\n<ul>\n<li>阻塞式I&#x2F;O</li>\n<li>非阻塞式I&#x2F;O</li>\n<li>I&#x2F;O多路复用（select和poll）</li>\n<li>信号驱动式I&#x2F;O（SIGIO）</li>\n<li>异步I&#x2F;O（AIO）</li>\n</ul>\n<h3 id=\"阻塞式I-O\"><a href=\"#阻塞式I-O\" class=\"headerlink\" title=\"阻塞式I&#x2F;O\"></a>阻塞式I&#x2F;O</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>\n<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>\n<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">recvfrom</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags, <span class=\"keyword\">struct</span> sockaddr *src_addr, <span class=\"type\">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/03/20/socket/image-20240320110531226.png\"></p>\n<h3 id=\"非阻塞式-I-O\"><a href=\"#非阻塞式-I-O\" class=\"headerlink\" title=\"非阻塞式 I&#x2F;O\"></a>非阻塞式 I&#x2F;O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为<strong>轮询（polling）</strong>。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320110625558.png\"></p>\n<h3 id=\"I-O-复用\"><a href=\"#I-O-复用\" class=\"headerlink\" title=\"I&#x2F;O 复用\"></a>I&#x2F;O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。</p>\n<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O（对这句保持质疑）。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320111122789.png\"></p>\n<h3 id=\"信号驱动-I-O\"><a href=\"#信号驱动-I-O\" class=\"headerlink\" title=\"信号驱动 I&#x2F;O\"></a>信号驱动 I&#x2F;O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120005597.png\"></p>\n<h3 id=\"异步-I-O\"><a href=\"#异步-I-O\" class=\"headerlink\" title=\"异步 I&#x2F;O\"></a>异步 I&#x2F;O</h3><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步是通知应用进程I&#x2F;O完成，信号驱动是通知可以开始I&#x2F;O。</p>\n<h3 id=\"五大-I-O-模型比较\"><a href=\"#五大-I-O-模型比较\" class=\"headerlink\" title=\"五大 I&#x2F;O 模型比较\"></a>五大 I&#x2F;O 模型比较</h3><ul>\n<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>\n<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li>\n</ul>\n<p>除了异步I&#x2F;O，其它的都是同步I&#x2F;O。</p>\n<p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120231930.png\"></p>\n<h2 id=\"二、I-O-复用\"><a href=\"#二、I-O-复用\" class=\"headerlink\" title=\"二、I&#x2F;O 复用\"></a>二、I&#x2F;O 复用</h2><p>select&#x2F;poll&#x2F;epoll 都是 I&#x2F;O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>\n<h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I&#x2F;O 操作。</p>\n<ul>\n<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听<strong>少于 FD_SETSIZE 数量</strong>的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>\n<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>\n<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>\n</ul>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><h4 id=\"1-功能\"><a href=\"#1-功能\" class=\"headerlink\" title=\"1. 功能\"></a>1. 功能</h4><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>\n<ul>\n<li>select 会修改描述符，而 poll 不会；</li>\n<li>select监听的描述符数量比poll少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>\n<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>\n<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>\n</ul>\n<h4 id=\"2-速度\"><a href=\"#2-速度\" class=\"headerlink\" title=\"2. 速度\"></a>2. 速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>\n<h4 id=\"3-可移植性\"><a href=\"#3-可移植性\" class=\"headerlink\" title=\"3. 可移植性\"></a>3. 可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>\n<h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>；</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，通过回调函数内核会将 I&#x2F;O <strong>准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>\n<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>\n<p>epoll 仅适用于 Linux OS。</p>\n<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>\n<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>\n<h3 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>\n<h4 id=\"1-LT-模式\"><a href=\"#1-LT-模式\" class=\"headerlink\" title=\"1. LT 模式\"></a>1. LT 模式</h4><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以<strong>不立即处理</strong>该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>\n<h4 id=\"2-ET-模式\"><a href=\"#2-ET-模式\" class=\"headerlink\" title=\"2. ET 模式\"></a>2. ET 模式</h4><p>和 LT 模式不同的是，通知之后进程必须<strong>立即处理</strong>事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>\n<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-select-应用场景\"><a href=\"#1-select-应用场景\" class=\"headerlink\" title=\"1. select 应用场景\"></a>1. select 应用场景</h4><p>实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。</p>\n<p>可移植性。几乎被所有主流平台所支持。</p>\n<h4 id=\"2-poll-应用场景\"><a href=\"#2-poll-应用场景\" class=\"headerlink\" title=\"2. poll 应用场景\"></a>2. poll 应用场景</h4><p>实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。</p>\n<h4 id=\"3-epoll-应用场景\"><a href=\"#3-epoll-应用场景\" class=\"headerlink\" title=\"3. epoll 应用场景\"></a>3. epoll 应用场景</h4><p>只需要运行在Linux上，有大量描述符需要监控，并且连接为长连接。</p>\n<p>少于1000的描述符没必要用。</p>\n<p>描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>\n"}],"PostAsset":[{"_id":"source/_posts/database-system-principles/image-20240319215933046.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319215933046.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319220740283.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319220740283.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319220943892.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319220943892.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221024695.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319221024695.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221039549.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319221039549.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221109092.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319221109092.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221128098.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319221128098.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222609279.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319222609279.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222621455.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319222621455.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222801904.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319222801904.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222832886.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319222832886.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222857283.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319222857283.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319223152453.png","post":"cltzd0ony00001kcg97lge4gq","slug":"image-20240319223152453.png","modified":1,"renderable":0},{"_id":"source/_posts/mysql/image-20240319231655495.png","post":"cltzd0oo800021kcgh5ag9gnx","slug":"image-20240319231655495.png","modified":1,"renderable":0},{"_id":"source/_posts/mysql/image-20240319231743225.png","post":"cltzd0oo800021kcgh5ag9gnx","slug":"image-20240319231743225.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320110531226.png","post":"cltzd0oo900031kcgd1up0s6o","slug":"image-20240320110531226.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320110625558.png","post":"cltzd0oo900031kcgd1up0s6o","slug":"image-20240320110625558.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320111122789.png","post":"cltzd0oo900031kcgd1up0s6o","slug":"image-20240320111122789.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320120005597.png","post":"cltzd0oo900031kcgd1up0s6o","slug":"image-20240320120005597.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320120231930.png","post":"cltzd0oo900031kcgd1up0s6o","slug":"image-20240320120231930.png","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cltzd0oo900031kcgd1up0s6o","tag_id":"cltzd0ooa00041kcg1it840zx","_id":"cltzd0ood00051kcggljrhwt8"}],"Tag":[{"name":"computer-networks","_id":"cltzd0ooa00041kcg1it840zx"}]}}