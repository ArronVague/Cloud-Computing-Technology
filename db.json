{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":0},{"_id":"source/img/logo.png","path":"img/logo.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/computer-networks.md","hash":"22a6a2082d94a692fd3d5afb1a388f1e056052d3","modified":1711078571678},{"_id":"source/_posts/database-system-principles.md","hash":"d72263378f1dc4b9b8beebe5f713e38d5c7ac26b","modified":1711078571682},{"_id":"source/_posts/golang.md","hash":"f959cd81bc4baedeb363e66269f72d4e40b26b01","modified":1711078571685},{"_id":"source/_posts/hello-world.md","hash":"bbe436200b81686fcca06d9205812c8dde3ac364","modified":1710923063966},{"_id":"source/_posts/hw1.md","hash":"9c1c8ad58342b1ec94fa074ad8b188b8df69a4b2","modified":1711078738809},{"_id":"source/_posts/meituan-interview.md","hash":"7a7a51aacced63970bd4a39ebc9292e758abc301","modified":1711078571686},{"_id":"source/_posts/mysql.md","hash":"8f0ea2b37f10c11ba2f55f3eeeef63c858b1973d","modified":1711078571713},{"_id":"source/_posts/operating-systems.md","hash":"26ae11b753f3749a7fc216fea3d1d0fb2d22af60","modified":1711078571717},{"_id":"source/_posts/socket.md","hash":"e9f2f4592021bf7eaa7f7488329dcdaabae42c9e","modified":1711078571720},{"_id":"source/img/avatar.jpg","hash":"3307e2fcb0c14e66257dfa918d4a6a77b32a49cd","modified":1701753639323},{"_id":"source/img/favicon.svg","hash":"0336619be9767d3f9fb8c65fb6a15adabfe8aea9","modified":1710924531709},{"_id":"source/img/logo.png","hash":"fcc912750e423c3ac3b026513fe18924827eb5d7","modified":1710923840000},{"_id":"source/_posts/computer-networks/image-20240320231617299.png","hash":"8e38920f91c412541726369c6c03385f7ed97e69","modified":1710947777313},{"_id":"source/_posts/computer-networks/image-20240320231606870.png","hash":"4d9665ae13b2f8133b14fd12f667a5efb8f44095","modified":1710947766896},{"_id":"source/_posts/computer-networks/image-20240320231639197.png","hash":"ad785716b678479d150f1dffc49208bb44282296","modified":1710947799206},{"_id":"source/_posts/computer-networks/image-20240320231628966.png","hash":"4e506a74298aa58f7d6dba998f947321f3db692b","modified":1710947788976},{"_id":"source/_posts/computer-networks/image-20240320231707214.png","hash":"b64d62b95f6f75a8e40b58615b8b98ba408fb070","modified":1710947827240},{"_id":"source/_posts/computer-networks/image-20240320231718044.png","hash":"021102c5e0a3e51b54908dd49c494771c509e790","modified":1710947838046},{"_id":"source/_posts/computer-networks/image-20240320231741490.png","hash":"49375e44baa16accca973e8417cc3422e667a908","modified":1710947861502},{"_id":"source/_posts/computer-networks/image-20240320231728699.png","hash":"525453fa26ee32bff57a59a4e873d1cf92d1f70b","modified":1710947848729},{"_id":"source/_posts/computer-networks/image-20240320231946518.png","hash":"ddb62ecb9bbfb79a9c8ea80656368c99b2291688","modified":1710947986531},{"_id":"source/_posts/computer-networks/image-20240320232052656.png","hash":"973866dc0a2ec37d9da0571c6eb8916b2474f169","modified":1710948052675},{"_id":"source/_posts/computer-networks/image-20240320232244255.png","hash":"1941a5e7e0004e69134c5a8a7c2acf8f174c81e2","modified":1710948164262},{"_id":"source/_posts/computer-networks/image-20240320233356850.png","hash":"aa8873f578b93821b599ea5671d2679060f8c24e","modified":1710948836870},{"_id":"source/_posts/computer-networks/image-20240320235727170.png","hash":"75cfb2523341a9b7be5bcfc533acf31ed88414fd","modified":1710950247198},{"_id":"source/_posts/database-system-principles/image-20240319220740283.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710857260304},{"_id":"source/_posts/database-system-principles/image-20240319215933046.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710856773068},{"_id":"source/_posts/database-system-principles/image-20240319220943892.png","hash":"bc60779a7c294034e7de4e6be05037b95b659ef2","modified":1710857383912},{"_id":"source/_posts/database-system-principles/image-20240319221039549.png","hash":"cbf322064326a4abe99ace20077060f2a27aad4d","modified":1710857439571},{"_id":"source/_posts/database-system-principles/image-20240319221024695.png","hash":"69b6c0175dac118c71e167c90c33a4e4c4e47757","modified":1710857424710},{"_id":"source/_posts/database-system-principles/image-20240319221109092.png","hash":"bd4b34fb787786b5be792b6517a2c236f7705e0b","modified":1710857469113},{"_id":"source/_posts/database-system-principles/image-20240319221128098.png","hash":"28269ef73d73a53ece9fa0df1015be097b0fad25","modified":1710857488129},{"_id":"source/_posts/database-system-principles/image-20240319222609279.png","hash":"225bd2c408a4105dca17e4a59cf266b12d11fb02","modified":1710858369294},{"_id":"source/_posts/database-system-principles/image-20240319222621455.png","hash":"a7b9939d28d10aa06158df97048a5fc3bdd683f9","modified":1710858381475},{"_id":"source/_posts/database-system-principles/image-20240319222801904.png","hash":"634e1a8d7ae85ac963b833bf27488be2e832913a","modified":1710858481926},{"_id":"source/_posts/database-system-principles/image-20240319222832886.png","hash":"96be249738a4b864e738436b19edae3f1f21d8ea","modified":1710858512908},{"_id":"source/_posts/hw1/image-20240319110624835.png","hash":"13a2f8494ad5d94be5aeef1af4e64142d3c3edb3","modified":1711078043561},{"_id":"source/_posts/mysql/image-20240319231743225.png","hash":"9d372fbdb6b582c5446a56ab11de5d6044670974","modified":1710861463230},{"_id":"source/_posts/mysql/image-20240319231655495.png","hash":"1f4a4feb12d773b0e2ba01d66dc32191c220fffc","modified":1710861415501},{"_id":"source/_posts/operating-systems/image-20240320175436050.png","hash":"936a74801c44565c8c8ba961e8bf1ad550a00912","modified":1710928476068},{"_id":"source/_posts/operating-systems/image-20240320175446963.png","hash":"33ceb8fed90ef27ac05b8c2cfe3796614e96f13d","modified":1710928486972},{"_id":"source/_posts/operating-systems/image-20240320175508729.png","hash":"ffd34568e69f20afc1b7f28a10d49d9b45d28579","modified":1710928508736},{"_id":"source/_posts/operating-systems/image-20240320175525345.png","hash":"74e3fd6ad32ec4bd350f1266810c21d8f0f1c8c0","modified":1710928525364},{"_id":"source/_posts/operating-systems/image-20240320175609777.png","hash":"8e0085c774f91292ad6083d97c1c8b0f8c627d9b","modified":1710928569794},{"_id":"source/_posts/operating-systems/image-20240320175601947.png","hash":"34cd78ed8afff0010fd1f8c0a4452b8cd2df7ac9","modified":1710928561975},{"_id":"source/_posts/operating-systems/image-20240320175633047.png","hash":"0efb9d9083e2b40c384e623269869f5f650c0a91","modified":1710928593062},{"_id":"source/_posts/operating-systems/image-20240320175638377.png","hash":"add8183f002ac08c400354df11349d8316e64c7f","modified":1710928598392},{"_id":"source/_posts/operating-systems/image-20240320175649285.png","hash":"878cd4b22055ba56055694f190d3b5e05d46859d","modified":1710928609309},{"_id":"source/_posts/operating-systems/image-20240320175712336.png","hash":"fdcf0d1f66737143f3e096cd21cd49c303f10747","modified":1710928632349},{"_id":"source/_posts/operating-systems/image-20240320175725276.png","hash":"46b87a1cb280c5248027a661d2e06c4ac79f0990","modified":1710928645303},{"_id":"source/_posts/operating-systems/image-20240320180115680.png","hash":"57336aed945c0b8e1bf63f9a273cbe022e3d0ad6","modified":1710928875693},{"_id":"source/_posts/operating-systems/image-20240320180134569.png","hash":"afb3e757d2624779af95cd055c99e2f2e35f8d0b","modified":1710928894588},{"_id":"source/_posts/socket/image-20240320110531226.png","hash":"58f971ea6ab24f3e75b5d8a8c4d21b59c87cbf61","modified":1710903931261},{"_id":"source/_posts/computer-networks/image-20240318110448792.png","hash":"b1153eec1a51c96bb455bcbae9df456215959e4d","modified":1710947632279},{"_id":"source/_posts/computer-networks/image-20240318105358847.png","hash":"f86b5e040c3caee5a6f09e0736a8e4ce98bc33da","modified":1710947632279},{"_id":"source/_posts/computer-networks/image-20240318105418710.png","hash":"66c5804a92bd5d3f4a2cf43798175f857975ae68","modified":1710947632279},{"_id":"source/_posts/computer-networks/image-20240318105431532.png","hash":"83e56dd767884b55d20e0f9e428e91eb1794a314","modified":1710947632279},{"_id":"source/_posts/computer-networks/image-20240319094259385.png","hash":"4ca961c1e0d96eac41e9686ff24ded9d0d616a50","modified":1710947632278},{"_id":"source/_posts/computer-networks/image-20240319094315691.png","hash":"1d084022ea57f9574c56abae6025666048381f13","modified":1710947632278},{"_id":"source/_posts/computer-networks/image-20240320231555984.png","hash":"ce1c74d9ebfc590b835e9cbdd32ae5c328f2ddaf","modified":1710947756007},{"_id":"source/_posts/computer-networks/image-20240320232029117.png","hash":"73f34d22a79eb818929474db685283e71f996364","modified":1710948029150},{"_id":"source/_posts/computer-networks/image-20240320233535616.png","hash":"e9f919e4d4aa5d227961f6292679fe45aafd81d4","modified":1710948935635},{"_id":"source/_posts/computer-networks/image-20240320233614781.png","hash":"a3ad41574e5717cbbd512e186663ebbb3b4d1a65","modified":1710948974801},{"_id":"source/_posts/computer-networks/image-20240320233622336.png","hash":"3659b47acd7bda34fa29c2612c96fc065aa0b9e1","modified":1710948982361},{"_id":"source/_posts/computer-networks/image-20240320233735273.png","hash":"faf1ee65da933f1d49786a253072da8d3515a0a7","modified":1710949055287},{"_id":"source/_posts/computer-networks/image-20240320233838217.png","hash":"54f017113ae490c4c46bd4f3857fdc922c44b4c5","modified":1710949118238},{"_id":"source/_posts/computer-networks/image-20240320233951219.png","hash":"2c6ba67f95d8ba9fc34122e30601f5f52f9b1206","modified":1710949191239},{"_id":"source/_posts/computer-networks/image-20240320234748836.png","hash":"309a7bc65cd562f7627eb901efac10f3b49e6712","modified":1710949668856},{"_id":"source/_posts/computer-networks/image-20240320234811272.png","hash":"198aebae02a63bf7af8157f20962a52ae402d616","modified":1710949691295},{"_id":"source/_posts/computer-networks/image-20240320235442988.png","hash":"a7de886f4792cdf8096fca0c203b15e88c59fcff","modified":1710950083024},{"_id":"source/_posts/computer-networks/image-20240320234840219.png","hash":"004ada464c571f00bc21fcb21fb475943b0e7487","modified":1710949720237},{"_id":"source/_posts/database-system-principles/image-20240319222857283.png","hash":"d06e64e0562cf03313a31c9cb24cf3a5b5e37db8","modified":1710858537309},{"_id":"source/_posts/database-system-principles/image-20240319223152453.png","hash":"cb4ef05fc4b820636c20f0b08364f4c5f2aad45b","modified":1710858712480},{"_id":"source/_posts/golang/image-20240320181645811.png","hash":"8e9f0dc94c369d51d1e452dbe1e919da91a71a9d","modified":1710929805860},{"_id":"source/_posts/operating-systems/image-20240320175407843.png","hash":"7be2e1e0d847c2667f6679622a1482d49cebd45f","modified":1710928447868},{"_id":"source/_posts/operating-systems/image-20240320175421234.png","hash":"43a8a286eac96c7609bac5dfca6fc21879268072","modified":1710928461270},{"_id":"source/_posts/operating-systems/image-20240320175455259.png","hash":"b196bb644449f31cba630100dde53cb539d2cc6f","modified":1710928495294},{"_id":"source/_posts/operating-systems/image-20240320175548861.png","hash":"b53cb6eca750a6f0f61db6b3ce0db11c160918e2","modified":1710928548879},{"_id":"source/_posts/operating-systems/image-20240320180056054.png","hash":"dd50f23461f1d9c0f158cc52478f39d4ff024a81","modified":1710928856078},{"_id":"source/_posts/operating-systems/image-20240320175747301.png","hash":"a87995f29a5eff378cf379a96d3c7c9dea98521a","modified":1710928667313},{"_id":"source/_posts/operating-systems/image-20240320180104512.png","hash":"be26d8cbd67384ca444ffeaa81b4af61219ef519","modified":1710928864550},{"_id":"source/_posts/operating-systems/image-20240320180128128.png","hash":"ac729cb0d52318ee311cb4e669fb55c490630013","modified":1710928888164},{"_id":"source/_posts/socket/image-20240320110625558.png","hash":"45f7da1a37207c8255d61dc83e05277de2a1e7a7","modified":1710903985578},{"_id":"source/_posts/socket/image-20240320111122789.png","hash":"712cfd1050ba4fb0504209f09479f87752f6b04b","modified":1710904282827},{"_id":"source/_posts/socket/image-20240320120005597.png","hash":"bebd03b42c4c96e72496d4538eda9e6a4caa40e8","modified":1710907205617},{"_id":"source/_posts/socket/image-20240320120231930.png","hash":"599cb4eb3ad604fd449f6b2393f67a1cfff101db","modified":1710907351954},{"_id":"source/_posts/computer-networks/image-20240318123102054.png","hash":"0b9fcc633e6334b7f6027f9aa08a32b625b284e4","modified":1710947632282},{"_id":"source/_posts/computer-networks/image-20240318124318116.png","hash":"7af3935c270ead4bfd7f63d5c3b2d1e6ef013de9","modified":1710947632282},{"_id":"source/_posts/computer-networks/image-20240318124331487.png","hash":"4cd6a5a3b0bd83c56646c2b35173d385292aa510","modified":1710770284996},{"_id":"source/_posts/computer-networks/image-20240320231501917.png","hash":"041c553a8e609a04cd91011b8660e54bbf101cf3","modified":1710947701951},{"_id":"source/_posts/computer-networks/image-20240320233906140.png","hash":"6f1eed9ecf3b945c18e30467fd4d1117c3be1914","modified":1710949146170},{"_id":"source/_posts/computer-networks/image-20240320234247573.png","hash":"b44738da5242eb33b450269cd6c3c165dde1b0fd","modified":1710949367602},{"_id":"source/_posts/computer-networks/image-20240320235524028.png","hash":"df5e4cfb23c7fd8e09c50288a3f837e88d1b542c","modified":1710950124087},{"_id":"source/_posts/computer-networks/image-20240320235533138.png","hash":"32163510650dc6144b59fa83f75eadbb9abc08d5","modified":1710950133189},{"_id":"source/_posts/computer-networks/image-20240320235655694.png","hash":"4a636684be454a11894248e014af94af351e6fcd","modified":1710950215747},{"_id":"source/_posts/meituan-interview/image-20240321213051186.png","hash":"5023b600b2653e339e5061b57e49fa9764cdec79","modified":1711078571704},{"_id":"source/_posts/meituan-interview/image-20240321213127087.png","hash":"2f6bec0c82937d8f31fd3b7c61302c45b05c66b1","modified":1711078571706},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755585},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755588},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755592},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755593},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755595},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755559},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755573},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755568},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755582},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710909755576},{"_id":"source/_posts/computer-networks/image-20240320233517464.png","hash":"73c722dfa3e790fcbf6e6931c4ae8c5db2cd2945","modified":1710948917515},{"_id":"source/_posts/computer-networks/image-20240320233705195.png","hash":"7f83ddf1bf834870bec0f16b89627dad33b52d58","modified":1710949025226},{"_id":"source/_posts/computer-networks/image-20240320233404661.png","hash":"c43b9dcd7ab952418f805e52dc2261d75d035b24","modified":1710948844707},{"_id":"source/_posts/computer-networks/image-20240320233632927.png","hash":"deddf3c6fcf3fea762c95669319c26482494396b","modified":1710948992965},{"_id":"source/_posts/computer-networks/image-20240320233852959.png","hash":"e73cc47d213a34f7971874ca2b1343a8b0ae8f56","modified":1710949133004},{"_id":"source/_posts/computer-networks/image-20240320234048388.png","hash":"d3d7c09350e05029fabb8052b5c3f7109857b9a5","modified":1710949248428},{"_id":"source/_posts/computer-networks/image-20240320234214934.png","hash":"8bbbacd13097f1d63ee8dfa344e47dabd955548d","modified":1710949334977},{"_id":"source/_posts/computer-networks/image-20240320234310912.png","hash":"c2dd354e167064b4e4b9965692d984176edc2565","modified":1710949390956},{"_id":"source/_posts/computer-networks/image-20240320235718371.png","hash":"97e5c61e38a5b3fb31329e90e80b6eb90129947e","modified":1710950238404},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1710909755968},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"18b3b80cf6456697a675721d957362840c1ab949","modified":1710909755629},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1710909755597},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1710909755971},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"4b8a3096137e0d879fb17972a69630bde38d8212","modified":1710909755604},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1710909756262},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"e02471f80db87db43aa7d527176e195b60dc4b99","modified":1710909755606},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1710909756263},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1710909756265},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"b992b68705f5050a99de926525b3cb40d95c4769","modified":1710909756266},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"040fed1d0d7e4d8003446d1541bc15a2c4b4e500","modified":1710909755612},{"_id":"node_modules/hexo-theme-icarus/languages/it.yml","hash":"b76999994cda6b08b53d34c3dd67947f164de655","modified":1710909756267},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1710909756267},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1710909756268},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1710909756269},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1710909756270},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1710909756271},{"_id":"node_modules/hexo-theme-icarus/languages/sv.yml","hash":"b12eee168c52aac855ffce9f78fe5fd5d6e3970c","modified":1710909756273},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1710909756272},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1710909756274},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1710909756275},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1710909756276},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1710909756277},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1710909756278},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1710909755943},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"daf8eca64197709a9dc4a4792c403a32d78bdfae","modified":1710909755939},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1710909755952},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1710909755944},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1710909755953},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1710909755957},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1710909755955},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1710909755965},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1710909755964},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"f233678cd656c0e300181ca79dd30cb42fc213b3","modified":1710909755624},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"93a79969c7eb47cfac097893cda36368db56902c","modified":1710909755610},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1710909756241},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1710909756242},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1710909756243},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1710909756243},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1710909756248},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"ec54dc24eb4d9802d8fefc44c210558bc1641109","modified":1710909756245},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1710909756249},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1710909756250},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1710909756251},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1710909756251},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"084843d5a522029e0f84a4fe791fbcb2cabd4c36","modified":1710909756252},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1710909756254},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1710909756253},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1710909756256},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1710909756257},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1710909755605},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"7189efe33d18927d3790e8afb06642fb293b8603","modified":1710909755608},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1710909755615},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"a46da71c20fa9d73c1bac26fda77717abae1b308","modified":1710909755613},{"_id":"node_modules/hexo-theme-icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1710909755615},{"_id":"node_modules/hexo-theme-icarus/include/migration/v5_v5.1.js","hash":"073f22bd16e34b56f016633b1676dab2e7d8843d","modified":1710909755616},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"c4fc3c016de42c50614f70538a23359eee905ed3","modified":1710909755941},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"0610cadb3976954c6f299d30320a93a1bd2a151c","modified":1710909755946},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"de966666f1e4ef80e0d15081b2709c3065b246dd","modified":1710909755949},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"fd52330d582fd122db7f55444c2f3368ff4bd8d7","modified":1710909755947},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1710909755954},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"ff049c2837a111da775d1661b605dd417614b84c","modified":1710909755950},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"eaec7c7b936197247e5acd73a79ca951da4d82ec","modified":1710909755961},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"2e27800b2a8a87112c96778db858c3419d890b79","modified":1710909755956},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"1409627d98a92b4f5b2ab829f8e6b50b75d60e53","modified":1710909755962},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"0fad6f8a91bb5cf678b9ff2d66d2162d61625074","modified":1710909755963},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"7a89ac72a988d13b4714ab78a6dfd5cd8de85d47","modified":1710909755966},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1710909755943},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1710909755641},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1710909755959},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1710909756246},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1710909756247},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1710909755973},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1710909756255},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1710909756258},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1710909756259},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1710909756260},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1710909756239},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1710909756261},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1710909755600},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1710909755601},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1710909755602},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"37f3b16fbd9668b9496d5f2d9bd9fb22fc6cee27","modified":1710909755611},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1710909755620},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"f49270b619f5d2c3decde6b0b5a0c3bbab4b54a5","modified":1710909755623},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1710909755625},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"e85c9d7f2579805beb252a1b6345d5a668a13baa","modified":1710909755626},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1710909755628},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1710909755627},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1710909755631},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1710909755634},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1710909755635},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1710909755636},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1710909755638},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1710909755639},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1710909755618},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1710909755621},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1710909755633},{"_id":"source/img/favicon.ico","hash":"6b1086f72bad6aa8e5c86d97f203f3b4d584d46d","modified":1710924526329},{"_id":"source/_posts/computer-networks/image-20240320234736573.png","hash":"fb440234be8959539dba53c92880acb41a8d656d","modified":1710949656634},{"_id":"source/_posts/meituan-interview/image-20240321213357032.png","hash":"cdd7007de9fa472fcf35060aa77a5fcdf89c0f74","modified":1711078571710},{"_id":"source/_posts/meituan-interview/image-20240321212159961.png","hash":"58219b18a75171356e99952b91004eead82c8cd3","modified":1711078571693},{"_id":"source/_posts/meituan-interview/image-20240321212210047.png","hash":"0a3468e27d88a8c03a918a8dcf2b2ac07c46ddad","modified":1711078571700},{"_id":"source/_posts/computer-networks/image-20240320233824232.png","hash":"cbde6fe71670dd323b88baf0863a22037722dbec","modified":1710949104356},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1711078924827},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1711078924827},{"_id":"public/content.json","hash":"a6d92f7ddde67e6419ec71d41d3bfeda3822fca4","modified":1711078924827},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1711078924827},{"_id":"public/manifest.json","hash":"8dafbebe1edd21ec9799a37f5c25d2e50f16fe3c","modified":1711078924827},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1711078924827},{"_id":"public/2024/03/20/golang/index.html","hash":"fd7f080c9e85e941693ecc5532bac60fc9654e7f","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/index.html","hash":"29006f5ad167bc32ba5acdbca11da142f06655a8","modified":1711078924827},{"_id":"public/2024/03/21/meituan-interview/index.html","hash":"7d30a628b0a0dc5631a36bcac3e845a9a68c9134","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/index.html","hash":"754283d2c65597cfcaf3374d767426a25c9ae6e9","modified":1711078924827},{"_id":"public/2024/03/20/hello-world/index.html","hash":"696df0dbbd31bf490ebda9a783d2dc04d41b39f7","modified":1711078924827},{"_id":"public/2024/03/20/socket/index.html","hash":"62cd6780f0c705288a5e5fba2c2afcd5fa3d6e46","modified":1711078924827},{"_id":"public/2024/03/19/hw1/index.html","hash":"2c090c411b37a26f929b17bb0ebaa7eba6c0979b","modified":1711078924827},{"_id":"public/2024/03/19/mysql/index.html","hash":"01c7917b612c218c5f4b68190016ce2e2f77c3a9","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/index.html","hash":"c142f20e2c3036547bae7a4b1ab7db58bd41fc28","modified":1711078924827},{"_id":"public/categories/work/index.html","hash":"266f02d37c091ef793dc6e3e7a96ae70cfa945b9","modified":1711078924827},{"_id":"public/categories/study/index.html","hash":"a812686c9b2f12e940054a15ef6f8545433b0f27","modified":1711078924827},{"_id":"public/categories/work/review/index.html","hash":"c1a5c8abbedd7ad5d3e4c9d7abdf6a89a09e4dc9","modified":1711078924827},{"_id":"public/categories/study/cloud-computing-technology/index.html","hash":"13cb5ac9317d23d52cd8bf7ae6bca206078d75e0","modified":1711078924827},{"_id":"public/categories/work/review/computer-networks/index.html","hash":"d14bedb09e1dc3f907ff01a7b38644b40b62202e","modified":1711078924827},{"_id":"public/categories/work/review/programming-language/index.html","hash":"655c456aaef767976213c85e29ea529e4ec0fe18","modified":1711078924827},{"_id":"public/categories/work/review/database-systems/index.html","hash":"2dcbda47838d356b61273dcf58421082c4b14d7e","modified":1711078924827},{"_id":"public/index.html","hash":"69128c6f4bfa4a3d820992119f0fc035ec707488","modified":1711078924827},{"_id":"public/categories/work/interview/index.html","hash":"8010cb0cf5566af6125069055292918dc8db590d","modified":1711078924827},{"_id":"public/categories/work/review/operating-systems/index.html","hash":"bd72f36bbce403cf86913883835f97abb287c233","modified":1711078924827},{"_id":"public/tags/computer-networks/index.html","hash":"d76e62f82d68cd0d6f7f424638ad951dbb3f1a7f","modified":1711078924827},{"_id":"public/tags/database/index.html","hash":"95de63f1f9edd226bf73c2357878fa2ad123d92b","modified":1711078924827},{"_id":"public/tags/principles/index.html","hash":"d155301402171412bb29ae5a896d291098bfb21d","modified":1711078924827},{"_id":"public/tags/homework/index.html","hash":"28e9c53be8818cea069fc2ed39d2718377f14ca6","modified":1711078924827},{"_id":"public/tags/go/index.html","hash":"1a0f37d9ffe9f6dd2ee6308d10b06a92dbe92437","modified":1711078924827},{"_id":"public/tags/language/index.html","hash":"6701aaade27e810814b1468a600306b7e3c6eca8","modified":1711078924827},{"_id":"public/tags/work/index.html","hash":"ecb20fccc921131b1634f16db78ef0350fb9246b","modified":1711078924827},{"_id":"public/tags/interview/index.html","hash":"5a73be6d38bf0da8ed40df9f0dba03e4b0058ba7","modified":1711078924827},{"_id":"public/tags/backend/index.html","hash":"44f0addefdbaf8b34e674a139e343b8e84ef9e84","modified":1711078924827},{"_id":"public/tags/mysql/index.html","hash":"75eb4d27a85f849db4c819aaa84fb1fd3bcfc32c","modified":1711078924827},{"_id":"public/tags/operating-systems/index.html","hash":"44fa3e4ecedc1750c06da3c9ff6c81a667c4c8e0","modified":1711078924827},{"_id":"public/tags/socket/index.html","hash":"22f701517f09b9711fc9288a014178a9aebe4847","modified":1711078924827},{"_id":"public/archives/index.html","hash":"221bcf8b2038d44d2835c0e7fd087c20c6e7356d","modified":1711078924827},{"_id":"public/archives/2024/index.html","hash":"0c379d17f184ee0a9dca431d5fecccee4acb4d82","modified":1711078924827},{"_id":"public/archives/2024/03/index.html","hash":"695a47882217d99f8a6e1a1900748e00b8a4df41","modified":1711078924827},{"_id":"public/categories/index.html","hash":"3d20d6d90fe2af5fec475e552e94391a8d6af8d6","modified":1711078924827},{"_id":"public/tags/index.html","hash":"93dec86b1ddf0f0d61a60199be26617db6ae6d46","modified":1711078924827},{"_id":"public/img/favicon.svg","hash":"0336619be9767d3f9fb8c65fb6a15adabfe8aea9","modified":1711078924827},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1711078924827},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1711078924827},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1711078924827},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1711078924827},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1711078924827},{"_id":"public/img/avatar.jpg","hash":"3307e2fcb0c14e66257dfa918d4a6a77b32a49cd","modified":1711078924827},{"_id":"public/img/logo.png","hash":"fcc912750e423c3ac3b026513fe18924827eb5d7","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231617299.png","hash":"8e38920f91c412541726369c6c03385f7ed97e69","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231639197.png","hash":"ad785716b678479d150f1dffc49208bb44282296","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231606870.png","hash":"4d9665ae13b2f8133b14fd12f667a5efb8f44095","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231628966.png","hash":"4e506a74298aa58f7d6dba998f947321f3db692b","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231707214.png","hash":"b64d62b95f6f75a8e40b58615b8b98ba408fb070","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231718044.png","hash":"021102c5e0a3e51b54908dd49c494771c509e790","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231728699.png","hash":"525453fa26ee32bff57a59a4e873d1cf92d1f70b","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231741490.png","hash":"49375e44baa16accca973e8417cc3422e667a908","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231946518.png","hash":"ddb62ecb9bbfb79a9c8ea80656368c99b2291688","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320232052656.png","hash":"973866dc0a2ec37d9da0571c6eb8916b2474f169","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320232244255.png","hash":"1941a5e7e0004e69134c5a8a7c2acf8f174c81e2","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233356850.png","hash":"aa8873f578b93821b599ea5671d2679060f8c24e","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320235727170.png","hash":"75cfb2523341a9b7be5bcfc533acf31ed88414fd","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319215933046.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319221024695.png","hash":"69b6c0175dac118c71e167c90c33a4e4c4e47757","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319221039549.png","hash":"cbf322064326a4abe99ace20077060f2a27aad4d","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319220943892.png","hash":"bc60779a7c294034e7de4e6be05037b95b659ef2","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319220740283.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319221109092.png","hash":"bd4b34fb787786b5be792b6517a2c236f7705e0b","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319221128098.png","hash":"28269ef73d73a53ece9fa0df1015be097b0fad25","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319222609279.png","hash":"225bd2c408a4105dca17e4a59cf266b12d11fb02","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319222621455.png","hash":"a7b9939d28d10aa06158df97048a5fc3bdd683f9","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319222801904.png","hash":"634e1a8d7ae85ac963b833bf27488be2e832913a","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319222832886.png","hash":"96be249738a4b864e738436b19edae3f1f21d8ea","modified":1711078924827},{"_id":"public/2024/03/19/hw1/image-20240319110624835.png","hash":"13a2f8494ad5d94be5aeef1af4e64142d3c3edb3","modified":1711078924827},{"_id":"public/2024/03/19/mysql/image-20240319231655495.png","hash":"1f4a4feb12d773b0e2ba01d66dc32191c220fffc","modified":1711078924827},{"_id":"public/2024/03/19/mysql/image-20240319231743225.png","hash":"9d372fbdb6b582c5446a56ab11de5d6044670974","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175436050.png","hash":"936a74801c44565c8c8ba961e8bf1ad550a00912","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175446963.png","hash":"33ceb8fed90ef27ac05b8c2cfe3796614e96f13d","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175508729.png","hash":"ffd34568e69f20afc1b7f28a10d49d9b45d28579","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175525345.png","hash":"74e3fd6ad32ec4bd350f1266810c21d8f0f1c8c0","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175601947.png","hash":"34cd78ed8afff0010fd1f8c0a4452b8cd2df7ac9","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175609777.png","hash":"8e0085c774f91292ad6083d97c1c8b0f8c627d9b","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175633047.png","hash":"0efb9d9083e2b40c384e623269869f5f650c0a91","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175638377.png","hash":"add8183f002ac08c400354df11349d8316e64c7f","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175649285.png","hash":"878cd4b22055ba56055694f190d3b5e05d46859d","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175712336.png","hash":"fdcf0d1f66737143f3e096cd21cd49c303f10747","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175725276.png","hash":"46b87a1cb280c5248027a661d2e06c4ac79f0990","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320180115680.png","hash":"57336aed945c0b8e1bf63f9a273cbe022e3d0ad6","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320180134569.png","hash":"afb3e757d2624779af95cd055c99e2f2e35f8d0b","modified":1711078924827},{"_id":"public/2024/03/20/socket/image-20240320110531226.png","hash":"58f971ea6ab24f3e75b5d8a8c4d21b59c87cbf61","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240318105358847.png","hash":"f86b5e040c3caee5a6f09e0736a8e4ce98bc33da","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240318105418710.png","hash":"66c5804a92bd5d3f4a2cf43798175f857975ae68","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240318105431532.png","hash":"83e56dd767884b55d20e0f9e428e91eb1794a314","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240318110448792.png","hash":"b1153eec1a51c96bb455bcbae9df456215959e4d","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240319094259385.png","hash":"4ca961c1e0d96eac41e9686ff24ded9d0d616a50","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240319094315691.png","hash":"1d084022ea57f9574c56abae6025666048381f13","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231555984.png","hash":"ce1c74d9ebfc590b835e9cbdd32ae5c328f2ddaf","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320232029117.png","hash":"73f34d22a79eb818929474db685283e71f996364","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233535616.png","hash":"e9f919e4d4aa5d227961f6292679fe45aafd81d4","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233614781.png","hash":"a3ad41574e5717cbbd512e186663ebbb3b4d1a65","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233622336.png","hash":"3659b47acd7bda34fa29c2612c96fc065aa0b9e1","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233735273.png","hash":"faf1ee65da933f1d49786a253072da8d3515a0a7","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233838217.png","hash":"54f017113ae490c4c46bd4f3857fdc922c44b4c5","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233951219.png","hash":"2c6ba67f95d8ba9fc34122e30601f5f52f9b1206","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234748836.png","hash":"309a7bc65cd562f7627eb901efac10f3b49e6712","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234811272.png","hash":"198aebae02a63bf7af8157f20962a52ae402d616","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320235442988.png","hash":"a7de886f4792cdf8096fca0c203b15e88c59fcff","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234840219.png","hash":"004ada464c571f00bc21fcb21fb475943b0e7487","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319222857283.png","hash":"d06e64e0562cf03313a31c9cb24cf3a5b5e37db8","modified":1711078924827},{"_id":"public/2024/03/19/database-system-principles/image-20240319223152453.png","hash":"cb4ef05fc4b820636c20f0b08364f4c5f2aad45b","modified":1711078924827},{"_id":"public/2024/03/20/golang/image-20240320181645811.png","hash":"8e9f0dc94c369d51d1e452dbe1e919da91a71a9d","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175407843.png","hash":"7be2e1e0d847c2667f6679622a1482d49cebd45f","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175421234.png","hash":"43a8a286eac96c7609bac5dfca6fc21879268072","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175455259.png","hash":"b196bb644449f31cba630100dde53cb539d2cc6f","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175548861.png","hash":"b53cb6eca750a6f0f61db6b3ce0db11c160918e2","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320175747301.png","hash":"a87995f29a5eff378cf379a96d3c7c9dea98521a","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320180056054.png","hash":"dd50f23461f1d9c0f158cc52478f39d4ff024a81","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320180104512.png","hash":"be26d8cbd67384ca444ffeaa81b4af61219ef519","modified":1711078924827},{"_id":"public/2024/03/20/operating-systems/image-20240320180128128.png","hash":"ac729cb0d52318ee311cb4e669fb55c490630013","modified":1711078924827},{"_id":"public/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1711078924827},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1711078924827},{"_id":"public/js/main.js","hash":"37f3b16fbd9668b9496d5f2d9bd9fb22fc6cee27","modified":1711078924827},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1711078924827},{"_id":"public/css/cyberpunk.css","hash":"b462177bee11f76e84e649f8192d5a68cb4b1402","modified":1711078924827},{"_id":"public/css/default.css","hash":"8717dd0ed1fe2a4237fbfb4f4f6e566cb1ee16b7","modified":1711078924827},{"_id":"public/css/style.css","hash":"8717dd0ed1fe2a4237fbfb4f4f6e566cb1ee16b7","modified":1711078924827},{"_id":"public/2024/03/20/socket/image-20240320110625558.png","hash":"45f7da1a37207c8255d61dc83e05277de2a1e7a7","modified":1711078924827},{"_id":"public/2024/03/20/socket/image-20240320111122789.png","hash":"712cfd1050ba4fb0504209f09479f87752f6b04b","modified":1711078924827},{"_id":"public/2024/03/20/socket/image-20240320120005597.png","hash":"bebd03b42c4c96e72496d4538eda9e6a4caa40e8","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240318123102054.png","hash":"0b9fcc633e6334b7f6027f9aa08a32b625b284e4","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240318124318116.png","hash":"7af3935c270ead4bfd7f63d5c3b2d1e6ef013de9","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240318124331487.png","hash":"4cd6a5a3b0bd83c56646c2b35173d385292aa510","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320231501917.png","hash":"041c553a8e609a04cd91011b8660e54bbf101cf3","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233906140.png","hash":"6f1eed9ecf3b945c18e30467fd4d1117c3be1914","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234247573.png","hash":"b44738da5242eb33b450269cd6c3c165dde1b0fd","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320235524028.png","hash":"df5e4cfb23c7fd8e09c50288a3f837e88d1b542c","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320235533138.png","hash":"32163510650dc6144b59fa83f75eadbb9abc08d5","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320235655694.png","hash":"4a636684be454a11894248e014af94af351e6fcd","modified":1711078924827},{"_id":"public/2024/03/21/meituan-interview/image-20240321213051186.png","hash":"5023b600b2653e339e5061b57e49fa9764cdec79","modified":1711078924827},{"_id":"public/2024/03/21/meituan-interview/image-20240321213127087.png","hash":"2f6bec0c82937d8f31fd3b7c61302c45b05c66b1","modified":1711078924827},{"_id":"public/2024/03/20/socket/image-20240320120231930.png","hash":"599cb4eb3ad604fd449f6b2393f67a1cfff101db","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233404661.png","hash":"c43b9dcd7ab952418f805e52dc2261d75d035b24","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233517464.png","hash":"73c722dfa3e790fcbf6e6931c4ae8c5db2cd2945","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233632927.png","hash":"deddf3c6fcf3fea762c95669319c26482494396b","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233705195.png","hash":"7f83ddf1bf834870bec0f16b89627dad33b52d58","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233852959.png","hash":"e73cc47d213a34f7971874ca2b1343a8b0ae8f56","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234048388.png","hash":"d3d7c09350e05029fabb8052b5c3f7109857b9a5","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234214934.png","hash":"8bbbacd13097f1d63ee8dfa344e47dabd955548d","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234310912.png","hash":"c2dd354e167064b4e4b9965692d984176edc2565","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320235718371.png","hash":"97e5c61e38a5b3fb31329e90e80b6eb90129947e","modified":1711078924827},{"_id":"public/img/favicon.ico","hash":"6b1086f72bad6aa8e5c86d97f203f3b4d584d46d","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320234736573.png","hash":"fb440234be8959539dba53c92880acb41a8d656d","modified":1711078924827},{"_id":"public/2024/03/21/meituan-interview/image-20240321213357032.png","hash":"cdd7007de9fa472fcf35060aa77a5fcdf89c0f74","modified":1711078924827},{"_id":"public/2024/03/21/meituan-interview/image-20240321212159961.png","hash":"58219b18a75171356e99952b91004eead82c8cd3","modified":1711078924827},{"_id":"public/2024/03/21/meituan-interview/image-20240321212210047.png","hash":"0a3468e27d88a8c03a918a8dcf2b2ac07c46ddad","modified":1711078924827},{"_id":"public/2024/03/20/computer-networks/image-20240320233824232.png","hash":"cbde6fe71670dd323b88baf0863a22037722dbec","modified":1711078924827}],"Category":[{"name":"work","_id":"clu247puj0002jocg7rbb5paz"},{"name":"study","_id":"clu247pvs000ajocg04n1bqen"},{"name":"review","parent":"clu247puj0002jocg7rbb5paz","_id":"clu247pvt000cjocg8dsi788h"},{"name":"cloud computing technology","parent":"clu247pvs000ajocg04n1bqen","_id":"clu247pvw000ljocgdv795msq"},{"name":"computer networks","parent":"clu247pvt000cjocg8dsi788h","_id":"clu247pvx000njocg1fkib00l"},{"name":"programming language","parent":"clu247pvt000cjocg8dsi788h","_id":"clu247pvx000qjocg4jqvblnu"},{"name":"database systems","parent":"clu247pvt000cjocg8dsi788h","_id":"clu247pvy000tjocg0eh14q53"},{"name":"interview","parent":"clu247puj0002jocg7rbb5paz","_id":"clu247pw60016jocg3qy59wh1"},{"name":"operating systems","parent":"clu247pvt000cjocg8dsi788h","_id":"clu247pw80019jocgdhth6jlh"}],"Data":[],"Page":[],"Post":[{"title":"计算机网络","date":"2024-03-20T15:11:44.000Z","toc":true,"_content":"\n转载自：https://github.com/CyC2018/CS-Notes/tree/master\n\n## 概述\n\n### 网络的网络\n\n网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。\n\n<!--more-->\n\n![image-20240320231555984](computer-networks/image-20240320231555984.png)\n\n### ISP (Internet Service Provider)\n\n互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。\n\n![image-20240320231606870](computer-networks/image-20240320231606870.png)\n\n目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。\n\n![image-20240320231617299](computer-networks/image-20240320231617299.png)\n\n### 主机间的通信方式\n\n- 客户-服务端（C/S）：客户是服务的请求方，服务器是服务的提供方。\n\n![image-20240320231628966](computer-networks/image-20240320231628966.png)\n\n- 对等（P2P）：不区分客户和服务器。\n\n![image-20240320231639197](computer-networks/image-20240320231639197.png)\n\n### 电路交换与分组交换\n\n#### 1. 电路交换\n\n用于电话通信系统，两个用户通信之前需要建立一条专用的物理链路，并且整个通信过程占用该链路。线路利用率低，往往不到 10%。\n\n#### 2. 分组交换\n\n每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，也就是说分组交换不需要占用传输线路。\n\n在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。\n\n### 时延\n\n总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延\n\n![image-20240320231707214](computer-networks/image-20240320231707214.png)\n\n#### 1. 排队时延\n\n分组在路由器的输入队列和输出**队列中排队等待**的时间，取决于当前网络通信量。\n\n#### 2. 处理时延\n\n主机或路由器收到分组后，进行处理需要的时间。例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。\n\n#### 3. 传输时延\n\n主机或路由器传输数据帧所需要的时间。\n\n![image-20240320231718044](computer-networks/image-20240320231718044.png)\n\n其中 l 表示数据帧的长度，v 表示传输速率。\n\n#### 4. 传播时延\n\n电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。\n\n![image-20240320231728699](computer-networks/image-20240320231728699.png)\n\n其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。\n\n### 计算机网络体系结构\n\n![image-20240320231741490](computer-networks/image-20240320231741490.png)\n\n#### 1. 五层协议\n\n- 应用层：为特定的应用程序提供数据传输服务，如：HTTP、DNS、FTP、SMTP、POP3（已被 IMAP 取代）、DHCP、TELNET（已被 SSH 取代）等协议。数据单位：报文（Message）。\n- 传输层：为进程提供数据传输服务。定义通用的传输层协议可以支持不断增多的应用层协议。包括两种协议：\n  - 传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位：报文段（Segment）。\n  - 用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位：数据报（Datagram）。\n- 网络层：为主机提供数据传输服务，网络层把传输层传递下来的报文段或数据报封装成分组。数据单位：分组（Packet）。如：IPv4、IPv6、ARP、ICMP。\n- 数据链路层：主机之间有很多链路，链路层为同一链路的主机提供数据传输服务。把网络层传下来的分组封装成帧（Frame）。如以太网（Ethernet），Wi-Fi，和蓝牙。\n- 物理层：传输 bit 流，尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到。\n\n#### 2. OSI（Open Systems Interconnection）\n\n- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。\n- 会话层：建立及管理会话。\n\n五层协议将这些功能留给应用开发者处理。\n\n#### 3. TCP/IP\n\n相当于五层协议中数据链路层和物理层合并为网络接口层。\n\nTCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。\n\n![image-20240320231946518](computer-networks/image-20240320231946518.png)\n\n#### 4. 数据在各层之间的传递过程\n\n在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。\n\n路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。\n\n## 物理层\n\n### 通信方式\n\n三种传输方式：\n\n- 单工通信：单向传输\n- 半双工通信：双向交替传输\n- 全双工通信：双向同时传输\n\n### 带通调制\n\n模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号，以便在物理介质上发送的信号。\n\n![image-20240320232029117](computer-networks/image-20240320232029117.png)\n\n## 链路层（不完整）\n\n### 基本问题\n\n#### 1. 封装成帧\n\n将网络层传下来的分组（IP）添加首部和尾部，用于标记帧的开始和结束。\n\n![image-20240320232052656](computer-networks/image-20240320232052656.png)\n\n#### 2. 透明传输\n\n透明表示一个实际存在的事物看起来好像不存在一样。\n\n帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n\n下图中：\n\n1. **SOH（Start of Header）**：在 ASCII 中，SOH 的十进制值为 1。它通常用于标记一段信息的开始，尤其是头部信息的开始。\n2. **ESC（Escape）**：在 ASCII 中，ESC 的十进制值为 27。它通常用于引入一个转义序列，这是一种改变后续字符含义的机制。例如，在许多编程语言和命令行界面中，ESC 字符可以用来引入一个颜色、格式或特殊字符的编码。\n3. **EOT（End of Transmission）**：在 ASCII 中，EOT 的十进制值为 4。它通常用于标记一段信息的结束，尤其是在通信中标记传输的结束。\n\n![image-20240320232244255](computer-networks/image-20240320232244255.png)\n\n#### 3. 差错检测\n\n目前广泛使用了循环冗余检验（CRC）来检查比特差错。\n\n## 网络层\n\n### 概述\n\n整个互联网的核心，因此尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。\n\n使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。\n\n![image-20240320233356850](computer-networks/image-20240320233356850.png)\n\n与 IP 协议配套使用的还有三个协议：\n\n- 地址解析协议 ARP（Address Resolution Protocol），知道网关路由器 IP 地址，用该协议广播获得网关路由器的 MAC 地址。\n- 网际控制报文协议 ICMP（Internet Control Message Protocol）\n- 网际组管理协议 IGMP（Internet Group Management Protocol）\n\n### IP 数据报格式\n\n![image-20240320233404661](computer-networks/image-20240320233404661.png)\n\n- **版本** : 有 4（IPv4）和 6（IPv6）两个值；\n- **首部长度** : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。\n- **区分服务** : 用来获得更好的服务，一般情况下不使用。\n- **总长度** : 包括首部长度和数据部分长度。\n- **标识** : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。\n- **标志**（Flags）：这是一个 3 位的字段，其中最重要的两位是 DF（Don't Fragment）和 MF（More Fragments）。\n  - DF 位用于控制数据报是否可以被分片。如果 DF 位被设置（值为 1），那么数据报就不能被分片。如果数据报太大，无法通过下一跳网络，那么它将被丢弃，并且发送 ICMP 错误消息给发送者。如果 DF 位没有被设置（值为 0），那么数据报可以被分片。\n  - MF 位用于表示是否还有更多的片段。如果一个数据报被分片，那么除了最后一个片段之外，所有的片段都会设置 MF 位（值为 1）。最后一个片段的 MF 位不会被设置（值为 0）。这样，接收端就可以知道所有的片段是否都已经接收到了。\n  - 在 IPv6 中，由于不再支持在传输过程中的分片，所以没有这两个字段。IPv6 只在源端支持分片，并且使用了一个完全不同的机制和头部扩展来处理分片。\n- **片偏移** : 和标识符一起，用于发生分片的情况。片偏移的单位为**8 字节**。\n- **生存时间** ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。\n- **协议** ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。\n- **首部检验和** ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。\n\n![image-20240320233517464](computer-networks/image-20240320233517464.png)\n\n### IP 地址编址方式\n\nIP 地址的编址方式经历了三个历史阶段：\n\n- 分类\n- 子网划分\n- 无分类\n\n#### 1. 分类\n\n由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。\n\nIP 地址 ::= {< 网络号 >, < 主机号 >}\n\n![image-20240320233535616](computer-networks/image-20240320233535616.png)\n\n#### 2. 子网划分\n\n通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。\n\nIP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}\n\n要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。\n\n注意，外部网络看不到子网的存在。\n\n一些约定：\n\n- 子网部分：全为 0——本网络。\n- 主机部分：全为 0——本主机。\n- 主机部分：全为 1—— 广播地址，这个网络的所有主机。\n\n#### 3. 无分类\n\n无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。\n\nIP 地址 ::= {< 网络前缀号 >, < 主机号 >}\n\nCIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。\n\nCIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。\n\n一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。\n\n在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。\n\n### 地址解析协议 ARP\n\n网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。\n\n![image-20240320233614781](computer-networks/image-20240320233614781.png)\n\nARP 实现由 IP 地址得到 MAC 地址。\n\n![image-20240320233622336](computer-networks/image-20240320233622336.png)\n\n每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。\n\n如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。\n\n![image-20240320233632927](computer-networks/image-20240320233632927.png)\n\n### 网际控制报文协议 ICMP\n\n位于网络层，但是封装在 IP 数据报中。ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。\n\n![image-20240320233705195](computer-networks/image-20240320233705195.png)\n\nICMP 报文分为差错报告报文和询问报文。\n\n![image-20240320233735273](computer-networks/image-20240320233735273.png)\n\n#### 1. Ping\n\nPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。\n\nPing 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。\n\n#### 2. Traceroute\n\nTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。\n\nTraceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文（type = 3）。\n\n- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文（type = 11）；\n- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。\n- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文（type = 3）。\n- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。\n\n### 虚拟专用网 VPN\n\n由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。\n\n有三个专用地址块：\n\n- 10.0.0.0 ~ 10.255.255.255\n- 172.16.0.0 ~ 172.31.255.255\n- 192.168.0.0 ~ 192.168.255.255\n\nVPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。\n\n下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。\n\n![image-20240320233824232](computer-networks/image-20240320233824232.png)\n\n### 网络地址转换 NAT\n\n专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。\n\n在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。\n\n![image-20240320233838217](computer-networks/image-20240320233838217.png)\n\n![image-20240319094259385](computer-networks/image-20240319094259385.png)\n\n![image-20240319094315691](computer-networks/image-20240319094315691.png)\n\n### 路由器的结构\n\n路由器从功能上可以划分为：路由选择和分组转发。\n\n分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。\n\n![image-20240320233852959](computer-networks/image-20240320233852959.png)\n\n### 路由器分组转发流程\n\n- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。\n- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；\n- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；\n- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；\n- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；\n- 报告转发分组出错。\n\n![image-20240320233906140](computer-networks/image-20240320233906140.png)\n\n### 路由选择协议\n\n路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。\n\n互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。\n\n可以把路由选择协议划分为两大类：\n\n- 自治系统内部的路由选择：RIP 和 OSPF\n- 自治系统间的路由选择：BGP\n\n#### 1. 内部网关协议 RIP（已经被 OSPF 取代）\n\nRIP 是一种基于距离向量（基于 Bellman-Ford 算法）的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。\n\nRIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。\n\n距离向量算法：\n\n- 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；\n- 对修改后的 RIP 报文中的每一个项目，进行以下步骤：\n- 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；\n- 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。\n- 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。\n\nRIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。\n\n#### 2. 内部网关协议 OSPF\n\n开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。\n\n开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。\n\nOSPF 具有以下特点：\n\n- 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。\n- 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。\n- 只有当链路状态发生变化时，路由器才会发送信息。\n\n所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。\n\n#### 3. 外部网关协议 BGP\n\n基于距离矢量算法。\n\nBGP（Border Gateway Protocol，边界网关协议）\n\nAS 之间的路由选择很困难，主要是由于：\n\n- 互联网规模很大；\n- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；\n- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。\n\nBGP 只能寻找一条比较好的路由，而不是最佳路由。\n\n每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。\n\n![image-20240320233951219](computer-networks/image-20240320233951219.png)\n\n## 传输层\n\n网络层只把分组发送到目的主机，但是真正通信的是主机中的进程。传输层提供了进程间的逻辑通信，向高层用户屏蔽了网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。\n\n### UDP 和 TCP 的特点\n\n- 用户数据报协议 UDP（User Datagram Protocol）无连接，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。\n- 传输控制协议 TCP（Transmission Control Protocol）面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。\n\n### UDP 首部格式\n\n![image-20240320234048388](computer-networks/image-20240320234048388.png)\n\n首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的，并不会真正地发送出去。\n\n### TCP 首部格式\n\n![image-20240320234214934](computer-networks/image-20240320234214934.png)\n\n- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。\n- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。\n- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。\n- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。\n- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。\n- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。\n- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。\n\n### TCP 的三次握手\n\n![image-20240320234247573](computer-networks/image-20240320234247573.png)\n\n上图中，大写的 SYN、ACK 为 bit 位，seq 为序列号，ack 为确认号。\n\n假设 A 为客户端，B 为服务器端。\n\n- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。\n- A 向 B 发送连接请求报文，SYN=1，ACK=0（表示这是一个连接请求报文段。），选择一个初始的序号 x。\n- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1（也是希望收到的下一个报文段的序列号），同时也选择一个初始的序号 y。\n- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。\n- B 收到 A 的确认后，连接建立。\n\n**三次握手的原因**\n\n第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。\n\n客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。\n\n### TCP 的四次挥手\n\n![image-20240320234310912](computer-networks/image-20240320234310912.png)\n\n以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。\n\n- A 发送连接释放报文，FIN=1。\n- B 收到之后发出确认（此时 FIN=0），此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。\n- 当 B 不再需要连接时，发送连接释放报文，FIN=1。\n- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。\n- B 收到 A 的确认后释放连接。\n\n**四次挥手的原因**\n\n客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让**服务器端发送还未传送完毕的数据**，传送完毕之后，服务器会发送 FIN 连接释放报文。\n\n**TIME_WAIT**\n\n客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：\n\n- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。\n- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。\n\n### TCP 可靠传输\n\nTCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。\n\n一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：\n\n$$\nRTT_s=(1-\\alpha)\\cdot(RTT_s)+\\alpha\\cdot RTT\n$$\n\n其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。\n\n超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：\n\n$$\nRTO=RTT_s+4\\cdot RTT_d\n$$\n\n其中 RTTd 为偏差的加权平均值。\n\n$$\nRTT_d=(1-\\beta)\\cdot RTT_d+\\beta\\cdot |RTT_s-RTT|\n$$\n\nRTTs 和 RTTd 的计算应该同时进行，因此，两个算式中右边的 RTTs 都是旧的 RTTs。\n\n### TCP 滑动窗口\n\n窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。\n\n发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。\n\n接收窗口只会对窗口内最后一个**按序到达**的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。\n\n![image-20240320234736573](computer-networks/image-20240320234736573.png)\n\n### TCP 流量控制\n\n为了控制发送方发送速率，保证接收方来得及接收。\n\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方发送速率。如果设置为 0，则发送方不能发送数据。\n\n### TCP 拥塞控制\n\n如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。\n\n流量控制是为了让接收方来得及接收，拥塞控制是为了降低整个网络的拥塞程度。\n\n![image-20240320234748836](computer-networks/image-20240320234748836.png)\n\n四个算法：\n\n- 慢开始\n- 拥塞避免\n- 快重传\n- 快恢复\n\n发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。\n\n为了便于讨论，做如下假设：\n\n- 接收方有足够大的接收缓存，因此不会发生流量控制；\n- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。\n\n![image-20240320234811272](computer-networks/image-20240320234811272.png)\n\n#### 1. 慢开始与拥塞避免\n\n发送的最初执行慢开始（指数增长），令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...\n\n注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n\n如果出现了超时，则令 ssthresh = cwnd / 2，cwnd = 1，然后重新执行慢开始。\n\n#### 2. 快重传与快恢复\n\n注意：快重传后紧跟快恢复\n\n在接收方，要求每次接收到报文段都应该对最后一个**已收到的有序报文段**进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。\n\n在发送方，如果收到三个重复确认（也就是收到了四个一样的确认），那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。\n\n在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh（不同的 TCP 分支有不同的处理方式），注意到此时直接进入拥塞避免。\n\n慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n\n![image-20240320234840219](computer-networks/image-20240320234840219.png)\n\n## 应用层\n\n### 域名系统\n\nDNS 是一个分布式数据库（每个站点只保留自己的部分数据），提供了主机名和 IP 地址之间相互转换的服务。\n\n域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。\n\n![image-20240320235442988](computer-networks/image-20240320235442988.png)\n\nDNS 可以用 UDP 或 TCP 传输，使用端口号都为 53。大多数情况，DNS 使用 UDP 传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传以保证可靠性。两种情况下会使用 TCP 传输：\n\n- 返回的响应超过 UDP 能携带的最大数据。\n- 区域传送（是主域名服务器向辅助域名服务器传送变化的那部分数据）。\n\n### 文件传送协议\n\nFTP 使用 TCP 进行连接，需要两个连接来传送一个文件：\n\n- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。\n- 数据连接：传送一个文件数据。\n\n根据数据连接是否是服务器端主动建立，FTP 有主动和被动（主语为服务器）两种模式：\n\n- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。\n\n![image-20240320235524028](computer-networks/image-20240320235524028.png)\n\n- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。\n\n![image-20240320235533138](computer-networks/image-20240320235533138.png)\n\n主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。\n\n### 动态主机配置协议\n\nDHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。\n\nDHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。\n\nDHCP 工作过程如下（跟找工作差不多……）：\n\n1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。\n2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。\n3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。\n4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。\n\n![image-20240320235655694](computer-networks/image-20240320235655694.png)\n\n### 远程登录协议\n\nTELNET（已经被 SSH 协议取代） 用于登录到远程主机上，并且远程主机上的输出也会返回。\n\nTELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。\n\n### 电子邮件协议\n\n电子邮件系统组成部分：\n\n- 用户代理\n- 邮件服务器\n- 邮件协议\n  - 发送协议（常用 SMTP）\n  - 读取协议（常用 POP3 和 IMAP）\n\n![image-20240320235718371](computer-networks/image-20240320235718371.png)\n\n#### 1. SMTP\n\nSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。\n\n![image-20240320235727170](computer-networks/image-20240320235727170.png)\n\n#### 2. POP3\n\n特点是只要用户从服务器上读取了邮件，就删除该邮件。已经被 IMAP 取代。\n\n#### 3. IMAP\n\n客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。\n\n### 常用端口\n\n| 应用             | 应用层协议 | 端口号  | 传输层协议 | 备注                        |\n| ---------------- | ---------- | ------- | ---------- | --------------------------- |\n| 域名解析         | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |\n| 动态主机配置协议 | DHCP       | 67/68   | UDP        |                             |\n| 简单网络管理协议 | SNMP       | 161/162 | UDP        |                             |\n| 文件传送协议     | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |\n| 远程终端协议     | TELNET     | 23      | TCP        |                             |\n| 超文本传送协议   | HTTP       | 80      | TCP        |                             |\n| 简单邮件传送协议 | SMTP       | 25      | TCP        |                             |\n| 邮件读取协议     | POP3       | 110     | TCP        |                             |\n| 网际报文存取协议 | IMAP       | 143     | TCP        |                             |\n\n### Web 页面请求过程\n\n![image-20240318105358847](computer-networks/image-20240318105358847.png)\n\n#### 1. DHCP 配置主机信息\n\n- 假设主机最开始没有 IP 地址及其它信息，需要先试用 DHCP 获取。\n- 主机生成 DHCP 请求报文，放入 UDP 数据报中，目的端口 67，源端口 68。\n- 放入 IP 数据报中，广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）。\n- 放入 MAC 帧中，具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。\n- 连接在交换机的 DHCP 服务器收到广播帧后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。\n- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。\n- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。\n\n![image-20240318105418710](computer-networks/image-20240318105418710.png)\n\n![image-20240318105431532](computer-networks/image-20240318105431532.png)\n\n#### 2. ARP（网络层）解析 MAC 地址\n\n- 主机为了生成套接字，需要知道网站的域名对应的 IP 地址。\n- 主机生成一个 DNS 查询报文，封装在 UDP 中。\n- 放入 IP 数据报中，目的地址 DNS 服务器 IP 地址。\n- 放入以太网帧中，将帧发送到网关路由器。\n- 但是这时候还不知道网关路由器的 MAC 地址，因为 DHCP 过程只知道网关路由器的 IP 地址。因此需要使用 ARP 协议。\n- 主机生成一个 ARP 查询报文，目的地址为网关路由器的 IP 地址。放入以太网帧中，具有广播目的地址 FF:FF:FF:FF:FF:FF 的以太网帧中，并向交换机发送该以太网帧，交换机转发给所有连接设备。\n- 网关路由器接收后，不断分解得到 ARP 报文，发现其中 IP 地址与其接口 IP 地址匹配，因此发送 ARP 回答报文，包含了它的 MAC 地址，发回给主机。\n\n![image-20240318110448792](computer-networks/image-20240318110448792.png)\n\n#### 3. DNS 解析域名\n\n- 网关路由器接收到 DNS 查询以太帧后，抽取 IP 数据报，并根据转发表决定应该转发的路由器。\n- 路由到 NDS 服务器的路由表由内部网关协议（RIP、OSPF）和外部网关协议（BGP）创建。\n- 到达 DNS 服务器后，服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。\n- 找到 DNS 记录后，发送 DNS 回答报文，放入 UDP 数据报中，放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。\n\n![image-20240318123102054](computer-networks/image-20240318123102054.png)\n\n#### 4. HTTP 请求页面\n\n- 有了 HTTP 服务器的 IP 地址后，主机生成 TCP 套接字，用于向 Web 服务器发送 HTTP GET 报文。\n- 生成套接字之前，需要与服务器三次握手来建立连接。客户端生成一个 SYN 报文段（x），发送给服务器。\n- 服务器发回 SYN ACK 报文段（x + 1, y）。\n- 客户端发送 ACK 报文段（y + 1），连接建立。此步为第三次握手，可同时将 HTTP GET 报文发送给服务器。\n- 服务器从 TCP 套接字中读取 HTTP GET 报文，生成 HTTP 响应报文，将 Web 页面内容发回给主机。\n- 主机抽取出内容，渲染，显示 Web 页面。\n\n![image-20240318124318116](computer-networks/image-20240318124318116.png)\n\n![image-20240318124331487](computer-networks/image-20240318124331487.png)\n","source":"_posts/computer-networks.md","raw":"---\ntitle: 计算机网络\ndate: 2024-03-20 23:11:44\ncategories:\n  - work\n  - review\n  - computer networks\ntags:\n  - computer networks\ntoc: true\n---\n\n转载自：https://github.com/CyC2018/CS-Notes/tree/master\n\n## 概述\n\n### 网络的网络\n\n网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。\n\n<!--more-->\n\n![image-20240320231555984](computer-networks/image-20240320231555984.png)\n\n### ISP (Internet Service Provider)\n\n互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。\n\n![image-20240320231606870](computer-networks/image-20240320231606870.png)\n\n目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。\n\n![image-20240320231617299](computer-networks/image-20240320231617299.png)\n\n### 主机间的通信方式\n\n- 客户-服务端（C/S）：客户是服务的请求方，服务器是服务的提供方。\n\n![image-20240320231628966](computer-networks/image-20240320231628966.png)\n\n- 对等（P2P）：不区分客户和服务器。\n\n![image-20240320231639197](computer-networks/image-20240320231639197.png)\n\n### 电路交换与分组交换\n\n#### 1. 电路交换\n\n用于电话通信系统，两个用户通信之前需要建立一条专用的物理链路，并且整个通信过程占用该链路。线路利用率低，往往不到 10%。\n\n#### 2. 分组交换\n\n每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，也就是说分组交换不需要占用传输线路。\n\n在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。\n\n### 时延\n\n总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延\n\n![image-20240320231707214](computer-networks/image-20240320231707214.png)\n\n#### 1. 排队时延\n\n分组在路由器的输入队列和输出**队列中排队等待**的时间，取决于当前网络通信量。\n\n#### 2. 处理时延\n\n主机或路由器收到分组后，进行处理需要的时间。例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。\n\n#### 3. 传输时延\n\n主机或路由器传输数据帧所需要的时间。\n\n![image-20240320231718044](computer-networks/image-20240320231718044.png)\n\n其中 l 表示数据帧的长度，v 表示传输速率。\n\n#### 4. 传播时延\n\n电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。\n\n![image-20240320231728699](computer-networks/image-20240320231728699.png)\n\n其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。\n\n### 计算机网络体系结构\n\n![image-20240320231741490](computer-networks/image-20240320231741490.png)\n\n#### 1. 五层协议\n\n- 应用层：为特定的应用程序提供数据传输服务，如：HTTP、DNS、FTP、SMTP、POP3（已被 IMAP 取代）、DHCP、TELNET（已被 SSH 取代）等协议。数据单位：报文（Message）。\n- 传输层：为进程提供数据传输服务。定义通用的传输层协议可以支持不断增多的应用层协议。包括两种协议：\n  - 传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位：报文段（Segment）。\n  - 用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位：数据报（Datagram）。\n- 网络层：为主机提供数据传输服务，网络层把传输层传递下来的报文段或数据报封装成分组。数据单位：分组（Packet）。如：IPv4、IPv6、ARP、ICMP。\n- 数据链路层：主机之间有很多链路，链路层为同一链路的主机提供数据传输服务。把网络层传下来的分组封装成帧（Frame）。如以太网（Ethernet），Wi-Fi，和蓝牙。\n- 物理层：传输 bit 流，尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到。\n\n#### 2. OSI（Open Systems Interconnection）\n\n- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。\n- 会话层：建立及管理会话。\n\n五层协议将这些功能留给应用开发者处理。\n\n#### 3. TCP/IP\n\n相当于五层协议中数据链路层和物理层合并为网络接口层。\n\nTCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。\n\n![image-20240320231946518](computer-networks/image-20240320231946518.png)\n\n#### 4. 数据在各层之间的传递过程\n\n在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。\n\n路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。\n\n## 物理层\n\n### 通信方式\n\n三种传输方式：\n\n- 单工通信：单向传输\n- 半双工通信：双向交替传输\n- 全双工通信：双向同时传输\n\n### 带通调制\n\n模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号，以便在物理介质上发送的信号。\n\n![image-20240320232029117](computer-networks/image-20240320232029117.png)\n\n## 链路层（不完整）\n\n### 基本问题\n\n#### 1. 封装成帧\n\n将网络层传下来的分组（IP）添加首部和尾部，用于标记帧的开始和结束。\n\n![image-20240320232052656](computer-networks/image-20240320232052656.png)\n\n#### 2. 透明传输\n\n透明表示一个实际存在的事物看起来好像不存在一样。\n\n帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n\n下图中：\n\n1. **SOH（Start of Header）**：在 ASCII 中，SOH 的十进制值为 1。它通常用于标记一段信息的开始，尤其是头部信息的开始。\n2. **ESC（Escape）**：在 ASCII 中，ESC 的十进制值为 27。它通常用于引入一个转义序列，这是一种改变后续字符含义的机制。例如，在许多编程语言和命令行界面中，ESC 字符可以用来引入一个颜色、格式或特殊字符的编码。\n3. **EOT（End of Transmission）**：在 ASCII 中，EOT 的十进制值为 4。它通常用于标记一段信息的结束，尤其是在通信中标记传输的结束。\n\n![image-20240320232244255](computer-networks/image-20240320232244255.png)\n\n#### 3. 差错检测\n\n目前广泛使用了循环冗余检验（CRC）来检查比特差错。\n\n## 网络层\n\n### 概述\n\n整个互联网的核心，因此尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。\n\n使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。\n\n![image-20240320233356850](computer-networks/image-20240320233356850.png)\n\n与 IP 协议配套使用的还有三个协议：\n\n- 地址解析协议 ARP（Address Resolution Protocol），知道网关路由器 IP 地址，用该协议广播获得网关路由器的 MAC 地址。\n- 网际控制报文协议 ICMP（Internet Control Message Protocol）\n- 网际组管理协议 IGMP（Internet Group Management Protocol）\n\n### IP 数据报格式\n\n![image-20240320233404661](computer-networks/image-20240320233404661.png)\n\n- **版本** : 有 4（IPv4）和 6（IPv6）两个值；\n- **首部长度** : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。\n- **区分服务** : 用来获得更好的服务，一般情况下不使用。\n- **总长度** : 包括首部长度和数据部分长度。\n- **标识** : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。\n- **标志**（Flags）：这是一个 3 位的字段，其中最重要的两位是 DF（Don't Fragment）和 MF（More Fragments）。\n  - DF 位用于控制数据报是否可以被分片。如果 DF 位被设置（值为 1），那么数据报就不能被分片。如果数据报太大，无法通过下一跳网络，那么它将被丢弃，并且发送 ICMP 错误消息给发送者。如果 DF 位没有被设置（值为 0），那么数据报可以被分片。\n  - MF 位用于表示是否还有更多的片段。如果一个数据报被分片，那么除了最后一个片段之外，所有的片段都会设置 MF 位（值为 1）。最后一个片段的 MF 位不会被设置（值为 0）。这样，接收端就可以知道所有的片段是否都已经接收到了。\n  - 在 IPv6 中，由于不再支持在传输过程中的分片，所以没有这两个字段。IPv6 只在源端支持分片，并且使用了一个完全不同的机制和头部扩展来处理分片。\n- **片偏移** : 和标识符一起，用于发生分片的情况。片偏移的单位为**8 字节**。\n- **生存时间** ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。\n- **协议** ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。\n- **首部检验和** ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。\n\n![image-20240320233517464](computer-networks/image-20240320233517464.png)\n\n### IP 地址编址方式\n\nIP 地址的编址方式经历了三个历史阶段：\n\n- 分类\n- 子网划分\n- 无分类\n\n#### 1. 分类\n\n由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。\n\nIP 地址 ::= {< 网络号 >, < 主机号 >}\n\n![image-20240320233535616](computer-networks/image-20240320233535616.png)\n\n#### 2. 子网划分\n\n通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。\n\nIP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}\n\n要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。\n\n注意，外部网络看不到子网的存在。\n\n一些约定：\n\n- 子网部分：全为 0——本网络。\n- 主机部分：全为 0——本主机。\n- 主机部分：全为 1—— 广播地址，这个网络的所有主机。\n\n#### 3. 无分类\n\n无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。\n\nIP 地址 ::= {< 网络前缀号 >, < 主机号 >}\n\nCIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。\n\nCIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。\n\n一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。\n\n在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。\n\n### 地址解析协议 ARP\n\n网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。\n\n![image-20240320233614781](computer-networks/image-20240320233614781.png)\n\nARP 实现由 IP 地址得到 MAC 地址。\n\n![image-20240320233622336](computer-networks/image-20240320233622336.png)\n\n每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。\n\n如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。\n\n![image-20240320233632927](computer-networks/image-20240320233632927.png)\n\n### 网际控制报文协议 ICMP\n\n位于网络层，但是封装在 IP 数据报中。ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。\n\n![image-20240320233705195](computer-networks/image-20240320233705195.png)\n\nICMP 报文分为差错报告报文和询问报文。\n\n![image-20240320233735273](computer-networks/image-20240320233735273.png)\n\n#### 1. Ping\n\nPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。\n\nPing 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。\n\n#### 2. Traceroute\n\nTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。\n\nTraceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文（type = 3）。\n\n- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文（type = 11）；\n- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。\n- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文（type = 3）。\n- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。\n\n### 虚拟专用网 VPN\n\n由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。\n\n有三个专用地址块：\n\n- 10.0.0.0 ~ 10.255.255.255\n- 172.16.0.0 ~ 172.31.255.255\n- 192.168.0.0 ~ 192.168.255.255\n\nVPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。\n\n下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。\n\n![image-20240320233824232](computer-networks/image-20240320233824232.png)\n\n### 网络地址转换 NAT\n\n专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。\n\n在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。\n\n![image-20240320233838217](computer-networks/image-20240320233838217.png)\n\n![image-20240319094259385](computer-networks/image-20240319094259385.png)\n\n![image-20240319094315691](computer-networks/image-20240319094315691.png)\n\n### 路由器的结构\n\n路由器从功能上可以划分为：路由选择和分组转发。\n\n分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。\n\n![image-20240320233852959](computer-networks/image-20240320233852959.png)\n\n### 路由器分组转发流程\n\n- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。\n- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；\n- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；\n- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；\n- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；\n- 报告转发分组出错。\n\n![image-20240320233906140](computer-networks/image-20240320233906140.png)\n\n### 路由选择协议\n\n路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。\n\n互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。\n\n可以把路由选择协议划分为两大类：\n\n- 自治系统内部的路由选择：RIP 和 OSPF\n- 自治系统间的路由选择：BGP\n\n#### 1. 内部网关协议 RIP（已经被 OSPF 取代）\n\nRIP 是一种基于距离向量（基于 Bellman-Ford 算法）的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。\n\nRIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。\n\n距离向量算法：\n\n- 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；\n- 对修改后的 RIP 报文中的每一个项目，进行以下步骤：\n- 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；\n- 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。\n- 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。\n\nRIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。\n\n#### 2. 内部网关协议 OSPF\n\n开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。\n\n开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。\n\nOSPF 具有以下特点：\n\n- 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。\n- 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。\n- 只有当链路状态发生变化时，路由器才会发送信息。\n\n所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。\n\n#### 3. 外部网关协议 BGP\n\n基于距离矢量算法。\n\nBGP（Border Gateway Protocol，边界网关协议）\n\nAS 之间的路由选择很困难，主要是由于：\n\n- 互联网规模很大；\n- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；\n- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。\n\nBGP 只能寻找一条比较好的路由，而不是最佳路由。\n\n每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。\n\n![image-20240320233951219](computer-networks/image-20240320233951219.png)\n\n## 传输层\n\n网络层只把分组发送到目的主机，但是真正通信的是主机中的进程。传输层提供了进程间的逻辑通信，向高层用户屏蔽了网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。\n\n### UDP 和 TCP 的特点\n\n- 用户数据报协议 UDP（User Datagram Protocol）无连接，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。\n- 传输控制协议 TCP（Transmission Control Protocol）面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。\n\n### UDP 首部格式\n\n![image-20240320234048388](computer-networks/image-20240320234048388.png)\n\n首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的，并不会真正地发送出去。\n\n### TCP 首部格式\n\n![image-20240320234214934](computer-networks/image-20240320234214934.png)\n\n- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。\n- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。\n- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。\n- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。\n- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。\n- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。\n- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。\n\n### TCP 的三次握手\n\n![image-20240320234247573](computer-networks/image-20240320234247573.png)\n\n上图中，大写的 SYN、ACK 为 bit 位，seq 为序列号，ack 为确认号。\n\n假设 A 为客户端，B 为服务器端。\n\n- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。\n- A 向 B 发送连接请求报文，SYN=1，ACK=0（表示这是一个连接请求报文段。），选择一个初始的序号 x。\n- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1（也是希望收到的下一个报文段的序列号），同时也选择一个初始的序号 y。\n- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。\n- B 收到 A 的确认后，连接建立。\n\n**三次握手的原因**\n\n第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。\n\n客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。\n\n### TCP 的四次挥手\n\n![image-20240320234310912](computer-networks/image-20240320234310912.png)\n\n以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。\n\n- A 发送连接释放报文，FIN=1。\n- B 收到之后发出确认（此时 FIN=0），此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。\n- 当 B 不再需要连接时，发送连接释放报文，FIN=1。\n- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。\n- B 收到 A 的确认后释放连接。\n\n**四次挥手的原因**\n\n客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让**服务器端发送还未传送完毕的数据**，传送完毕之后，服务器会发送 FIN 连接释放报文。\n\n**TIME_WAIT**\n\n客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：\n\n- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。\n- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。\n\n### TCP 可靠传输\n\nTCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。\n\n一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：\n\n$$\nRTT_s=(1-\\alpha)\\cdot(RTT_s)+\\alpha\\cdot RTT\n$$\n\n其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。\n\n超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：\n\n$$\nRTO=RTT_s+4\\cdot RTT_d\n$$\n\n其中 RTTd 为偏差的加权平均值。\n\n$$\nRTT_d=(1-\\beta)\\cdot RTT_d+\\beta\\cdot |RTT_s-RTT|\n$$\n\nRTTs 和 RTTd 的计算应该同时进行，因此，两个算式中右边的 RTTs 都是旧的 RTTs。\n\n### TCP 滑动窗口\n\n窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。\n\n发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。\n\n接收窗口只会对窗口内最后一个**按序到达**的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。\n\n![image-20240320234736573](computer-networks/image-20240320234736573.png)\n\n### TCP 流量控制\n\n为了控制发送方发送速率，保证接收方来得及接收。\n\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方发送速率。如果设置为 0，则发送方不能发送数据。\n\n### TCP 拥塞控制\n\n如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。\n\n流量控制是为了让接收方来得及接收，拥塞控制是为了降低整个网络的拥塞程度。\n\n![image-20240320234748836](computer-networks/image-20240320234748836.png)\n\n四个算法：\n\n- 慢开始\n- 拥塞避免\n- 快重传\n- 快恢复\n\n发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。\n\n为了便于讨论，做如下假设：\n\n- 接收方有足够大的接收缓存，因此不会发生流量控制；\n- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。\n\n![image-20240320234811272](computer-networks/image-20240320234811272.png)\n\n#### 1. 慢开始与拥塞避免\n\n发送的最初执行慢开始（指数增长），令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...\n\n注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n\n如果出现了超时，则令 ssthresh = cwnd / 2，cwnd = 1，然后重新执行慢开始。\n\n#### 2. 快重传与快恢复\n\n注意：快重传后紧跟快恢复\n\n在接收方，要求每次接收到报文段都应该对最后一个**已收到的有序报文段**进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。\n\n在发送方，如果收到三个重复确认（也就是收到了四个一样的确认），那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。\n\n在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh（不同的 TCP 分支有不同的处理方式），注意到此时直接进入拥塞避免。\n\n慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n\n![image-20240320234840219](computer-networks/image-20240320234840219.png)\n\n## 应用层\n\n### 域名系统\n\nDNS 是一个分布式数据库（每个站点只保留自己的部分数据），提供了主机名和 IP 地址之间相互转换的服务。\n\n域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。\n\n![image-20240320235442988](computer-networks/image-20240320235442988.png)\n\nDNS 可以用 UDP 或 TCP 传输，使用端口号都为 53。大多数情况，DNS 使用 UDP 传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传以保证可靠性。两种情况下会使用 TCP 传输：\n\n- 返回的响应超过 UDP 能携带的最大数据。\n- 区域传送（是主域名服务器向辅助域名服务器传送变化的那部分数据）。\n\n### 文件传送协议\n\nFTP 使用 TCP 进行连接，需要两个连接来传送一个文件：\n\n- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。\n- 数据连接：传送一个文件数据。\n\n根据数据连接是否是服务器端主动建立，FTP 有主动和被动（主语为服务器）两种模式：\n\n- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。\n\n![image-20240320235524028](computer-networks/image-20240320235524028.png)\n\n- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。\n\n![image-20240320235533138](computer-networks/image-20240320235533138.png)\n\n主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。\n\n### 动态主机配置协议\n\nDHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。\n\nDHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。\n\nDHCP 工作过程如下（跟找工作差不多……）：\n\n1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。\n2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。\n3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。\n4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。\n\n![image-20240320235655694](computer-networks/image-20240320235655694.png)\n\n### 远程登录协议\n\nTELNET（已经被 SSH 协议取代） 用于登录到远程主机上，并且远程主机上的输出也会返回。\n\nTELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。\n\n### 电子邮件协议\n\n电子邮件系统组成部分：\n\n- 用户代理\n- 邮件服务器\n- 邮件协议\n  - 发送协议（常用 SMTP）\n  - 读取协议（常用 POP3 和 IMAP）\n\n![image-20240320235718371](computer-networks/image-20240320235718371.png)\n\n#### 1. SMTP\n\nSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。\n\n![image-20240320235727170](computer-networks/image-20240320235727170.png)\n\n#### 2. POP3\n\n特点是只要用户从服务器上读取了邮件，就删除该邮件。已经被 IMAP 取代。\n\n#### 3. IMAP\n\n客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。\n\n### 常用端口\n\n| 应用             | 应用层协议 | 端口号  | 传输层协议 | 备注                        |\n| ---------------- | ---------- | ------- | ---------- | --------------------------- |\n| 域名解析         | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |\n| 动态主机配置协议 | DHCP       | 67/68   | UDP        |                             |\n| 简单网络管理协议 | SNMP       | 161/162 | UDP        |                             |\n| 文件传送协议     | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |\n| 远程终端协议     | TELNET     | 23      | TCP        |                             |\n| 超文本传送协议   | HTTP       | 80      | TCP        |                             |\n| 简单邮件传送协议 | SMTP       | 25      | TCP        |                             |\n| 邮件读取协议     | POP3       | 110     | TCP        |                             |\n| 网际报文存取协议 | IMAP       | 143     | TCP        |                             |\n\n### Web 页面请求过程\n\n![image-20240318105358847](computer-networks/image-20240318105358847.png)\n\n#### 1. DHCP 配置主机信息\n\n- 假设主机最开始没有 IP 地址及其它信息，需要先试用 DHCP 获取。\n- 主机生成 DHCP 请求报文，放入 UDP 数据报中，目的端口 67，源端口 68。\n- 放入 IP 数据报中，广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）。\n- 放入 MAC 帧中，具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。\n- 连接在交换机的 DHCP 服务器收到广播帧后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。\n- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。\n- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。\n\n![image-20240318105418710](computer-networks/image-20240318105418710.png)\n\n![image-20240318105431532](computer-networks/image-20240318105431532.png)\n\n#### 2. ARP（网络层）解析 MAC 地址\n\n- 主机为了生成套接字，需要知道网站的域名对应的 IP 地址。\n- 主机生成一个 DNS 查询报文，封装在 UDP 中。\n- 放入 IP 数据报中，目的地址 DNS 服务器 IP 地址。\n- 放入以太网帧中，将帧发送到网关路由器。\n- 但是这时候还不知道网关路由器的 MAC 地址，因为 DHCP 过程只知道网关路由器的 IP 地址。因此需要使用 ARP 协议。\n- 主机生成一个 ARP 查询报文，目的地址为网关路由器的 IP 地址。放入以太网帧中，具有广播目的地址 FF:FF:FF:FF:FF:FF 的以太网帧中，并向交换机发送该以太网帧，交换机转发给所有连接设备。\n- 网关路由器接收后，不断分解得到 ARP 报文，发现其中 IP 地址与其接口 IP 地址匹配，因此发送 ARP 回答报文，包含了它的 MAC 地址，发回给主机。\n\n![image-20240318110448792](computer-networks/image-20240318110448792.png)\n\n#### 3. DNS 解析域名\n\n- 网关路由器接收到 DNS 查询以太帧后，抽取 IP 数据报，并根据转发表决定应该转发的路由器。\n- 路由到 NDS 服务器的路由表由内部网关协议（RIP、OSPF）和外部网关协议（BGP）创建。\n- 到达 DNS 服务器后，服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。\n- 找到 DNS 记录后，发送 DNS 回答报文，放入 UDP 数据报中，放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。\n\n![image-20240318123102054](computer-networks/image-20240318123102054.png)\n\n#### 4. HTTP 请求页面\n\n- 有了 HTTP 服务器的 IP 地址后，主机生成 TCP 套接字，用于向 Web 服务器发送 HTTP GET 报文。\n- 生成套接字之前，需要与服务器三次握手来建立连接。客户端生成一个 SYN 报文段（x），发送给服务器。\n- 服务器发回 SYN ACK 报文段（x + 1, y）。\n- 客户端发送 ACK 报文段（y + 1），连接建立。此步为第三次握手，可同时将 HTTP GET 报文发送给服务器。\n- 服务器从 TCP 套接字中读取 HTTP GET 报文，生成 HTTP 响应报文，将 Web 页面内容发回给主机。\n- 主机抽取出内容，渲染，显示 Web 页面。\n\n![image-20240318124318116](computer-networks/image-20240318124318116.png)\n\n![image-20240318124331487](computer-networks/image-20240318124331487.png)\n","slug":"computer-networks","published":1,"updated":"2024-03-22T03:36:11.678Z","comments":1,"layout":"post","photos":[],"_id":"clu247pua0000jocg4vdhcnxo","content":"<p>转载自：<a href=\"https://github.com/CyC2018/CS-Notes/tree/master\">https://github.com/CyC2018/CS-Notes/tree/master</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"网络的网络\"><a href=\"#网络的网络\" class=\"headerlink\" title=\"网络的网络\"></a>网络的网络</h3><p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231555984.png\"></p>\n<h3 id=\"ISP-Internet-Service-Provider\"><a href=\"#ISP-Internet-Service-Provider\" class=\"headerlink\" title=\"ISP (Internet Service Provider)\"></a>ISP (Internet Service Provider)</h3><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231606870.png\"></p>\n<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231617299.png\"></p>\n<h3 id=\"主机间的通信方式\"><a href=\"#主机间的通信方式\" class=\"headerlink\" title=\"主机间的通信方式\"></a>主机间的通信方式</h3><ul>\n<li>客户-服务端（C&#x2F;S）：客户是服务的请求方，服务器是服务的提供方。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231628966.png\"></p>\n<ul>\n<li>对等（P2P）：不区分客户和服务器。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231639197.png\"></p>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><h4 id=\"1-电路交换\"><a href=\"#1-电路交换\" class=\"headerlink\" title=\"1. 电路交换\"></a>1. 电路交换</h4><p>用于电话通信系统，两个用户通信之前需要建立一条专用的物理链路，并且整个通信过程占用该链路。线路利用率低，往往不到 10%。</p>\n<h4 id=\"2-分组交换\"><a href=\"#2-分组交换\" class=\"headerlink\" title=\"2. 分组交换\"></a>2. 分组交换</h4><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，也就是说分组交换不需要占用传输线路。</p>\n<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>\n<h3 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h3><p>总时延 &#x3D; 排队时延 + 处理时延 + 传输时延 + 传播时延</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231707214.png\"></p>\n<h4 id=\"1-排队时延\"><a href=\"#1-排队时延\" class=\"headerlink\" title=\"1. 排队时延\"></a>1. 排队时延</h4><p>分组在路由器的输入队列和输出<strong>队列中排队等待</strong>的时间，取决于当前网络通信量。</p>\n<h4 id=\"2-处理时延\"><a href=\"#2-处理时延\" class=\"headerlink\" title=\"2. 处理时延\"></a>2. 处理时延</h4><p>主机或路由器收到分组后，进行处理需要的时间。例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>\n<h4 id=\"3-传输时延\"><a href=\"#3-传输时延\" class=\"headerlink\" title=\"3. 传输时延\"></a>3. 传输时延</h4><p>主机或路由器传输数据帧所需要的时间。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231718044.png\"></p>\n<p>其中 l 表示数据帧的长度，v 表示传输速率。</p>\n<h4 id=\"4-传播时延\"><a href=\"#4-传播时延\" class=\"headerlink\" title=\"4. 传播时延\"></a>4. 传播时延</h4><p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231728699.png\"></p>\n<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p>\n<h3 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320231741490.png\"></p>\n<h4 id=\"1-五层协议\"><a href=\"#1-五层协议\" class=\"headerlink\" title=\"1. 五层协议\"></a>1. 五层协议</h4><ul>\n<li>应用层：为特定的应用程序提供数据传输服务，如：HTTP、DNS、FTP、SMTP、POP3（已被 IMAP 取代）、DHCP、TELNET（已被 SSH 取代）等协议。数据单位：报文（Message）。</li>\n<li>传输层：为进程提供数据传输服务。定义通用的传输层协议可以支持不断增多的应用层协议。包括两种协议：<ul>\n<li>传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位：报文段（Segment）。</li>\n<li>用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位：数据报（Datagram）。</li>\n</ul>\n</li>\n<li>网络层：为主机提供数据传输服务，网络层把传输层传递下来的报文段或数据报封装成分组。数据单位：分组（Packet）。如：IPv4、IPv6、ARP、ICMP。</li>\n<li>数据链路层：主机之间有很多链路，链路层为同一链路的主机提供数据传输服务。把网络层传下来的分组封装成帧（Frame）。如以太网（Ethernet），Wi-Fi，和蓝牙。</li>\n<li>物理层：传输 bit 流，尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到。</li>\n</ul>\n<h4 id=\"2-OSI（Open-Systems-Interconnection）\"><a href=\"#2-OSI（Open-Systems-Interconnection）\" class=\"headerlink\" title=\"2. OSI（Open Systems Interconnection）\"></a>2. OSI（Open Systems Interconnection）</h4><ul>\n<li>表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>\n<li>会话层：建立及管理会话。</li>\n</ul>\n<p>五层协议将这些功能留给应用开发者处理。</p>\n<h4 id=\"3-TCP-IP\"><a href=\"#3-TCP-IP\" class=\"headerlink\" title=\"3. TCP&#x2F;IP\"></a>3. TCP&#x2F;IP</h4><p>相当于五层协议中数据链路层和物理层合并为网络接口层。</p>\n<p>TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231946518.png\"></p>\n<h4 id=\"4-数据在各层之间的传递过程\"><a href=\"#4-数据在各层之间的传递过程\" class=\"headerlink\" title=\"4. 数据在各层之间的传递过程\"></a>4. 数据在各层之间的传递过程</h4><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>\n<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><h3 id=\"通信方式\"><a href=\"#通信方式\" class=\"headerlink\" title=\"通信方式\"></a>通信方式</h3><p>三种传输方式：</p>\n<ul>\n<li>单工通信：单向传输</li>\n<li>半双工通信：双向交替传输</li>\n<li>全双工通信：双向同时传输</li>\n</ul>\n<h3 id=\"带通调制\"><a href=\"#带通调制\" class=\"headerlink\" title=\"带通调制\"></a>带通调制</h3><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号，以便在物理介质上发送的信号。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320232029117.png\"></p>\n<h2 id=\"链路层（不完整）\"><a href=\"#链路层（不完整）\" class=\"headerlink\" title=\"链路层（不完整）\"></a>链路层（不完整）</h2><h3 id=\"基本问题\"><a href=\"#基本问题\" class=\"headerlink\" title=\"基本问题\"></a>基本问题</h3><h4 id=\"1-封装成帧\"><a href=\"#1-封装成帧\" class=\"headerlink\" title=\"1. 封装成帧\"></a>1. 封装成帧</h4><p>将网络层传下来的分组（IP）添加首部和尾部，用于标记帧的开始和结束。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320232052656.png\"></p>\n<h4 id=\"2-透明传输\"><a href=\"#2-透明传输\" class=\"headerlink\" title=\"2. 透明传输\"></a>2. 透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样。</p>\n<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>\n<p>下图中：</p>\n<ol>\n<li><strong>SOH（Start of Header）</strong>：在 ASCII 中，SOH 的十进制值为 1。它通常用于标记一段信息的开始，尤其是头部信息的开始。</li>\n<li><strong>ESC（Escape）</strong>：在 ASCII 中，ESC 的十进制值为 27。它通常用于引入一个转义序列，这是一种改变后续字符含义的机制。例如，在许多编程语言和命令行界面中，ESC 字符可以用来引入一个颜色、格式或特殊字符的编码。</li>\n<li><strong>EOT（End of Transmission）</strong>：在 ASCII 中，EOT 的十进制值为 4。它通常用于标记一段信息的结束，尤其是在通信中标记传输的结束。</li>\n</ol>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320232244255.png\"></p>\n<h4 id=\"3-差错检测\"><a href=\"#3-差错检测\" class=\"headerlink\" title=\"3. 差错检测\"></a>3. 差错检测</h4><p>目前广泛使用了循环冗余检验（CRC）来检查比特差错。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>整个互联网的核心，因此尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>\n<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233356850.png\"></p>\n<p>与 IP 协议配套使用的还有三个协议：</p>\n<ul>\n<li>地址解析协议 ARP（Address Resolution Protocol），知道网关路由器 IP 地址，用该协议广播获得网关路由器的 MAC 地址。</li>\n<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>\n<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>\n</ul>\n<h3 id=\"IP-数据报格式\"><a href=\"#IP-数据报格式\" class=\"headerlink\" title=\"IP 数据报格式\"></a>IP 数据报格式</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320233404661.png\"></p>\n<ul>\n<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>\n<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>\n<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>\n<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>\n<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>\n<li><strong>标志</strong>（Flags）：这是一个 3 位的字段，其中最重要的两位是 DF（Don’t Fragment）和 MF（More Fragments）。<ul>\n<li>DF 位用于控制数据报是否可以被分片。如果 DF 位被设置（值为 1），那么数据报就不能被分片。如果数据报太大，无法通过下一跳网络，那么它将被丢弃，并且发送 ICMP 错误消息给发送者。如果 DF 位没有被设置（值为 0），那么数据报可以被分片。</li>\n<li>MF 位用于表示是否还有更多的片段。如果一个数据报被分片，那么除了最后一个片段之外，所有的片段都会设置 MF 位（值为 1）。最后一个片段的 MF 位不会被设置（值为 0）。这样，接收端就可以知道所有的片段是否都已经接收到了。</li>\n<li>在 IPv6 中，由于不再支持在传输过程中的分片，所以没有这两个字段。IPv6 只在源端支持分片，并且使用了一个完全不同的机制和头部扩展来处理分片。</li>\n</ul>\n</li>\n<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为<strong>8 字节</strong>。</li>\n<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>\n<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>\n<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233517464.png\"></p>\n<h3 id=\"IP-地址编址方式\"><a href=\"#IP-地址编址方式\" class=\"headerlink\" title=\"IP 地址编址方式\"></a>IP 地址编址方式</h3><p>IP 地址的编址方式经历了三个历史阶段：</p>\n<ul>\n<li>分类</li>\n<li>子网划分</li>\n<li>无分类</li>\n</ul>\n<h4 id=\"1-分类\"><a href=\"#1-分类\" class=\"headerlink\" title=\"1. 分类\"></a>1. 分类</h4><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>\n<p>IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233535616.png\"></p>\n<h4 id=\"2-子网划分\"><a href=\"#2-子网划分\" class=\"headerlink\" title=\"2. 子网划分\"></a>2. 子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>\n<p>IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>\n<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>\n<p>注意，外部网络看不到子网的存在。</p>\n<p>一些约定：</p>\n<ul>\n<li>子网部分：全为 0——本网络。</li>\n<li>主机部分：全为 0——本主机。</li>\n<li>主机部分：全为 1—— 广播地址，这个网络的所有主机。</li>\n</ul>\n<h4 id=\"3-无分类\"><a href=\"#3-无分类\" class=\"headerlink\" title=\"3. 无分类\"></a>3. 无分类</h4><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>\n<p>IP 地址 ::&#x3D; {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>\n<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7&#x2F;20 表示前 20 位为网络前缀。</p>\n<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>\n<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>\n<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>\n<h3 id=\"地址解析协议-ARP\"><a href=\"#地址解析协议-ARP\" class=\"headerlink\" title=\"地址解析协议 ARP\"></a>地址解析协议 ARP</h3><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233614781.png\"></p>\n<p>ARP 实现由 IP 地址得到 MAC 地址。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233622336.png\"></p>\n<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>\n<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233632927.png\"></p>\n<h3 id=\"网际控制报文协议-ICMP\"><a href=\"#网际控制报文协议-ICMP\" class=\"headerlink\" title=\"网际控制报文协议 ICMP\"></a>网际控制报文协议 ICMP</h3><p>位于网络层，但是封装在 IP 数据报中。ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233705195.png\"></p>\n<p>ICMP 报文分为差错报告报文和询问报文。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233735273.png\"></p>\n<h4 id=\"1-Ping\"><a href=\"#1-Ping\" class=\"headerlink\" title=\"1. Ping\"></a>1. Ping</h4><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>\n<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>\n<h4 id=\"2-Traceroute\"><a href=\"#2-Traceroute\" class=\"headerlink\" title=\"2. Traceroute\"></a>2. Traceroute</h4><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>\n<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文（type &#x3D; 3）。</p>\n<ul>\n<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文（type &#x3D; 11）；</li>\n<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>\n<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文（type &#x3D; 3）。</li>\n<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>\n</ul>\n<h3 id=\"虚拟专用网-VPN\"><a href=\"#虚拟专用网-VPN\" class=\"headerlink\" title=\"虚拟专用网 VPN\"></a>虚拟专用网 VPN</h3><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>\n<p>有三个专用地址块：</p>\n<ul>\n<li>10.0.0.0 ~ 10.255.255.255</li>\n<li>172.16.0.0 ~ 172.31.255.255</li>\n<li>192.168.0.0 ~ 192.168.255.255</li>\n</ul>\n<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>\n<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233824232.png\"></p>\n<h3 id=\"网络地址转换-NAT\"><a href=\"#网络地址转换-NAT\" class=\"headerlink\" title=\"网络地址转换 NAT\"></a>网络地址转换 NAT</h3><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>\n<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233838217.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240319094259385.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240319094315691.png\"></p>\n<h3 id=\"路由器的结构\"><a href=\"#路由器的结构\" class=\"headerlink\" title=\"路由器的结构\"></a>路由器的结构</h3><p>路由器从功能上可以划分为：路由选择和分组转发。</p>\n<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233852959.png\"></p>\n<h3 id=\"路由器分组转发流程\"><a href=\"#路由器分组转发流程\" class=\"headerlink\" title=\"路由器分组转发流程\"></a>路由器分组转发流程</h3><ul>\n<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>\n<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>\n<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>\n<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>\n<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>\n<li>报告转发分组出错。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233906140.png\"></p>\n<h3 id=\"路由选择协议\"><a href=\"#路由选择协议\" class=\"headerlink\" title=\"路由选择协议\"></a>路由选择协议</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>\n<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>\n<p>可以把路由选择协议划分为两大类：</p>\n<ul>\n<li>自治系统内部的路由选择：RIP 和 OSPF</li>\n<li>自治系统间的路由选择：BGP</li>\n</ul>\n<h4 id=\"1-内部网关协议-RIP（已经被-OSPF-取代）\"><a href=\"#1-内部网关协议-RIP（已经被-OSPF-取代）\" class=\"headerlink\" title=\"1. 内部网关协议 RIP（已经被 OSPF 取代）\"></a>1. 内部网关协议 RIP（已经被 OSPF 取代）</h4><p>RIP 是一种基于距离向量（基于 Bellman-Ford 算法）的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>\n<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>\n<p>距离向量算法：</p>\n<ul>\n<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>\n<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>\n<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>\n<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>\n<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>\n</ul>\n<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>\n<h4 id=\"2-内部网关协议-OSPF\"><a href=\"#2-内部网关协议-OSPF\" class=\"headerlink\" title=\"2. 内部网关协议 OSPF\"></a>2. 内部网关协议 OSPF</h4><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>\n<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>\n<p>OSPF 具有以下特点：</p>\n<ul>\n<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>\n<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>\n<li>只有当链路状态发生变化时，路由器才会发送信息。</li>\n</ul>\n<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>\n<h4 id=\"3-外部网关协议-BGP\"><a href=\"#3-外部网关协议-BGP\" class=\"headerlink\" title=\"3. 外部网关协议 BGP\"></a>3. 外部网关协议 BGP</h4><p>基于距离矢量算法。</p>\n<p>BGP（Border Gateway Protocol，边界网关协议）</p>\n<p>AS 之间的路由选择很困难，主要是由于：</p>\n<ul>\n<li>互联网规模很大；</li>\n<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>\n<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>\n</ul>\n<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>\n<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233951219.png\"></p>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>网络层只把分组发送到目的主机，但是真正通信的是主机中的进程。传输层提供了进程间的逻辑通信，向高层用户屏蔽了网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>\n<h3 id=\"UDP-和-TCP-的特点\"><a href=\"#UDP-和-TCP-的特点\" class=\"headerlink\" title=\"UDP 和 TCP 的特点\"></a>UDP 和 TCP 的特点</h3><ul>\n<li>用户数据报协议 UDP（User Datagram Protocol）无连接，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>\n<li>传输控制协议 TCP（Transmission Control Protocol）面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>\n</ul>\n<h3 id=\"UDP-首部格式\"><a href=\"#UDP-首部格式\" class=\"headerlink\" title=\"UDP 首部格式\"></a>UDP 首部格式</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234048388.png\"></p>\n<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的，并不会真正地发送出去。</p>\n<h3 id=\"TCP-首部格式\"><a href=\"#TCP-首部格式\" class=\"headerlink\" title=\"TCP 首部格式\"></a>TCP 首部格式</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234214934.png\"></p>\n<ul>\n<li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>\n<li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>\n<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li>\n<li><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>\n<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</li>\n<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>\n<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>\n</ul>\n<h3 id=\"TCP-的三次握手\"><a href=\"#TCP-的三次握手\" class=\"headerlink\" title=\"TCP 的三次握手\"></a>TCP 的三次握手</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234247573.png\"></p>\n<p>上图中，大写的 SYN、ACK 为 bit 位，seq 为序列号，ack 为确认号。</p>\n<p>假设 A 为客户端，B 为服务器端。</p>\n<ul>\n<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>\n<li>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0（表示这是一个连接请求报文段。），选择一个初始的序号 x。</li>\n<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1（也是希望收到的下一个报文段的序列号），同时也选择一个初始的序号 y。</li>\n<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>\n<li>B 收到 A 的确认后，连接建立。</li>\n</ul>\n<p><strong>三次握手的原因</strong></p>\n<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>\n<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>\n<h3 id=\"TCP-的四次挥手\"><a href=\"#TCP-的四次挥手\" class=\"headerlink\" title=\"TCP 的四次挥手\"></a>TCP 的四次挥手</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234310912.png\"></p>\n<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>\n<ul>\n<li>A 发送连接释放报文，FIN&#x3D;1。</li>\n<li>B 收到之后发出确认（此时 FIN&#x3D;0），此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>\n<li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1。</li>\n<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>\n<li>B 收到 A 的确认后释放连接。</li>\n</ul>\n<p><strong>四次挥手的原因</strong></p>\n<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让<strong>服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>\n<p><strong>TIME_WAIT</strong></p>\n<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>\n<ul>\n<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>\n<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>\n</ul>\n<h3 id=\"TCP-可靠传输\"><a href=\"#TCP-可靠传输\" class=\"headerlink\" title=\"TCP 可靠传输\"></a>TCP 可靠传输</h3><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>\n<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>\n<p>$$<br>RTT_s&#x3D;(1-\\alpha)\\cdot(RTT_s)+\\alpha\\cdot RTT<br>$$</p>\n<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>\n<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>\n<p>$$<br>RTO&#x3D;RTT_s+4\\cdot RTT_d<br>$$</p>\n<p>其中 RTTd 为偏差的加权平均值。</p>\n<p>$$<br>RTT_d&#x3D;(1-\\beta)\\cdot RTT_d+\\beta\\cdot |RTT_s-RTT|<br>$$</p>\n<p>RTTs 和 RTTd 的计算应该同时进行，因此，两个算式中右边的 RTTs 都是旧的 RTTs。</p>\n<h3 id=\"TCP-滑动窗口\"><a href=\"#TCP-滑动窗口\" class=\"headerlink\" title=\"TCP 滑动窗口\"></a>TCP 滑动窗口</h3><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>\n<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>\n<p>接收窗口只会对窗口内最后一个<strong>按序到达</strong>的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234736573.png\"></p>\n<h3 id=\"TCP-流量控制\"><a href=\"#TCP-流量控制\" class=\"headerlink\" title=\"TCP 流量控制\"></a>TCP 流量控制</h3><p>为了控制发送方发送速率，保证接收方来得及接收。</p>\n<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方发送速率。如果设置为 0，则发送方不能发送数据。</p>\n<h3 id=\"TCP-拥塞控制\"><a href=\"#TCP-拥塞控制\" class=\"headerlink\" title=\"TCP 拥塞控制\"></a>TCP 拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。</p>\n<p>流量控制是为了让接收方来得及接收，拥塞控制是为了降低整个网络的拥塞程度。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234748836.png\"></p>\n<p>四个算法：</p>\n<ul>\n<li>慢开始</li>\n<li>拥塞避免</li>\n<li>快重传</li>\n<li>快恢复</li>\n</ul>\n<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>\n<p>为了便于讨论，做如下假设：</p>\n<ul>\n<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>\n<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234811272.png\"></p>\n<h4 id=\"1-慢开始与拥塞避免\"><a href=\"#1-慢开始与拥塞避免\" class=\"headerlink\" title=\"1. 慢开始与拥塞避免\"></a>1. 慢开始与拥塞避免</h4><p>发送的最初执行慢开始（指数增长），令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>\n<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>\n<p>如果出现了超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，cwnd &#x3D; 1，然后重新执行慢开始。</p>\n<h4 id=\"2-快重传与快恢复\"><a href=\"#2-快重传与快恢复\" class=\"headerlink\" title=\"2. 快重传与快恢复\"></a>2. 快重传与快恢复</h4><p>注意：快重传后紧跟快恢复</p>\n<p>在接收方，要求每次接收到报文段都应该对最后一个<strong>已收到的有序报文段</strong>进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>\n<p>在发送方，如果收到三个重复确认（也就是收到了四个一样的确认），那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>\n<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh &#x3D; cwnd &#x2F; 2 ，cwnd &#x3D; ssthresh（不同的 TCP 分支有不同的处理方式），注意到此时直接进入拥塞避免。</p>\n<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234840219.png\"></p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><h3 id=\"域名系统\"><a href=\"#域名系统\" class=\"headerlink\" title=\"域名系统\"></a>域名系统</h3><p>DNS 是一个分布式数据库（每个站点只保留自己的部分数据），提供了主机名和 IP 地址之间相互转换的服务。</p>\n<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235442988.png\"></p>\n<p>DNS 可以用 UDP 或 TCP 传输，使用端口号都为 53。大多数情况，DNS 使用 UDP 传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传以保证可靠性。两种情况下会使用 TCP 传输：</p>\n<ul>\n<li>返回的响应超过 UDP 能携带的最大数据。</li>\n<li>区域传送（是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>\n</ul>\n<h3 id=\"文件传送协议\"><a href=\"#文件传送协议\" class=\"headerlink\" title=\"文件传送协议\"></a>文件传送协议</h3><p>FTP 使用 TCP 进行连接，需要两个连接来传送一个文件：</p>\n<ul>\n<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>\n<li>数据连接：传送一个文件数据。</li>\n</ul>\n<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动（主语为服务器）两种模式：</p>\n<ul>\n<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235524028.png\"></p>\n<ul>\n<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235533138.png\"></p>\n<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>\n<h3 id=\"动态主机配置协议\"><a href=\"#动态主机配置协议\" class=\"headerlink\" title=\"动态主机配置协议\"></a>动态主机配置协议</h3><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>\n<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>\n<p>DHCP 工作过程如下（跟找工作差不多……）：</p>\n<ol>\n<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>\n<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>\n<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>\n<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>\n</ol>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235655694.png\"></p>\n<h3 id=\"远程登录协议\"><a href=\"#远程登录协议\" class=\"headerlink\" title=\"远程登录协议\"></a>远程登录协议</h3><p>TELNET（已经被 SSH 协议取代） 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>\n<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>\n<h3 id=\"电子邮件协议\"><a href=\"#电子邮件协议\" class=\"headerlink\" title=\"电子邮件协议\"></a>电子邮件协议</h3><p>电子邮件系统组成部分：</p>\n<ul>\n<li>用户代理</li>\n<li>邮件服务器</li>\n<li>邮件协议<ul>\n<li>发送协议（常用 SMTP）</li>\n<li>读取协议（常用 POP3 和 IMAP）</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235718371.png\"></p>\n<h4 id=\"1-SMTP\"><a href=\"#1-SMTP\" class=\"headerlink\" title=\"1. SMTP\"></a>1. SMTP</h4><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235727170.png\"></p>\n<h4 id=\"2-POP3\"><a href=\"#2-POP3\" class=\"headerlink\" title=\"2. POP3\"></a>2. POP3</h4><p>特点是只要用户从服务器上读取了邮件，就删除该邮件。已经被 IMAP 取代。</p>\n<h4 id=\"3-IMAP\"><a href=\"#3-IMAP\" class=\"headerlink\" title=\"3. IMAP\"></a>3. IMAP</h4><p>客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>\n<h3 id=\"常用端口\"><a href=\"#常用端口\" class=\"headerlink\" title=\"常用端口\"></a>常用端口</h3><table>\n<thead>\n<tr>\n<th>应用</th>\n<th>应用层协议</th>\n<th>端口号</th>\n<th>传输层协议</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>域名解析</td>\n<td>DNS</td>\n<td>53</td>\n<td>UDP&#x2F;TCP</td>\n<td>长度超过 512 字节时使用 TCP</td>\n</tr>\n<tr>\n<td>动态主机配置协议</td>\n<td>DHCP</td>\n<td>67&#x2F;68</td>\n<td>UDP</td>\n<td></td>\n</tr>\n<tr>\n<td>简单网络管理协议</td>\n<td>SNMP</td>\n<td>161&#x2F;162</td>\n<td>UDP</td>\n<td></td>\n</tr>\n<tr>\n<td>文件传送协议</td>\n<td>FTP</td>\n<td>20&#x2F;21</td>\n<td>TCP</td>\n<td>控制连接 21，数据连接 20</td>\n</tr>\n<tr>\n<td>远程终端协议</td>\n<td>TELNET</td>\n<td>23</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>超文本传送协议</td>\n<td>HTTP</td>\n<td>80</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>简单邮件传送协议</td>\n<td>SMTP</td>\n<td>25</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>邮件读取协议</td>\n<td>POP3</td>\n<td>110</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>网际报文存取协议</td>\n<td>IMAP</td>\n<td>143</td>\n<td>TCP</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"Web-页面请求过程\"><a href=\"#Web-页面请求过程\" class=\"headerlink\" title=\"Web 页面请求过程\"></a>Web 页面请求过程</h3><p><img src=\"/2024/03/20/computer-networks/image-20240318105358847.png\"></p>\n<h4 id=\"1-DHCP-配置主机信息\"><a href=\"#1-DHCP-配置主机信息\" class=\"headerlink\" title=\"1. DHCP 配置主机信息\"></a>1. DHCP 配置主机信息</h4><ul>\n<li>假设主机最开始没有 IP 地址及其它信息，需要先试用 DHCP 获取。</li>\n<li>主机生成 DHCP 请求报文，放入 UDP 数据报中，目的端口 67，源端口 68。</li>\n<li>放入 IP 数据报中，广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）。</li>\n<li>放入 MAC 帧中，具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li>\n<li>连接在交换机的 DHCP 服务器收到广播帧后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>\n<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>\n<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318105418710.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318105431532.png\"></p>\n<h4 id=\"2-ARP（网络层）解析-MAC-地址\"><a href=\"#2-ARP（网络层）解析-MAC-地址\" class=\"headerlink\" title=\"2. ARP（网络层）解析 MAC 地址\"></a>2. ARP（网络层）解析 MAC 地址</h4><ul>\n<li>主机为了生成套接字，需要知道网站的域名对应的 IP 地址。</li>\n<li>主机生成一个 DNS 查询报文，封装在 UDP 中。</li>\n<li>放入 IP 数据报中，目的地址 DNS 服务器 IP 地址。</li>\n<li>放入以太网帧中，将帧发送到网关路由器。</li>\n<li>但是这时候还不知道网关路由器的 MAC 地址，因为 DHCP 过程只知道网关路由器的 IP 地址。因此需要使用 ARP 协议。</li>\n<li>主机生成一个 ARP 查询报文，目的地址为网关路由器的 IP 地址。放入以太网帧中，具有广播目的地址 FF:FF:FF:FF:FF:FF 的以太网帧中，并向交换机发送该以太网帧，交换机转发给所有连接设备。</li>\n<li>网关路由器接收后，不断分解得到 ARP 报文，发现其中 IP 地址与其接口 IP 地址匹配，因此发送 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318110448792.png\"></p>\n<h4 id=\"3-DNS-解析域名\"><a href=\"#3-DNS-解析域名\" class=\"headerlink\" title=\"3. DNS 解析域名\"></a>3. DNS 解析域名</h4><ul>\n<li>网关路由器接收到 DNS 查询以太帧后，抽取 IP 数据报，并根据转发表决定应该转发的路由器。</li>\n<li>路由到 NDS 服务器的路由表由内部网关协议（RIP、OSPF）和外部网关协议（BGP）创建。</li>\n<li>到达 DNS 服务器后，服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>\n<li>找到 DNS 记录后，发送 DNS 回答报文，放入 UDP 数据报中，放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318123102054.png\"></p>\n<h4 id=\"4-HTTP-请求页面\"><a href=\"#4-HTTP-请求页面\" class=\"headerlink\" title=\"4. HTTP 请求页面\"></a>4. HTTP 请求页面</h4><ul>\n<li>有了 HTTP 服务器的 IP 地址后，主机生成 TCP 套接字，用于向 Web 服务器发送 HTTP GET 报文。</li>\n<li>生成套接字之前，需要与服务器三次握手来建立连接。客户端生成一个 SYN 报文段（x），发送给服务器。</li>\n<li>服务器发回 SYN ACK 报文段（x + 1, y）。</li>\n<li>客户端发送 ACK 报文段（y + 1），连接建立。此步为第三次握手，可同时将 HTTP GET 报文发送给服务器。</li>\n<li>服务器从 TCP 套接字中读取 HTTP GET 报文，生成 HTTP 响应报文，将 Web 页面内容发回给主机。</li>\n<li>主机抽取出内容，渲染，显示 Web 页面。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318124318116.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318124331487.png\"></p>\n","excerpt":"<p>转载自：<a href=\"https://github.com/CyC2018/CS-Notes/tree/master\">https://github.com/CyC2018/CS-Notes/tree/master</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"网络的网络\"><a href=\"#网络的网络\" class=\"headerlink\" title=\"网络的网络\"></a>网络的网络</h3><p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p>","more":"<p><img src=\"/2024/03/20/computer-networks/image-20240320231555984.png\"></p>\n<h3 id=\"ISP-Internet-Service-Provider\"><a href=\"#ISP-Internet-Service-Provider\" class=\"headerlink\" title=\"ISP (Internet Service Provider)\"></a>ISP (Internet Service Provider)</h3><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231606870.png\"></p>\n<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231617299.png\"></p>\n<h3 id=\"主机间的通信方式\"><a href=\"#主机间的通信方式\" class=\"headerlink\" title=\"主机间的通信方式\"></a>主机间的通信方式</h3><ul>\n<li>客户-服务端（C&#x2F;S）：客户是服务的请求方，服务器是服务的提供方。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231628966.png\"></p>\n<ul>\n<li>对等（P2P）：不区分客户和服务器。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231639197.png\"></p>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><h4 id=\"1-电路交换\"><a href=\"#1-电路交换\" class=\"headerlink\" title=\"1. 电路交换\"></a>1. 电路交换</h4><p>用于电话通信系统，两个用户通信之前需要建立一条专用的物理链路，并且整个通信过程占用该链路。线路利用率低，往往不到 10%。</p>\n<h4 id=\"2-分组交换\"><a href=\"#2-分组交换\" class=\"headerlink\" title=\"2. 分组交换\"></a>2. 分组交换</h4><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，也就是说分组交换不需要占用传输线路。</p>\n<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>\n<h3 id=\"时延\"><a href=\"#时延\" class=\"headerlink\" title=\"时延\"></a>时延</h3><p>总时延 &#x3D; 排队时延 + 处理时延 + 传输时延 + 传播时延</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231707214.png\"></p>\n<h4 id=\"1-排队时延\"><a href=\"#1-排队时延\" class=\"headerlink\" title=\"1. 排队时延\"></a>1. 排队时延</h4><p>分组在路由器的输入队列和输出<strong>队列中排队等待</strong>的时间，取决于当前网络通信量。</p>\n<h4 id=\"2-处理时延\"><a href=\"#2-处理时延\" class=\"headerlink\" title=\"2. 处理时延\"></a>2. 处理时延</h4><p>主机或路由器收到分组后，进行处理需要的时间。例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>\n<h4 id=\"3-传输时延\"><a href=\"#3-传输时延\" class=\"headerlink\" title=\"3. 传输时延\"></a>3. 传输时延</h4><p>主机或路由器传输数据帧所需要的时间。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231718044.png\"></p>\n<p>其中 l 表示数据帧的长度，v 表示传输速率。</p>\n<h4 id=\"4-传播时延\"><a href=\"#4-传播时延\" class=\"headerlink\" title=\"4. 传播时延\"></a>4. 传播时延</h4><p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231728699.png\"></p>\n<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p>\n<h3 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320231741490.png\"></p>\n<h4 id=\"1-五层协议\"><a href=\"#1-五层协议\" class=\"headerlink\" title=\"1. 五层协议\"></a>1. 五层协议</h4><ul>\n<li>应用层：为特定的应用程序提供数据传输服务，如：HTTP、DNS、FTP、SMTP、POP3（已被 IMAP 取代）、DHCP、TELNET（已被 SSH 取代）等协议。数据单位：报文（Message）。</li>\n<li>传输层：为进程提供数据传输服务。定义通用的传输层协议可以支持不断增多的应用层协议。包括两种协议：<ul>\n<li>传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位：报文段（Segment）。</li>\n<li>用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位：数据报（Datagram）。</li>\n</ul>\n</li>\n<li>网络层：为主机提供数据传输服务，网络层把传输层传递下来的报文段或数据报封装成分组。数据单位：分组（Packet）。如：IPv4、IPv6、ARP、ICMP。</li>\n<li>数据链路层：主机之间有很多链路，链路层为同一链路的主机提供数据传输服务。把网络层传下来的分组封装成帧（Frame）。如以太网（Ethernet），Wi-Fi，和蓝牙。</li>\n<li>物理层：传输 bit 流，尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到。</li>\n</ul>\n<h4 id=\"2-OSI（Open-Systems-Interconnection）\"><a href=\"#2-OSI（Open-Systems-Interconnection）\" class=\"headerlink\" title=\"2. OSI（Open Systems Interconnection）\"></a>2. OSI（Open Systems Interconnection）</h4><ul>\n<li>表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>\n<li>会话层：建立及管理会话。</li>\n</ul>\n<p>五层协议将这些功能留给应用开发者处理。</p>\n<h4 id=\"3-TCP-IP\"><a href=\"#3-TCP-IP\" class=\"headerlink\" title=\"3. TCP&#x2F;IP\"></a>3. TCP&#x2F;IP</h4><p>相当于五层协议中数据链路层和物理层合并为网络接口层。</p>\n<p>TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320231946518.png\"></p>\n<h4 id=\"4-数据在各层之间的传递过程\"><a href=\"#4-数据在各层之间的传递过程\" class=\"headerlink\" title=\"4. 数据在各层之间的传递过程\"></a>4. 数据在各层之间的传递过程</h4><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>\n<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><h3 id=\"通信方式\"><a href=\"#通信方式\" class=\"headerlink\" title=\"通信方式\"></a>通信方式</h3><p>三种传输方式：</p>\n<ul>\n<li>单工通信：单向传输</li>\n<li>半双工通信：双向交替传输</li>\n<li>全双工通信：双向同时传输</li>\n</ul>\n<h3 id=\"带通调制\"><a href=\"#带通调制\" class=\"headerlink\" title=\"带通调制\"></a>带通调制</h3><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号，以便在物理介质上发送的信号。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320232029117.png\"></p>\n<h2 id=\"链路层（不完整）\"><a href=\"#链路层（不完整）\" class=\"headerlink\" title=\"链路层（不完整）\"></a>链路层（不完整）</h2><h3 id=\"基本问题\"><a href=\"#基本问题\" class=\"headerlink\" title=\"基本问题\"></a>基本问题</h3><h4 id=\"1-封装成帧\"><a href=\"#1-封装成帧\" class=\"headerlink\" title=\"1. 封装成帧\"></a>1. 封装成帧</h4><p>将网络层传下来的分组（IP）添加首部和尾部，用于标记帧的开始和结束。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320232052656.png\"></p>\n<h4 id=\"2-透明传输\"><a href=\"#2-透明传输\" class=\"headerlink\" title=\"2. 透明传输\"></a>2. 透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样。</p>\n<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>\n<p>下图中：</p>\n<ol>\n<li><strong>SOH（Start of Header）</strong>：在 ASCII 中，SOH 的十进制值为 1。它通常用于标记一段信息的开始，尤其是头部信息的开始。</li>\n<li><strong>ESC（Escape）</strong>：在 ASCII 中，ESC 的十进制值为 27。它通常用于引入一个转义序列，这是一种改变后续字符含义的机制。例如，在许多编程语言和命令行界面中，ESC 字符可以用来引入一个颜色、格式或特殊字符的编码。</li>\n<li><strong>EOT（End of Transmission）</strong>：在 ASCII 中，EOT 的十进制值为 4。它通常用于标记一段信息的结束，尤其是在通信中标记传输的结束。</li>\n</ol>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320232244255.png\"></p>\n<h4 id=\"3-差错检测\"><a href=\"#3-差错检测\" class=\"headerlink\" title=\"3. 差错检测\"></a>3. 差错检测</h4><p>目前广泛使用了循环冗余检验（CRC）来检查比特差错。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>整个互联网的核心，因此尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>\n<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233356850.png\"></p>\n<p>与 IP 协议配套使用的还有三个协议：</p>\n<ul>\n<li>地址解析协议 ARP（Address Resolution Protocol），知道网关路由器 IP 地址，用该协议广播获得网关路由器的 MAC 地址。</li>\n<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>\n<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>\n</ul>\n<h3 id=\"IP-数据报格式\"><a href=\"#IP-数据报格式\" class=\"headerlink\" title=\"IP 数据报格式\"></a>IP 数据报格式</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320233404661.png\"></p>\n<ul>\n<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>\n<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>\n<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>\n<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>\n<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>\n<li><strong>标志</strong>（Flags）：这是一个 3 位的字段，其中最重要的两位是 DF（Don’t Fragment）和 MF（More Fragments）。<ul>\n<li>DF 位用于控制数据报是否可以被分片。如果 DF 位被设置（值为 1），那么数据报就不能被分片。如果数据报太大，无法通过下一跳网络，那么它将被丢弃，并且发送 ICMP 错误消息给发送者。如果 DF 位没有被设置（值为 0），那么数据报可以被分片。</li>\n<li>MF 位用于表示是否还有更多的片段。如果一个数据报被分片，那么除了最后一个片段之外，所有的片段都会设置 MF 位（值为 1）。最后一个片段的 MF 位不会被设置（值为 0）。这样，接收端就可以知道所有的片段是否都已经接收到了。</li>\n<li>在 IPv6 中，由于不再支持在传输过程中的分片，所以没有这两个字段。IPv6 只在源端支持分片，并且使用了一个完全不同的机制和头部扩展来处理分片。</li>\n</ul>\n</li>\n<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为<strong>8 字节</strong>。</li>\n<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>\n<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>\n<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233517464.png\"></p>\n<h3 id=\"IP-地址编址方式\"><a href=\"#IP-地址编址方式\" class=\"headerlink\" title=\"IP 地址编址方式\"></a>IP 地址编址方式</h3><p>IP 地址的编址方式经历了三个历史阶段：</p>\n<ul>\n<li>分类</li>\n<li>子网划分</li>\n<li>无分类</li>\n</ul>\n<h4 id=\"1-分类\"><a href=\"#1-分类\" class=\"headerlink\" title=\"1. 分类\"></a>1. 分类</h4><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>\n<p>IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233535616.png\"></p>\n<h4 id=\"2-子网划分\"><a href=\"#2-子网划分\" class=\"headerlink\" title=\"2. 子网划分\"></a>2. 子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>\n<p>IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>\n<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>\n<p>注意，外部网络看不到子网的存在。</p>\n<p>一些约定：</p>\n<ul>\n<li>子网部分：全为 0——本网络。</li>\n<li>主机部分：全为 0——本主机。</li>\n<li>主机部分：全为 1—— 广播地址，这个网络的所有主机。</li>\n</ul>\n<h4 id=\"3-无分类\"><a href=\"#3-无分类\" class=\"headerlink\" title=\"3. 无分类\"></a>3. 无分类</h4><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>\n<p>IP 地址 ::&#x3D; {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>\n<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7&#x2F;20 表示前 20 位为网络前缀。</p>\n<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>\n<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>\n<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>\n<h3 id=\"地址解析协议-ARP\"><a href=\"#地址解析协议-ARP\" class=\"headerlink\" title=\"地址解析协议 ARP\"></a>地址解析协议 ARP</h3><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233614781.png\"></p>\n<p>ARP 实现由 IP 地址得到 MAC 地址。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233622336.png\"></p>\n<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>\n<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233632927.png\"></p>\n<h3 id=\"网际控制报文协议-ICMP\"><a href=\"#网际控制报文协议-ICMP\" class=\"headerlink\" title=\"网际控制报文协议 ICMP\"></a>网际控制报文协议 ICMP</h3><p>位于网络层，但是封装在 IP 数据报中。ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233705195.png\"></p>\n<p>ICMP 报文分为差错报告报文和询问报文。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233735273.png\"></p>\n<h4 id=\"1-Ping\"><a href=\"#1-Ping\" class=\"headerlink\" title=\"1. Ping\"></a>1. Ping</h4><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>\n<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>\n<h4 id=\"2-Traceroute\"><a href=\"#2-Traceroute\" class=\"headerlink\" title=\"2. Traceroute\"></a>2. Traceroute</h4><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>\n<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文（type &#x3D; 3）。</p>\n<ul>\n<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文（type &#x3D; 11）；</li>\n<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>\n<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文（type &#x3D; 3）。</li>\n<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>\n</ul>\n<h3 id=\"虚拟专用网-VPN\"><a href=\"#虚拟专用网-VPN\" class=\"headerlink\" title=\"虚拟专用网 VPN\"></a>虚拟专用网 VPN</h3><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>\n<p>有三个专用地址块：</p>\n<ul>\n<li>10.0.0.0 ~ 10.255.255.255</li>\n<li>172.16.0.0 ~ 172.31.255.255</li>\n<li>192.168.0.0 ~ 192.168.255.255</li>\n</ul>\n<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>\n<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233824232.png\"></p>\n<h3 id=\"网络地址转换-NAT\"><a href=\"#网络地址转换-NAT\" class=\"headerlink\" title=\"网络地址转换 NAT\"></a>网络地址转换 NAT</h3><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>\n<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233838217.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240319094259385.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240319094315691.png\"></p>\n<h3 id=\"路由器的结构\"><a href=\"#路由器的结构\" class=\"headerlink\" title=\"路由器的结构\"></a>路由器的结构</h3><p>路由器从功能上可以划分为：路由选择和分组转发。</p>\n<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233852959.png\"></p>\n<h3 id=\"路由器分组转发流程\"><a href=\"#路由器分组转发流程\" class=\"headerlink\" title=\"路由器分组转发流程\"></a>路由器分组转发流程</h3><ul>\n<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>\n<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>\n<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>\n<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>\n<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>\n<li>报告转发分组出错。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233906140.png\"></p>\n<h3 id=\"路由选择协议\"><a href=\"#路由选择协议\" class=\"headerlink\" title=\"路由选择协议\"></a>路由选择协议</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>\n<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>\n<p>可以把路由选择协议划分为两大类：</p>\n<ul>\n<li>自治系统内部的路由选择：RIP 和 OSPF</li>\n<li>自治系统间的路由选择：BGP</li>\n</ul>\n<h4 id=\"1-内部网关协议-RIP（已经被-OSPF-取代）\"><a href=\"#1-内部网关协议-RIP（已经被-OSPF-取代）\" class=\"headerlink\" title=\"1. 内部网关协议 RIP（已经被 OSPF 取代）\"></a>1. 内部网关协议 RIP（已经被 OSPF 取代）</h4><p>RIP 是一种基于距离向量（基于 Bellman-Ford 算法）的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>\n<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>\n<p>距离向量算法：</p>\n<ul>\n<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>\n<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>\n<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>\n<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>\n<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>\n</ul>\n<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>\n<h4 id=\"2-内部网关协议-OSPF\"><a href=\"#2-内部网关协议-OSPF\" class=\"headerlink\" title=\"2. 内部网关协议 OSPF\"></a>2. 内部网关协议 OSPF</h4><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>\n<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>\n<p>OSPF 具有以下特点：</p>\n<ul>\n<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>\n<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>\n<li>只有当链路状态发生变化时，路由器才会发送信息。</li>\n</ul>\n<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>\n<h4 id=\"3-外部网关协议-BGP\"><a href=\"#3-外部网关协议-BGP\" class=\"headerlink\" title=\"3. 外部网关协议 BGP\"></a>3. 外部网关协议 BGP</h4><p>基于距离矢量算法。</p>\n<p>BGP（Border Gateway Protocol，边界网关协议）</p>\n<p>AS 之间的路由选择很困难，主要是由于：</p>\n<ul>\n<li>互联网规模很大；</li>\n<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>\n<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>\n</ul>\n<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>\n<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320233951219.png\"></p>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>网络层只把分组发送到目的主机，但是真正通信的是主机中的进程。传输层提供了进程间的逻辑通信，向高层用户屏蔽了网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>\n<h3 id=\"UDP-和-TCP-的特点\"><a href=\"#UDP-和-TCP-的特点\" class=\"headerlink\" title=\"UDP 和 TCP 的特点\"></a>UDP 和 TCP 的特点</h3><ul>\n<li>用户数据报协议 UDP（User Datagram Protocol）无连接，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>\n<li>传输控制协议 TCP（Transmission Control Protocol）面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>\n</ul>\n<h3 id=\"UDP-首部格式\"><a href=\"#UDP-首部格式\" class=\"headerlink\" title=\"UDP 首部格式\"></a>UDP 首部格式</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234048388.png\"></p>\n<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的，并不会真正地发送出去。</p>\n<h3 id=\"TCP-首部格式\"><a href=\"#TCP-首部格式\" class=\"headerlink\" title=\"TCP 首部格式\"></a>TCP 首部格式</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234214934.png\"></p>\n<ul>\n<li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>\n<li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>\n<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li>\n<li><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>\n<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</li>\n<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>\n<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>\n</ul>\n<h3 id=\"TCP-的三次握手\"><a href=\"#TCP-的三次握手\" class=\"headerlink\" title=\"TCP 的三次握手\"></a>TCP 的三次握手</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234247573.png\"></p>\n<p>上图中，大写的 SYN、ACK 为 bit 位，seq 为序列号，ack 为确认号。</p>\n<p>假设 A 为客户端，B 为服务器端。</p>\n<ul>\n<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>\n<li>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0（表示这是一个连接请求报文段。），选择一个初始的序号 x。</li>\n<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1（也是希望收到的下一个报文段的序列号），同时也选择一个初始的序号 y。</li>\n<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>\n<li>B 收到 A 的确认后，连接建立。</li>\n</ul>\n<p><strong>三次握手的原因</strong></p>\n<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>\n<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>\n<h3 id=\"TCP-的四次挥手\"><a href=\"#TCP-的四次挥手\" class=\"headerlink\" title=\"TCP 的四次挥手\"></a>TCP 的四次挥手</h3><p><img src=\"/2024/03/20/computer-networks/image-20240320234310912.png\"></p>\n<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>\n<ul>\n<li>A 发送连接释放报文，FIN&#x3D;1。</li>\n<li>B 收到之后发出确认（此时 FIN&#x3D;0），此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>\n<li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1。</li>\n<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>\n<li>B 收到 A 的确认后释放连接。</li>\n</ul>\n<p><strong>四次挥手的原因</strong></p>\n<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让<strong>服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>\n<p><strong>TIME_WAIT</strong></p>\n<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>\n<ul>\n<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>\n<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>\n</ul>\n<h3 id=\"TCP-可靠传输\"><a href=\"#TCP-可靠传输\" class=\"headerlink\" title=\"TCP 可靠传输\"></a>TCP 可靠传输</h3><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>\n<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>\n<p>$$<br>RTT_s&#x3D;(1-\\alpha)\\cdot(RTT_s)+\\alpha\\cdot RTT<br>$$</p>\n<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>\n<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>\n<p>$$<br>RTO&#x3D;RTT_s+4\\cdot RTT_d<br>$$</p>\n<p>其中 RTTd 为偏差的加权平均值。</p>\n<p>$$<br>RTT_d&#x3D;(1-\\beta)\\cdot RTT_d+\\beta\\cdot |RTT_s-RTT|<br>$$</p>\n<p>RTTs 和 RTTd 的计算应该同时进行，因此，两个算式中右边的 RTTs 都是旧的 RTTs。</p>\n<h3 id=\"TCP-滑动窗口\"><a href=\"#TCP-滑动窗口\" class=\"headerlink\" title=\"TCP 滑动窗口\"></a>TCP 滑动窗口</h3><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>\n<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>\n<p>接收窗口只会对窗口内最后一个<strong>按序到达</strong>的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234736573.png\"></p>\n<h3 id=\"TCP-流量控制\"><a href=\"#TCP-流量控制\" class=\"headerlink\" title=\"TCP 流量控制\"></a>TCP 流量控制</h3><p>为了控制发送方发送速率，保证接收方来得及接收。</p>\n<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方发送速率。如果设置为 0，则发送方不能发送数据。</p>\n<h3 id=\"TCP-拥塞控制\"><a href=\"#TCP-拥塞控制\" class=\"headerlink\" title=\"TCP 拥塞控制\"></a>TCP 拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。</p>\n<p>流量控制是为了让接收方来得及接收，拥塞控制是为了降低整个网络的拥塞程度。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234748836.png\"></p>\n<p>四个算法：</p>\n<ul>\n<li>慢开始</li>\n<li>拥塞避免</li>\n<li>快重传</li>\n<li>快恢复</li>\n</ul>\n<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>\n<p>为了便于讨论，做如下假设：</p>\n<ul>\n<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>\n<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234811272.png\"></p>\n<h4 id=\"1-慢开始与拥塞避免\"><a href=\"#1-慢开始与拥塞避免\" class=\"headerlink\" title=\"1. 慢开始与拥塞避免\"></a>1. 慢开始与拥塞避免</h4><p>发送的最初执行慢开始（指数增长），令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>\n<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>\n<p>如果出现了超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，cwnd &#x3D; 1，然后重新执行慢开始。</p>\n<h4 id=\"2-快重传与快恢复\"><a href=\"#2-快重传与快恢复\" class=\"headerlink\" title=\"2. 快重传与快恢复\"></a>2. 快重传与快恢复</h4><p>注意：快重传后紧跟快恢复</p>\n<p>在接收方，要求每次接收到报文段都应该对最后一个<strong>已收到的有序报文段</strong>进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>\n<p>在发送方，如果收到三个重复确认（也就是收到了四个一样的确认），那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>\n<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh &#x3D; cwnd &#x2F; 2 ，cwnd &#x3D; ssthresh（不同的 TCP 分支有不同的处理方式），注意到此时直接进入拥塞避免。</p>\n<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320234840219.png\"></p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><h3 id=\"域名系统\"><a href=\"#域名系统\" class=\"headerlink\" title=\"域名系统\"></a>域名系统</h3><p>DNS 是一个分布式数据库（每个站点只保留自己的部分数据），提供了主机名和 IP 地址之间相互转换的服务。</p>\n<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235442988.png\"></p>\n<p>DNS 可以用 UDP 或 TCP 传输，使用端口号都为 53。大多数情况，DNS 使用 UDP 传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传以保证可靠性。两种情况下会使用 TCP 传输：</p>\n<ul>\n<li>返回的响应超过 UDP 能携带的最大数据。</li>\n<li>区域传送（是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>\n</ul>\n<h3 id=\"文件传送协议\"><a href=\"#文件传送协议\" class=\"headerlink\" title=\"文件传送协议\"></a>文件传送协议</h3><p>FTP 使用 TCP 进行连接，需要两个连接来传送一个文件：</p>\n<ul>\n<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>\n<li>数据连接：传送一个文件数据。</li>\n</ul>\n<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动（主语为服务器）两种模式：</p>\n<ul>\n<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235524028.png\"></p>\n<ul>\n<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235533138.png\"></p>\n<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>\n<h3 id=\"动态主机配置协议\"><a href=\"#动态主机配置协议\" class=\"headerlink\" title=\"动态主机配置协议\"></a>动态主机配置协议</h3><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>\n<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>\n<p>DHCP 工作过程如下（跟找工作差不多……）：</p>\n<ol>\n<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>\n<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>\n<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>\n<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>\n</ol>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235655694.png\"></p>\n<h3 id=\"远程登录协议\"><a href=\"#远程登录协议\" class=\"headerlink\" title=\"远程登录协议\"></a>远程登录协议</h3><p>TELNET（已经被 SSH 协议取代） 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>\n<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>\n<h3 id=\"电子邮件协议\"><a href=\"#电子邮件协议\" class=\"headerlink\" title=\"电子邮件协议\"></a>电子邮件协议</h3><p>电子邮件系统组成部分：</p>\n<ul>\n<li>用户代理</li>\n<li>邮件服务器</li>\n<li>邮件协议<ul>\n<li>发送协议（常用 SMTP）</li>\n<li>读取协议（常用 POP3 和 IMAP）</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235718371.png\"></p>\n<h4 id=\"1-SMTP\"><a href=\"#1-SMTP\" class=\"headerlink\" title=\"1. SMTP\"></a>1. SMTP</h4><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240320235727170.png\"></p>\n<h4 id=\"2-POP3\"><a href=\"#2-POP3\" class=\"headerlink\" title=\"2. POP3\"></a>2. POP3</h4><p>特点是只要用户从服务器上读取了邮件，就删除该邮件。已经被 IMAP 取代。</p>\n<h4 id=\"3-IMAP\"><a href=\"#3-IMAP\" class=\"headerlink\" title=\"3. IMAP\"></a>3. IMAP</h4><p>客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>\n<h3 id=\"常用端口\"><a href=\"#常用端口\" class=\"headerlink\" title=\"常用端口\"></a>常用端口</h3><table>\n<thead>\n<tr>\n<th>应用</th>\n<th>应用层协议</th>\n<th>端口号</th>\n<th>传输层协议</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>域名解析</td>\n<td>DNS</td>\n<td>53</td>\n<td>UDP&#x2F;TCP</td>\n<td>长度超过 512 字节时使用 TCP</td>\n</tr>\n<tr>\n<td>动态主机配置协议</td>\n<td>DHCP</td>\n<td>67&#x2F;68</td>\n<td>UDP</td>\n<td></td>\n</tr>\n<tr>\n<td>简单网络管理协议</td>\n<td>SNMP</td>\n<td>161&#x2F;162</td>\n<td>UDP</td>\n<td></td>\n</tr>\n<tr>\n<td>文件传送协议</td>\n<td>FTP</td>\n<td>20&#x2F;21</td>\n<td>TCP</td>\n<td>控制连接 21，数据连接 20</td>\n</tr>\n<tr>\n<td>远程终端协议</td>\n<td>TELNET</td>\n<td>23</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>超文本传送协议</td>\n<td>HTTP</td>\n<td>80</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>简单邮件传送协议</td>\n<td>SMTP</td>\n<td>25</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>邮件读取协议</td>\n<td>POP3</td>\n<td>110</td>\n<td>TCP</td>\n<td></td>\n</tr>\n<tr>\n<td>网际报文存取协议</td>\n<td>IMAP</td>\n<td>143</td>\n<td>TCP</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"Web-页面请求过程\"><a href=\"#Web-页面请求过程\" class=\"headerlink\" title=\"Web 页面请求过程\"></a>Web 页面请求过程</h3><p><img src=\"/2024/03/20/computer-networks/image-20240318105358847.png\"></p>\n<h4 id=\"1-DHCP-配置主机信息\"><a href=\"#1-DHCP-配置主机信息\" class=\"headerlink\" title=\"1. DHCP 配置主机信息\"></a>1. DHCP 配置主机信息</h4><ul>\n<li>假设主机最开始没有 IP 地址及其它信息，需要先试用 DHCP 获取。</li>\n<li>主机生成 DHCP 请求报文，放入 UDP 数据报中，目的端口 67，源端口 68。</li>\n<li>放入 IP 数据报中，广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）。</li>\n<li>放入 MAC 帧中，具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li>\n<li>连接在交换机的 DHCP 服务器收到广播帧后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>\n<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>\n<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318105418710.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318105431532.png\"></p>\n<h4 id=\"2-ARP（网络层）解析-MAC-地址\"><a href=\"#2-ARP（网络层）解析-MAC-地址\" class=\"headerlink\" title=\"2. ARP（网络层）解析 MAC 地址\"></a>2. ARP（网络层）解析 MAC 地址</h4><ul>\n<li>主机为了生成套接字，需要知道网站的域名对应的 IP 地址。</li>\n<li>主机生成一个 DNS 查询报文，封装在 UDP 中。</li>\n<li>放入 IP 数据报中，目的地址 DNS 服务器 IP 地址。</li>\n<li>放入以太网帧中，将帧发送到网关路由器。</li>\n<li>但是这时候还不知道网关路由器的 MAC 地址，因为 DHCP 过程只知道网关路由器的 IP 地址。因此需要使用 ARP 协议。</li>\n<li>主机生成一个 ARP 查询报文，目的地址为网关路由器的 IP 地址。放入以太网帧中，具有广播目的地址 FF:FF:FF:FF:FF:FF 的以太网帧中，并向交换机发送该以太网帧，交换机转发给所有连接设备。</li>\n<li>网关路由器接收后，不断分解得到 ARP 报文，发现其中 IP 地址与其接口 IP 地址匹配，因此发送 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318110448792.png\"></p>\n<h4 id=\"3-DNS-解析域名\"><a href=\"#3-DNS-解析域名\" class=\"headerlink\" title=\"3. DNS 解析域名\"></a>3. DNS 解析域名</h4><ul>\n<li>网关路由器接收到 DNS 查询以太帧后，抽取 IP 数据报，并根据转发表决定应该转发的路由器。</li>\n<li>路由到 NDS 服务器的路由表由内部网关协议（RIP、OSPF）和外部网关协议（BGP）创建。</li>\n<li>到达 DNS 服务器后，服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>\n<li>找到 DNS 记录后，发送 DNS 回答报文，放入 UDP 数据报中，放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318123102054.png\"></p>\n<h4 id=\"4-HTTP-请求页面\"><a href=\"#4-HTTP-请求页面\" class=\"headerlink\" title=\"4. HTTP 请求页面\"></a>4. HTTP 请求页面</h4><ul>\n<li>有了 HTTP 服务器的 IP 地址后，主机生成 TCP 套接字，用于向 Web 服务器发送 HTTP GET 报文。</li>\n<li>生成套接字之前，需要与服务器三次握手来建立连接。客户端生成一个 SYN 报文段（x），发送给服务器。</li>\n<li>服务器发回 SYN ACK 报文段（x + 1, y）。</li>\n<li>客户端发送 ACK 报文段（y + 1），连接建立。此步为第三次握手，可同时将 HTTP GET 报文发送给服务器。</li>\n<li>服务器从 TCP 套接字中读取 HTTP GET 报文，生成 HTTP 响应报文，将 Web 页面内容发回给主机。</li>\n<li>主机抽取出内容，渲染，显示 Web 页面。</li>\n</ul>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318124318116.png\"></p>\n<p><img src=\"/2024/03/20/computer-networks/image-20240318124331487.png\"></p>"},{"title":"数据库系统原理","date":"2024-03-19T13:54:44.000Z","toc":true,"_content":"\n转载自：https://github.com/CyC2018/CS-Notes/tree/master\n\nhttps://zhuanlan.zhihu.com/p/476601594\n\nhttps://blog.csdn.net/Xupixel/article/details/120405501\n\nhttps://www.hwpo.top/posts/d87f7e0c/index.html\n\nhttps://developer.aliyun.com/article/815625\n\n## 一、事务\n\n### 概念\n\n事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\n<!--more-->\n\n![image-20240319220740283](database-system-principles/image-20240319220740283.png)\n\n#### 1. 原子性（Atomicity）\n\n事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\n#### 2. 一致性（Consistency）\n\n数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）\n\n#### 3. 隔离性（Isolation）\n\n一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\n#### 4. 持久性（Durability）\n\n一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n\n系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n\n---\n\n事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n\n- 只有满足一致性，事务的执行结果才是正确的。\n- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n- 事务满足持久化是为了能应对系统崩溃的情况。\n\n![image-20240319220943892](database-system-principles/image-20240319220943892.png)\n\n### AUTOCOMMIT\n\nMySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n\n## 二、并发一致性问题\n\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n\n### 丢失修改\n\n丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。下图的例子不太能体现丢失修改，将 write 改为 add 就能很好地体现了。\n\n![image-20240319221024695](database-system-principles/image-20240319221024695.png)\n\n### 读脏数据\n\n读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n\n![image-20240319221039549](database-system-principles/image-20240319221039549.png)\n\n### 不可重复读（读已提交导致）\n\n不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。这个图也不太恰当，应将 T1 的提交节点上移至 read A = 20 之上。\n\n![image-20240319221109092](database-system-principles/image-20240319221109092.png)\n\n### 幻影读\n\n幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n![image-20240319221128098](database-system-principles/image-20240319221128098.png)\n\n解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n\n## 三、封锁\n\n### 封锁粒度\n\nMySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n\n### 封锁类型\n\n#### 1. 读写锁\n\n- 互斥锁（Exclusive），简写为 X 锁，又称写锁。\n- 共享锁（Shared），简写为 S 锁，又称读锁。\n\n有以下两个规定：\n\n- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n锁的兼容关系如下：\n\n![image-20240319222609279](database-system-principles/image-20240319222609279.png)\n\n#### 2. 意向锁\n\n使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n\n- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n\n各种锁的兼容关系如下：\n\n![image-20240319222621455](database-system-principles/image-20240319222621455.png)\n\n### 封锁协议\n\n#### 1. 三级封锁协议\n\n**一级封锁协议**\n\n事务 T 要修改数据 A 时必须加**X 锁**，直到 **T 结束**才释放锁。\n\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n\n![image-20240319222801904](database-system-principles/image-20240319222801904.png)\n\n**二级封锁协议**\n\n在一级的基础上，要求读取数据 A 时必须加 **S 锁**，**读取完**马上释放 S 锁。\n\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\n![image-20240319222832886](database-system-principles/image-20240319222832886.png)\n\n**三级封锁协议**\n\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n![image-20240319222857283](database-system-principles/image-20240319222857283.png)\n\n#### 2. 两段锁协议\n\n加锁和解锁分为两个阶段进行。\n\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\n\n```\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n```\n\n但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\n\n```\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\n```\n\n### MySQL 隐式与显式锁定\n\nMySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\n\nInnoDB 也可以使用特定的语句进行显示锁定：\n\n```\nSELECT ... LOCK In SHARE MODE;\nSELECT ... FOR UPDATE;\n```\n\n## 四、隔离级别\n\n### 未提交读（READ UNCOMMITTED）\n\n事务中的修改即使没有提交，对其它事务也是可见的。\n\n### 提交读（READ COMMITTED）\n\n一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n### 可重复读（REPEATABLE READ）\n\n保证在同一个事务中多次读取同一数据的结果是一样的。\n\n### 可串行化（SERIALIZABLE）\n\n强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n![image-20240319223152453](database-system-principles/image-20240319223152453.png)\n\n## 五、多版本并发控制（暂时没见过）\n\n## 六、Next-Key Locks（暂时没见过）\n\n## 七、关系数据库设计理论（以后补充完整）\n\n### 函数依赖\n\n记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n\n如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n\n对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。\n\n对于 A->B，B->C，则 A->C 是一个传递函数依赖。\n\n#### 1. 第一范式 (1NF)\n\n属性不可分。满足原子性。\n\n#### 2. 第二范式 (2NF)\n\n每个非主属性完全函数依赖于键码。消除部分依赖。\n\n#### 3. 第三范式 (3NF)\n\n非主属性不传递函数依赖于键码。消除传递依赖。\n\n## 八、ER 图（以后再补充）\n","source":"_posts/database-system-principles.md","raw":"---\ntitle: 数据库系统原理\ndate: 2024-03-19 21:54:44\ncategories:\n  - work\n  - review\n  - database systems\ntags:\n  - database\n  - principles\ntoc: true\n---\n\n转载自：https://github.com/CyC2018/CS-Notes/tree/master\n\nhttps://zhuanlan.zhihu.com/p/476601594\n\nhttps://blog.csdn.net/Xupixel/article/details/120405501\n\nhttps://www.hwpo.top/posts/d87f7e0c/index.html\n\nhttps://developer.aliyun.com/article/815625\n\n## 一、事务\n\n### 概念\n\n事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\n<!--more-->\n\n![image-20240319220740283](database-system-principles/image-20240319220740283.png)\n\n#### 1. 原子性（Atomicity）\n\n事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\n#### 2. 一致性（Consistency）\n\n数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）\n\n#### 3. 隔离性（Isolation）\n\n一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\n#### 4. 持久性（Durability）\n\n一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n\n系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n\n---\n\n事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n\n- 只有满足一致性，事务的执行结果才是正确的。\n- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n- 事务满足持久化是为了能应对系统崩溃的情况。\n\n![image-20240319220943892](database-system-principles/image-20240319220943892.png)\n\n### AUTOCOMMIT\n\nMySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n\n## 二、并发一致性问题\n\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n\n### 丢失修改\n\n丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。下图的例子不太能体现丢失修改，将 write 改为 add 就能很好地体现了。\n\n![image-20240319221024695](database-system-principles/image-20240319221024695.png)\n\n### 读脏数据\n\n读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n\n![image-20240319221039549](database-system-principles/image-20240319221039549.png)\n\n### 不可重复读（读已提交导致）\n\n不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。这个图也不太恰当，应将 T1 的提交节点上移至 read A = 20 之上。\n\n![image-20240319221109092](database-system-principles/image-20240319221109092.png)\n\n### 幻影读\n\n幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n![image-20240319221128098](database-system-principles/image-20240319221128098.png)\n\n解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n\n## 三、封锁\n\n### 封锁粒度\n\nMySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n\n### 封锁类型\n\n#### 1. 读写锁\n\n- 互斥锁（Exclusive），简写为 X 锁，又称写锁。\n- 共享锁（Shared），简写为 S 锁，又称读锁。\n\n有以下两个规定：\n\n- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n锁的兼容关系如下：\n\n![image-20240319222609279](database-system-principles/image-20240319222609279.png)\n\n#### 2. 意向锁\n\n使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n\n- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n\n各种锁的兼容关系如下：\n\n![image-20240319222621455](database-system-principles/image-20240319222621455.png)\n\n### 封锁协议\n\n#### 1. 三级封锁协议\n\n**一级封锁协议**\n\n事务 T 要修改数据 A 时必须加**X 锁**，直到 **T 结束**才释放锁。\n\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n\n![image-20240319222801904](database-system-principles/image-20240319222801904.png)\n\n**二级封锁协议**\n\n在一级的基础上，要求读取数据 A 时必须加 **S 锁**，**读取完**马上释放 S 锁。\n\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\n![image-20240319222832886](database-system-principles/image-20240319222832886.png)\n\n**三级封锁协议**\n\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n![image-20240319222857283](database-system-principles/image-20240319222857283.png)\n\n#### 2. 两段锁协议\n\n加锁和解锁分为两个阶段进行。\n\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\n\n```\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n```\n\n但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\n\n```\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\n```\n\n### MySQL 隐式与显式锁定\n\nMySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\n\nInnoDB 也可以使用特定的语句进行显示锁定：\n\n```\nSELECT ... LOCK In SHARE MODE;\nSELECT ... FOR UPDATE;\n```\n\n## 四、隔离级别\n\n### 未提交读（READ UNCOMMITTED）\n\n事务中的修改即使没有提交，对其它事务也是可见的。\n\n### 提交读（READ COMMITTED）\n\n一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n### 可重复读（REPEATABLE READ）\n\n保证在同一个事务中多次读取同一数据的结果是一样的。\n\n### 可串行化（SERIALIZABLE）\n\n强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n![image-20240319223152453](database-system-principles/image-20240319223152453.png)\n\n## 五、多版本并发控制（暂时没见过）\n\n## 六、Next-Key Locks（暂时没见过）\n\n## 七、关系数据库设计理论（以后补充完整）\n\n### 函数依赖\n\n记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n\n如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n\n对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。\n\n对于 A->B，B->C，则 A->C 是一个传递函数依赖。\n\n#### 1. 第一范式 (1NF)\n\n属性不可分。满足原子性。\n\n#### 2. 第二范式 (2NF)\n\n每个非主属性完全函数依赖于键码。消除部分依赖。\n\n#### 3. 第三范式 (3NF)\n\n非主属性不传递函数依赖于键码。消除传递依赖。\n\n## 八、ER 图（以后再补充）\n","slug":"database-system-principles","published":1,"updated":"2024-03-22T03:36:11.682Z","comments":1,"layout":"post","photos":[],"_id":"clu247pug0001jocg2piu9ggw","content":"<p>转载自：<a href=\"https://github.com/CyC2018/CS-Notes/tree/master\">https://github.com/CyC2018/CS-Notes/tree/master</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/476601594\">https://zhuanlan.zhihu.com/p/476601594</a></p>\n<p><a href=\"https://blog.csdn.net/Xupixel/article/details/120405501\">https://blog.csdn.net/Xupixel/article/details/120405501</a></p>\n<p><a href=\"https://www.hwpo.top/posts/d87f7e0c/index.html\">https://www.hwpo.top/posts/d87f7e0c/index.html</a></p>\n<p><a href=\"https://developer.aliyun.com/article/815625\">https://developer.aliyun.com/article/815625</a></p>\n<h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220740283.png\"></p>\n<h4 id=\"1-原子性（Atomicity）\"><a href=\"#1-原子性（Atomicity）\" class=\"headerlink\" title=\"1. 原子性（Atomicity）\"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>\n<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>\n<h4 id=\"2-一致性（Consistency）\"><a href=\"#2-一致性（Consistency）\" class=\"headerlink\" title=\"2. 一致性（Consistency）\"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）</p>\n<h4 id=\"3-隔离性（Isolation）\"><a href=\"#3-隔离性（Isolation）\" class=\"headerlink\" title=\"3. 隔离性（Isolation）\"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>\n<h4 id=\"4-持久性（Durability）\"><a href=\"#4-持久性（Durability）\" class=\"headerlink\" title=\"4. 持久性（Durability）\"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>\n<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>\n<hr>\n<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>\n<ul>\n<li>只有满足一致性，事务的执行结果才是正确的。</li>\n<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>\n<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>\n<li>事务满足持久化是为了能应对系统崩溃的情况。</li>\n</ul>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220943892.png\"></p>\n<h3 id=\"AUTOCOMMIT\"><a href=\"#AUTOCOMMIT\" class=\"headerlink\" title=\"AUTOCOMMIT\"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>\n<h2 id=\"二、并发一致性问题\"><a href=\"#二、并发一致性问题\" class=\"headerlink\" title=\"二、并发一致性问题\"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。下图的例子不太能体现丢失修改，将 write 改为 add 就能很好地体现了。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221024695.png\"></p>\n<h3 id=\"读脏数据\"><a href=\"#读脏数据\" class=\"headerlink\" title=\"读脏数据\"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221039549.png\"></p>\n<h3 id=\"不可重复读（读已提交导致）\"><a href=\"#不可重复读（读已提交导致）\" class=\"headerlink\" title=\"不可重复读（读已提交导致）\"></a>不可重复读（读已提交导致）</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。这个图也不太恰当，应将 T1 的提交节点上移至 read A &#x3D; 20 之上。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221109092.png\"></p>\n<h3 id=\"幻影读\"><a href=\"#幻影读\" class=\"headerlink\" title=\"幻影读\"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221128098.png\"></p>\n<p>解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>\n<h2 id=\"三、封锁\"><a href=\"#三、封锁\" class=\"headerlink\" title=\"三、封锁\"></a>三、封锁</h2><h3 id=\"封锁粒度\"><a href=\"#封锁粒度\" class=\"headerlink\" title=\"封锁粒度\"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>\n<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>\n<h3 id=\"封锁类型\"><a href=\"#封锁类型\" class=\"headerlink\" title=\"封锁类型\"></a>封锁类型</h3><h4 id=\"1-读写锁\"><a href=\"#1-读写锁\" class=\"headerlink\" title=\"1. 读写锁\"></a>1. 读写锁</h4><ul>\n<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>\n<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>\n</ul>\n<p>有以下两个规定：</p>\n<ul>\n<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>\n</ul>\n<p>锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222609279.png\"></p>\n<h4 id=\"2-意向锁\"><a href=\"#2-意向锁\" class=\"headerlink\" title=\"2. 意向锁\"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>\n<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>\n<p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，IX&#x2F;IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>\n<ul>\n<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>\n<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>\n</ul>\n<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>\n<p>各种锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222621455.png\"></p>\n<h3 id=\"封锁协议\"><a href=\"#封锁协议\" class=\"headerlink\" title=\"封锁协议\"></a>封锁协议</h3><h4 id=\"1-三级封锁协议\"><a href=\"#1-三级封锁协议\" class=\"headerlink\" title=\"1. 三级封锁协议\"></a>1. 三级封锁协议</h4><p><strong>一级封锁协议</strong></p>\n<p>事务 T 要修改数据 A 时必须加<strong>X 锁</strong>，直到 <strong>T 结束</strong>才释放锁。</p>\n<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222801904.png\"></p>\n<p><strong>二级封锁协议</strong></p>\n<p>在一级的基础上，要求读取数据 A 时必须加 <strong>S 锁</strong>，<strong>读取完</strong>马上释放 S 锁。</p>\n<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222832886.png\"></p>\n<p><strong>三级封锁协议</strong></p>\n<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>\n<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222857283.png\"></p>\n<h4 id=\"2-两段锁协议\"><a href=\"#2-两段锁协议\" class=\"headerlink\" title=\"2. 两段锁协议\"></a>2. 两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>\n<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>\n<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>\n\n<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MySQL-隐式与显式锁定\"><a href=\"#MySQL-隐式与显式锁定\" class=\"headerlink\" title=\"MySQL 隐式与显式锁定\"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>\n<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ... LOCK In SHARE MODE;</span><br><span class=\"line\">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、隔离级别\"><a href=\"#四、隔离级别\" class=\"headerlink\" title=\"四、隔离级别\"></a>四、隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>\n<h3 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319223152453.png\"></p>\n<h2 id=\"五、多版本并发控制（暂时没见过）\"><a href=\"#五、多版本并发控制（暂时没见过）\" class=\"headerlink\" title=\"五、多版本并发控制（暂时没见过）\"></a>五、多版本并发控制（暂时没见过）</h2><h2 id=\"六、Next-Key-Locks（暂时没见过）\"><a href=\"#六、Next-Key-Locks（暂时没见过）\" class=\"headerlink\" title=\"六、Next-Key Locks（暂时没见过）\"></a>六、Next-Key Locks（暂时没见过）</h2><h2 id=\"七、关系数据库设计理论（以后补充完整）\"><a href=\"#七、关系数据库设计理论（以后补充完整）\" class=\"headerlink\" title=\"七、关系数据库设计理论（以后补充完整）\"></a>七、关系数据库设计理论（以后补充完整）</h2><h3 id=\"函数依赖\"><a href=\"#函数依赖\" class=\"headerlink\" title=\"函数依赖\"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>\n<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>\n<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>\n<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>\n<h4 id=\"1-第一范式-1NF\"><a href=\"#1-第一范式-1NF\" class=\"headerlink\" title=\"1. 第一范式 (1NF)\"></a>1. 第一范式 (1NF)</h4><p>属性不可分。满足原子性。</p>\n<h4 id=\"2-第二范式-2NF\"><a href=\"#2-第二范式-2NF\" class=\"headerlink\" title=\"2. 第二范式 (2NF)\"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。消除部分依赖。</p>\n<h4 id=\"3-第三范式-3NF\"><a href=\"#3-第三范式-3NF\" class=\"headerlink\" title=\"3. 第三范式 (3NF)\"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。消除传递依赖。</p>\n<h2 id=\"八、ER-图（以后再补充）\"><a href=\"#八、ER-图（以后再补充）\" class=\"headerlink\" title=\"八、ER 图（以后再补充）\"></a>八、ER 图（以后再补充）</h2>","excerpt":"<p>转载自：<a href=\"https://github.com/CyC2018/CS-Notes/tree/master\">https://github.com/CyC2018/CS-Notes/tree/master</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/476601594\">https://zhuanlan.zhihu.com/p/476601594</a></p>\n<p><a href=\"https://blog.csdn.net/Xupixel/article/details/120405501\">https://blog.csdn.net/Xupixel/article/details/120405501</a></p>\n<p><a href=\"https://www.hwpo.top/posts/d87f7e0c/index.html\">https://www.hwpo.top/posts/d87f7e0c/index.html</a></p>\n<p><a href=\"https://developer.aliyun.com/article/815625\">https://developer.aliyun.com/article/815625</a></p>\n<h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>","more":"<p><img src=\"/2024/03/19/database-system-principles/image-20240319220740283.png\"></p>\n<h4 id=\"1-原子性（Atomicity）\"><a href=\"#1-原子性（Atomicity）\" class=\"headerlink\" title=\"1. 原子性（Atomicity）\"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>\n<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>\n<h4 id=\"2-一致性（Consistency）\"><a href=\"#2-一致性（Consistency）\" class=\"headerlink\" title=\"2. 一致性（Consistency）\"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）</p>\n<h4 id=\"3-隔离性（Isolation）\"><a href=\"#3-隔离性（Isolation）\" class=\"headerlink\" title=\"3. 隔离性（Isolation）\"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>\n<h4 id=\"4-持久性（Durability）\"><a href=\"#4-持久性（Durability）\" class=\"headerlink\" title=\"4. 持久性（Durability）\"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>\n<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>\n<hr>\n<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>\n<ul>\n<li>只有满足一致性，事务的执行结果才是正确的。</li>\n<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>\n<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>\n<li>事务满足持久化是为了能应对系统崩溃的情况。</li>\n</ul>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220943892.png\"></p>\n<h3 id=\"AUTOCOMMIT\"><a href=\"#AUTOCOMMIT\" class=\"headerlink\" title=\"AUTOCOMMIT\"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>\n<h2 id=\"二、并发一致性问题\"><a href=\"#二、并发一致性问题\" class=\"headerlink\" title=\"二、并发一致性问题\"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。下图的例子不太能体现丢失修改，将 write 改为 add 就能很好地体现了。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221024695.png\"></p>\n<h3 id=\"读脏数据\"><a href=\"#读脏数据\" class=\"headerlink\" title=\"读脏数据\"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221039549.png\"></p>\n<h3 id=\"不可重复读（读已提交导致）\"><a href=\"#不可重复读（读已提交导致）\" class=\"headerlink\" title=\"不可重复读（读已提交导致）\"></a>不可重复读（读已提交导致）</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。这个图也不太恰当，应将 T1 的提交节点上移至 read A &#x3D; 20 之上。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221109092.png\"></p>\n<h3 id=\"幻影读\"><a href=\"#幻影读\" class=\"headerlink\" title=\"幻影读\"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221128098.png\"></p>\n<p>解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>\n<h2 id=\"三、封锁\"><a href=\"#三、封锁\" class=\"headerlink\" title=\"三、封锁\"></a>三、封锁</h2><h3 id=\"封锁粒度\"><a href=\"#封锁粒度\" class=\"headerlink\" title=\"封锁粒度\"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>\n<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>\n<h3 id=\"封锁类型\"><a href=\"#封锁类型\" class=\"headerlink\" title=\"封锁类型\"></a>封锁类型</h3><h4 id=\"1-读写锁\"><a href=\"#1-读写锁\" class=\"headerlink\" title=\"1. 读写锁\"></a>1. 读写锁</h4><ul>\n<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>\n<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>\n</ul>\n<p>有以下两个规定：</p>\n<ul>\n<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>\n</ul>\n<p>锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222609279.png\"></p>\n<h4 id=\"2-意向锁\"><a href=\"#2-意向锁\" class=\"headerlink\" title=\"2. 意向锁\"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>\n<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>\n<p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，IX&#x2F;IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>\n<ul>\n<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>\n<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>\n</ul>\n<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>\n<p>各种锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222621455.png\"></p>\n<h3 id=\"封锁协议\"><a href=\"#封锁协议\" class=\"headerlink\" title=\"封锁协议\"></a>封锁协议</h3><h4 id=\"1-三级封锁协议\"><a href=\"#1-三级封锁协议\" class=\"headerlink\" title=\"1. 三级封锁协议\"></a>1. 三级封锁协议</h4><p><strong>一级封锁协议</strong></p>\n<p>事务 T 要修改数据 A 时必须加<strong>X 锁</strong>，直到 <strong>T 结束</strong>才释放锁。</p>\n<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222801904.png\"></p>\n<p><strong>二级封锁协议</strong></p>\n<p>在一级的基础上，要求读取数据 A 时必须加 <strong>S 锁</strong>，<strong>读取完</strong>马上释放 S 锁。</p>\n<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222832886.png\"></p>\n<p><strong>三级封锁协议</strong></p>\n<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>\n<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222857283.png\"></p>\n<h4 id=\"2-两段锁协议\"><a href=\"#2-两段锁协议\" class=\"headerlink\" title=\"2. 两段锁协议\"></a>2. 两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>\n<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>\n<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>\n\n<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MySQL-隐式与显式锁定\"><a href=\"#MySQL-隐式与显式锁定\" class=\"headerlink\" title=\"MySQL 隐式与显式锁定\"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>\n<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ... LOCK In SHARE MODE;</span><br><span class=\"line\">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、隔离级别\"><a href=\"#四、隔离级别\" class=\"headerlink\" title=\"四、隔离级别\"></a>四、隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>\n<h3 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319223152453.png\"></p>\n<h2 id=\"五、多版本并发控制（暂时没见过）\"><a href=\"#五、多版本并发控制（暂时没见过）\" class=\"headerlink\" title=\"五、多版本并发控制（暂时没见过）\"></a>五、多版本并发控制（暂时没见过）</h2><h2 id=\"六、Next-Key-Locks（暂时没见过）\"><a href=\"#六、Next-Key-Locks（暂时没见过）\" class=\"headerlink\" title=\"六、Next-Key Locks（暂时没见过）\"></a>六、Next-Key Locks（暂时没见过）</h2><h2 id=\"七、关系数据库设计理论（以后补充完整）\"><a href=\"#七、关系数据库设计理论（以后补充完整）\" class=\"headerlink\" title=\"七、关系数据库设计理论（以后补充完整）\"></a>七、关系数据库设计理论（以后补充完整）</h2><h3 id=\"函数依赖\"><a href=\"#函数依赖\" class=\"headerlink\" title=\"函数依赖\"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>\n<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>\n<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>\n<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>\n<h4 id=\"1-第一范式-1NF\"><a href=\"#1-第一范式-1NF\" class=\"headerlink\" title=\"1. 第一范式 (1NF)\"></a>1. 第一范式 (1NF)</h4><p>属性不可分。满足原子性。</p>\n<h4 id=\"2-第二范式-2NF\"><a href=\"#2-第二范式-2NF\" class=\"headerlink\" title=\"2. 第二范式 (2NF)\"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。消除部分依赖。</p>\n<h4 id=\"3-第三范式-3NF\"><a href=\"#3-第三范式-3NF\" class=\"headerlink\" title=\"3. 第三范式 (3NF)\"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。消除传递依赖。</p>\n<h2 id=\"八、ER-图（以后再补充）\"><a href=\"#八、ER-图（以后再补充）\" class=\"headerlink\" title=\"八、ER 图（以后再补充）\"></a>八、ER 图（以后再补充）</h2>"},{"title":"what the fuck","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!--more-->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: what the fuck\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!--more-->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-03-20T08:24:23.966Z","updated":"2024-03-20T08:24:23.966Z","comments":1,"layout":"post","photos":[],"_id":"clu247pum0004jocggl03dnic","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<span id=\"more\"></span>\n\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>","more":"<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"sse316 hw1","date":"2024-03-19T15:02:31.000Z","toc":true,"_content":"\n郑泓东-21311570-第一次作业\n\n<!--more-->\n\n## 任务一\n\n![image-20240319110624835](hw1/image-20240319110624835.png)\n\n## 任务二\n\nhttp://47.113.146.19/2024/03/19/hw1/\n","source":"_posts/hw1.md","raw":"---\ntitle: sse316 hw1\ndate: 2024-03-19 23:02:31\ncategories:\n  - study\n  - cloud computing technology\ntags:\n  - homework\ntoc: true\n---\n\n郑泓东-21311570-第一次作业\n\n<!--more-->\n\n## 任务一\n\n![image-20240319110624835](hw1/image-20240319110624835.png)\n\n## 任务二\n\nhttp://47.113.146.19/2024/03/19/hw1/\n","slug":"hw1","published":1,"updated":"2024-03-22T03:38:58.809Z","comments":1,"layout":"post","photos":[],"_id":"clu247pun0005jocgfmgu6ova","content":"<p>郑泓东-21311570-第一次作业</p>\n<span id=\"more\"></span>\n\n<h2 id=\"任务一\"><a href=\"#任务一\" class=\"headerlink\" title=\"任务一\"></a>任务一</h2><p><img src=\"/2024/03/19/hw1/image-20240319110624835.png\"></p>\n<h2 id=\"任务二\"><a href=\"#任务二\" class=\"headerlink\" title=\"任务二\"></a>任务二</h2><p><a href=\"http://47.113.146.19/2024/03/19/hw1/\">http://47.113.146.19/2024/03/19/hw1/</a></p>\n","excerpt":"<p>郑泓东-21311570-第一次作业</p>","more":"<h2 id=\"任务一\"><a href=\"#任务一\" class=\"headerlink\" title=\"任务一\"></a>任务一</h2><p><img src=\"/2024/03/19/hw1/image-20240319110624835.png\"></p>\n<h2 id=\"任务二\"><a href=\"#任务二\" class=\"headerlink\" title=\"任务二\"></a>任务二</h2><p><a href=\"http://47.113.146.19/2024/03/19/hw1/\">http://47.113.146.19/2024/03/19/hw1/</a></p>"},{"title":"Golang 八股文","date":"2024-03-20T10:12:40.000Z","toc":true,"_content":"\n## Go 基础\n\n### init 和 main 函数相关特点\n\n所有 init 函数都在同⼀个 goroutine 内执行。\n\n所有 init 函数结束后才会执行 main.main 函数\n\n<!--more-->\n\n![image-20240320181645811](golang/image-20240320181645811.png)\n\n### Go 的数据结构的零值是什么?\n\n所有整型类型：0\n\n浮点类型：0.0\n\n布尔类型：false\n\n字符串类型：””\n\n指针、interface、切片（slice）、channel、map、function ：nil\n\nGo 的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。\n\n### byte 和 rune 有什么区别\n\nrune 和 byte 在 go 语言中都是字符类型，且都是别名类型\n\nbyte 型本质上是 uint8 类型的别名，代表了 ASCII 码的一个字符\n\nrune 型本质上是 int32 型的别名，代表一个 UTF-8 字符\n","source":"_posts/golang.md","raw":"---\ntitle: Golang 八股文\ndate: 2024-03-20 18:12:40\ncategories:\n  - work\n  - review\n  - programming language\ntags:\n  - go\n  - language\ntoc: true\n---\n\n## Go 基础\n\n### init 和 main 函数相关特点\n\n所有 init 函数都在同⼀个 goroutine 内执行。\n\n所有 init 函数结束后才会执行 main.main 函数\n\n<!--more-->\n\n![image-20240320181645811](golang/image-20240320181645811.png)\n\n### Go 的数据结构的零值是什么?\n\n所有整型类型：0\n\n浮点类型：0.0\n\n布尔类型：false\n\n字符串类型：””\n\n指针、interface、切片（slice）、channel、map、function ：nil\n\nGo 的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。\n\n### byte 和 rune 有什么区别\n\nrune 和 byte 在 go 语言中都是字符类型，且都是别名类型\n\nbyte 型本质上是 uint8 类型的别名，代表了 ASCII 码的一个字符\n\nrune 型本质上是 int32 型的别名，代表一个 UTF-8 字符\n","slug":"golang","published":1,"updated":"2024-03-22T03:36:11.685Z","comments":1,"layout":"post","photos":[],"_id":"clu247puo0006jocg6nk66mv2","content":"<h2 id=\"Go-基础\"><a href=\"#Go-基础\" class=\"headerlink\" title=\"Go 基础\"></a>Go 基础</h2><h3 id=\"init-和-main-函数相关特点\"><a href=\"#init-和-main-函数相关特点\" class=\"headerlink\" title=\"init 和 main 函数相关特点\"></a>init 和 main 函数相关特点</h3><p>所有 init 函数都在同⼀个 goroutine 内执行。</p>\n<p>所有 init 函数结束后才会执行 main.main 函数</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/2024/03/20/golang/image-20240320181645811.png\"></p>\n<h3 id=\"Go-的数据结构的零值是什么\"><a href=\"#Go-的数据结构的零值是什么\" class=\"headerlink\" title=\"Go 的数据结构的零值是什么?\"></a>Go 的数据结构的零值是什么?</h3><p>所有整型类型：0</p>\n<p>浮点类型：0.0</p>\n<p>布尔类型：false</p>\n<p>字符串类型：””</p>\n<p>指针、interface、切片（slice）、channel、map、function ：nil</p>\n<p>Go 的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</p>\n<h3 id=\"byte-和-rune-有什么区别\"><a href=\"#byte-和-rune-有什么区别\" class=\"headerlink\" title=\"byte 和 rune 有什么区别\"></a>byte 和 rune 有什么区别</h3><p>rune 和 byte 在 go 语言中都是字符类型，且都是别名类型</p>\n<p>byte 型本质上是 uint8 类型的别名，代表了 ASCII 码的一个字符</p>\n<p>rune 型本质上是 int32 型的别名，代表一个 UTF-8 字符</p>\n","excerpt":"<h2 id=\"Go-基础\"><a href=\"#Go-基础\" class=\"headerlink\" title=\"Go 基础\"></a>Go 基础</h2><h3 id=\"init-和-main-函数相关特点\"><a href=\"#init-和-main-函数相关特点\" class=\"headerlink\" title=\"init 和 main 函数相关特点\"></a>init 和 main 函数相关特点</h3><p>所有 init 函数都在同⼀个 goroutine 内执行。</p>\n<p>所有 init 函数结束后才会执行 main.main 函数</p>","more":"<p><img src=\"/2024/03/20/golang/image-20240320181645811.png\"></p>\n<h3 id=\"Go-的数据结构的零值是什么\"><a href=\"#Go-的数据结构的零值是什么\" class=\"headerlink\" title=\"Go 的数据结构的零值是什么?\"></a>Go 的数据结构的零值是什么?</h3><p>所有整型类型：0</p>\n<p>浮点类型：0.0</p>\n<p>布尔类型：false</p>\n<p>字符串类型：””</p>\n<p>指针、interface、切片（slice）、channel、map、function ：nil</p>\n<p>Go 的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</p>\n<h3 id=\"byte-和-rune-有什么区别\"><a href=\"#byte-和-rune-有什么区别\" class=\"headerlink\" title=\"byte 和 rune 有什么区别\"></a>byte 和 rune 有什么区别</h3><p>rune 和 byte 在 go 语言中都是字符类型，且都是别名类型</p>\n<p>byte 型本质上是 uint8 类型的别名，代表了 ASCII 码的一个字符</p>\n<p>rune 型本质上是 int32 型的别名，代表一个 UTF-8 字符</p>"},{"title":"美团后端开发一面","date":"2024-03-21T12:13:26.000Z","toc":true,"_content":"\n## 前情提要\n\n- 没有针对某个语言，较熟悉的 C++/python。\n- 项目都是使用 Go 编写：\n  - 二手交易网站\n  - IM 即时通信\n\n## 自我介绍\n\n<!--more-->\n\n不必多说。\n\n## 问题\n\n### 二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\n\n聊天。因为是二手交易，所以没有群聊。两张表，一张存储用户之间的联系，一张存储聊天记录。消息体有一个字段用于区分文字、表情、图片。\n\n### 图片怎么上传？\n\n两个项目不同的处理方式。二手交易网站项目中，将图片转为 blob 的形式存储在 MySQL。IM 即时通信，将图片存储到本地，再将图片的路径存储到 MySQL。\n\n### 数据库记录太多如何处理？肯定会很快变成慢查的。\n\n水平分片，将发送者字段和接收者字段拼接，做哈希映射，避免同一个联系中的聊天记录随机分到不同的片。\n\n### 有没有考虑聊天记录什么时候过期？\n\n没有。（面试官说这也是解决数据库聊天记录太多的方法）。\n\n将常用的查询字段，建索引，解决慢查问题。\n\n### 聊到索引，MySQL 有什么索引？\n\nB+树索引、哈希索引、全文索引、空间索引、覆盖索引。\n\n详细说了一下 B+树索引。\n\n### 还不够？主索引呢？\n\n（这个我不太了解）扯到了聚簇索引和非聚簇索引。在非聚簇索引中找到主键，再去聚簇索引中利用主键找到数据。\n\n### 隔离级别\n\n读未提交、读已提交、可重复读、串行化。\n\n### JWT 鉴权中间件的核心功能实现？\n\n只是调包，不了解底层的实现。\n\n### IM 即时通信如何做到消息不发错对象呢？\n\n实现一个 node 结构体，包含客户端 id，channel 用于传输信息，set 用于存储群聊。建立 map 映射。\n\n服务端为每个客户端开启两个协程，服务端接收的协程很简单，发送的写成需要解析消息体。IM 中的消息体多了一个字段 cmd，用于区分是否为私聊或群聊。如果 cmd 为私聊，直接将消息输发送对象的 channel；如果为群聊，需要遍历 map，查找发送对象是否位于每个节点的 set 中，如果存在，将消息输入该客户端的 channel。\n\n### 为什么用事务添加好友？\n\n防止一方丢失聊天对象。\n\n### 说一下事务的特性\n\nACID。\n\n原子性：（真该死啊，突然想不起来）事务的操作要么全部提交成功，要么全部失败回滚。\n\n一致性：事务执行前后保持一致性的状态。\n\n隔离性：一个事务在提交之前，对其它事务是不可见的。\n\n持久性：事务一旦提交，修改会永远保存在数据库中。发生崩溃可以用重做日志恢复。\n\n### 你有了解过微信的底层实现吗？\n\n没有。\n\n### 单机可支持数百人聊天，意思是 IM 上线了吗？\n\n没有，最近在服务器部署个人博客。\n\n### InnoDB 的索引和 MyISAM 有什么区别？\n\n| 特性             | InnoDB                                                                                                                                                    | MyISAM                                                                       |\n| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| 索引类型         | 支持全文索引（MySQL 5.6 及以后版本），支持外键和外键约束                                                                                                  | 支持全文索引，不支持外键和外键约束                                           |\n| 索引结构         | 使用聚簇索引，数据按照主键顺序存储。对于主键查询，InnoDB 只需要查找一次（。对于非主键查询，需要在辅助索引上查找到主键，再通过主键在聚簇索引上查找到数据。 | 使用非聚簇索引，数据文件和索引文件是分开的。索引文件只保存了数据记录的地址。 |\n| 并发性能         | 支持事务和行级锁定，适合高并发写入                                                                                                                        | 只支持表级锁定，可能在高并发写入场景下成为性能瓶颈                           |\n| 数据完整性和恢复 | 支持事务，可以进行崩溃后的恢复，支持外键和参照完整性                                                                                                      | 不支持事务和崩溃后的恢复，系统崩溃后可能需要手动干预修复数据                 |\n\n### http 三次握手\n\n![image-20240321212159961](meituan-interview/image-20240321212159961.png)\n\n### 四次挥手\n\n![image-20240321212210047](meituan-interview/image-20240321212210047.png)\n\n## 手撕算法 leetcode 形式\n\n### 第 k 大数，时间复杂度为 O(nlogn)\n\n![image-20240321213127087](meituan-interview/image-20240321213127087.png)\n\n#### 有想过排序的方法吗？\n\n想过，直接调用 sort，但是时间复杂度是 O(nlong+k)。\n\n查了一下，好像利用快排的思路可以做，在快排过程中，关注点是 index 左边全部小于，右边全部大于，所以，找到 index 为 k/n-k 时的数即可。\n\n### 已知前序遍历和中序遍历，构造二叉树\n\n分治思想，递归构建。\n\n![image-20240321213357032](meituan-interview/image-20240321213357032.png)\n\n## 聊天环节\n\n### 看到用 c++和 python 解题，学习 python 是兴趣吗？\n\n## 总结\n\n- 要深入了解索引，唯一索引和聚簇索引不同。\n- 只是调包 JWT，要了解底层实现。\n","source":"_posts/meituan-interview.md","raw":"---\ntitle: 美团后端开发一面\ndate: 2024-03-21 20:13:26\ncategories:\n  - work\n  - interview\ntags:\n  - work\n  - interview\n  - backend\ntoc: true\n---\n\n## 前情提要\n\n- 没有针对某个语言，较熟悉的 C++/python。\n- 项目都是使用 Go 编写：\n  - 二手交易网站\n  - IM 即时通信\n\n## 自我介绍\n\n<!--more-->\n\n不必多说。\n\n## 问题\n\n### 二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\n\n聊天。因为是二手交易，所以没有群聊。两张表，一张存储用户之间的联系，一张存储聊天记录。消息体有一个字段用于区分文字、表情、图片。\n\n### 图片怎么上传？\n\n两个项目不同的处理方式。二手交易网站项目中，将图片转为 blob 的形式存储在 MySQL。IM 即时通信，将图片存储到本地，再将图片的路径存储到 MySQL。\n\n### 数据库记录太多如何处理？肯定会很快变成慢查的。\n\n水平分片，将发送者字段和接收者字段拼接，做哈希映射，避免同一个联系中的聊天记录随机分到不同的片。\n\n### 有没有考虑聊天记录什么时候过期？\n\n没有。（面试官说这也是解决数据库聊天记录太多的方法）。\n\n将常用的查询字段，建索引，解决慢查问题。\n\n### 聊到索引，MySQL 有什么索引？\n\nB+树索引、哈希索引、全文索引、空间索引、覆盖索引。\n\n详细说了一下 B+树索引。\n\n### 还不够？主索引呢？\n\n（这个我不太了解）扯到了聚簇索引和非聚簇索引。在非聚簇索引中找到主键，再去聚簇索引中利用主键找到数据。\n\n### 隔离级别\n\n读未提交、读已提交、可重复读、串行化。\n\n### JWT 鉴权中间件的核心功能实现？\n\n只是调包，不了解底层的实现。\n\n### IM 即时通信如何做到消息不发错对象呢？\n\n实现一个 node 结构体，包含客户端 id，channel 用于传输信息，set 用于存储群聊。建立 map 映射。\n\n服务端为每个客户端开启两个协程，服务端接收的协程很简单，发送的写成需要解析消息体。IM 中的消息体多了一个字段 cmd，用于区分是否为私聊或群聊。如果 cmd 为私聊，直接将消息输发送对象的 channel；如果为群聊，需要遍历 map，查找发送对象是否位于每个节点的 set 中，如果存在，将消息输入该客户端的 channel。\n\n### 为什么用事务添加好友？\n\n防止一方丢失聊天对象。\n\n### 说一下事务的特性\n\nACID。\n\n原子性：（真该死啊，突然想不起来）事务的操作要么全部提交成功，要么全部失败回滚。\n\n一致性：事务执行前后保持一致性的状态。\n\n隔离性：一个事务在提交之前，对其它事务是不可见的。\n\n持久性：事务一旦提交，修改会永远保存在数据库中。发生崩溃可以用重做日志恢复。\n\n### 你有了解过微信的底层实现吗？\n\n没有。\n\n### 单机可支持数百人聊天，意思是 IM 上线了吗？\n\n没有，最近在服务器部署个人博客。\n\n### InnoDB 的索引和 MyISAM 有什么区别？\n\n| 特性             | InnoDB                                                                                                                                                    | MyISAM                                                                       |\n| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| 索引类型         | 支持全文索引（MySQL 5.6 及以后版本），支持外键和外键约束                                                                                                  | 支持全文索引，不支持外键和外键约束                                           |\n| 索引结构         | 使用聚簇索引，数据按照主键顺序存储。对于主键查询，InnoDB 只需要查找一次（。对于非主键查询，需要在辅助索引上查找到主键，再通过主键在聚簇索引上查找到数据。 | 使用非聚簇索引，数据文件和索引文件是分开的。索引文件只保存了数据记录的地址。 |\n| 并发性能         | 支持事务和行级锁定，适合高并发写入                                                                                                                        | 只支持表级锁定，可能在高并发写入场景下成为性能瓶颈                           |\n| 数据完整性和恢复 | 支持事务，可以进行崩溃后的恢复，支持外键和参照完整性                                                                                                      | 不支持事务和崩溃后的恢复，系统崩溃后可能需要手动干预修复数据                 |\n\n### http 三次握手\n\n![image-20240321212159961](meituan-interview/image-20240321212159961.png)\n\n### 四次挥手\n\n![image-20240321212210047](meituan-interview/image-20240321212210047.png)\n\n## 手撕算法 leetcode 形式\n\n### 第 k 大数，时间复杂度为 O(nlogn)\n\n![image-20240321213127087](meituan-interview/image-20240321213127087.png)\n\n#### 有想过排序的方法吗？\n\n想过，直接调用 sort，但是时间复杂度是 O(nlong+k)。\n\n查了一下，好像利用快排的思路可以做，在快排过程中，关注点是 index 左边全部小于，右边全部大于，所以，找到 index 为 k/n-k 时的数即可。\n\n### 已知前序遍历和中序遍历，构造二叉树\n\n分治思想，递归构建。\n\n![image-20240321213357032](meituan-interview/image-20240321213357032.png)\n\n## 聊天环节\n\n### 看到用 c++和 python 解题，学习 python 是兴趣吗？\n\n## 总结\n\n- 要深入了解索引，唯一索引和聚簇索引不同。\n- 只是调包 JWT，要了解底层实现。\n","slug":"meituan-interview","published":1,"updated":"2024-03-22T03:36:11.686Z","comments":1,"layout":"post","photos":[],"_id":"clu247pw40012jocgc15jdmdg","content":"<h2 id=\"前情提要\"><a href=\"#前情提要\" class=\"headerlink\" title=\"前情提要\"></a>前情提要</h2><ul>\n<li>没有针对某个语言，较熟悉的 C++&#x2F;python。</li>\n<li>项目都是使用 Go 编写：<ul>\n<li>二手交易网站</li>\n<li>IM 即时通信</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2><span id=\"more\"></span>\n\n<p>不必多说。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\"><a href=\"#二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\" class=\"headerlink\" title=\"二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\"></a>二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？</h3><p>聊天。因为是二手交易，所以没有群聊。两张表，一张存储用户之间的联系，一张存储聊天记录。消息体有一个字段用于区分文字、表情、图片。</p>\n<h3 id=\"图片怎么上传？\"><a href=\"#图片怎么上传？\" class=\"headerlink\" title=\"图片怎么上传？\"></a>图片怎么上传？</h3><p>两个项目不同的处理方式。二手交易网站项目中，将图片转为 blob 的形式存储在 MySQL。IM 即时通信，将图片存储到本地，再将图片的路径存储到 MySQL。</p>\n<h3 id=\"数据库记录太多如何处理？肯定会很快变成慢查的。\"><a href=\"#数据库记录太多如何处理？肯定会很快变成慢查的。\" class=\"headerlink\" title=\"数据库记录太多如何处理？肯定会很快变成慢查的。\"></a>数据库记录太多如何处理？肯定会很快变成慢查的。</h3><p>水平分片，将发送者字段和接收者字段拼接，做哈希映射，避免同一个联系中的聊天记录随机分到不同的片。</p>\n<h3 id=\"有没有考虑聊天记录什么时候过期？\"><a href=\"#有没有考虑聊天记录什么时候过期？\" class=\"headerlink\" title=\"有没有考虑聊天记录什么时候过期？\"></a>有没有考虑聊天记录什么时候过期？</h3><p>没有。（面试官说这也是解决数据库聊天记录太多的方法）。</p>\n<p>将常用的查询字段，建索引，解决慢查问题。</p>\n<h3 id=\"聊到索引，MySQL-有什么索引？\"><a href=\"#聊到索引，MySQL-有什么索引？\" class=\"headerlink\" title=\"聊到索引，MySQL 有什么索引？\"></a>聊到索引，MySQL 有什么索引？</h3><p>B+树索引、哈希索引、全文索引、空间索引、覆盖索引。</p>\n<p>详细说了一下 B+树索引。</p>\n<h3 id=\"还不够？主索引呢？\"><a href=\"#还不够？主索引呢？\" class=\"headerlink\" title=\"还不够？主索引呢？\"></a>还不够？主索引呢？</h3><p>（这个我不太了解）扯到了聚簇索引和非聚簇索引。在非聚簇索引中找到主键，再去聚簇索引中利用主键找到数据。</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>读未提交、读已提交、可重复读、串行化。</p>\n<h3 id=\"JWT-鉴权中间件的核心功能实现？\"><a href=\"#JWT-鉴权中间件的核心功能实现？\" class=\"headerlink\" title=\"JWT 鉴权中间件的核心功能实现？\"></a>JWT 鉴权中间件的核心功能实现？</h3><p>只是调包，不了解底层的实现。</p>\n<h3 id=\"IM-即时通信如何做到消息不发错对象呢？\"><a href=\"#IM-即时通信如何做到消息不发错对象呢？\" class=\"headerlink\" title=\"IM 即时通信如何做到消息不发错对象呢？\"></a>IM 即时通信如何做到消息不发错对象呢？</h3><p>实现一个 node 结构体，包含客户端 id，channel 用于传输信息，set 用于存储群聊。建立 map 映射。</p>\n<p>服务端为每个客户端开启两个协程，服务端接收的协程很简单，发送的写成需要解析消息体。IM 中的消息体多了一个字段 cmd，用于区分是否为私聊或群聊。如果 cmd 为私聊，直接将消息输发送对象的 channel；如果为群聊，需要遍历 map，查找发送对象是否位于每个节点的 set 中，如果存在，将消息输入该客户端的 channel。</p>\n<h3 id=\"为什么用事务添加好友？\"><a href=\"#为什么用事务添加好友？\" class=\"headerlink\" title=\"为什么用事务添加好友？\"></a>为什么用事务添加好友？</h3><p>防止一方丢失聊天对象。</p>\n<h3 id=\"说一下事务的特性\"><a href=\"#说一下事务的特性\" class=\"headerlink\" title=\"说一下事务的特性\"></a>说一下事务的特性</h3><p>ACID。</p>\n<p>原子性：（真该死啊，突然想不起来）事务的操作要么全部提交成功，要么全部失败回滚。</p>\n<p>一致性：事务执行前后保持一致性的状态。</p>\n<p>隔离性：一个事务在提交之前，对其它事务是不可见的。</p>\n<p>持久性：事务一旦提交，修改会永远保存在数据库中。发生崩溃可以用重做日志恢复。</p>\n<h3 id=\"你有了解过微信的底层实现吗？\"><a href=\"#你有了解过微信的底层实现吗？\" class=\"headerlink\" title=\"你有了解过微信的底层实现吗？\"></a>你有了解过微信的底层实现吗？</h3><p>没有。</p>\n<h3 id=\"单机可支持数百人聊天，意思是-IM-上线了吗？\"><a href=\"#单机可支持数百人聊天，意思是-IM-上线了吗？\" class=\"headerlink\" title=\"单机可支持数百人聊天，意思是 IM 上线了吗？\"></a>单机可支持数百人聊天，意思是 IM 上线了吗？</h3><p>没有，最近在服务器部署个人博客。</p>\n<h3 id=\"InnoDB-的索引和-MyISAM-有什么区别？\"><a href=\"#InnoDB-的索引和-MyISAM-有什么区别？\" class=\"headerlink\" title=\"InnoDB 的索引和 MyISAM 有什么区别？\"></a>InnoDB 的索引和 MyISAM 有什么区别？</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>索引类型</td>\n<td>支持全文索引（MySQL 5.6 及以后版本），支持外键和外键约束</td>\n<td>支持全文索引，不支持外键和外键约束</td>\n</tr>\n<tr>\n<td>索引结构</td>\n<td>使用聚簇索引，数据按照主键顺序存储。对于主键查询，InnoDB 只需要查找一次（。对于非主键查询，需要在辅助索引上查找到主键，再通过主键在聚簇索引上查找到数据。</td>\n<td>使用非聚簇索引，数据文件和索引文件是分开的。索引文件只保存了数据记录的地址。</td>\n</tr>\n<tr>\n<td>并发性能</td>\n<td>支持事务和行级锁定，适合高并发写入</td>\n<td>只支持表级锁定，可能在高并发写入场景下成为性能瓶颈</td>\n</tr>\n<tr>\n<td>数据完整性和恢复</td>\n<td>支持事务，可以进行崩溃后的恢复，支持外键和参照完整性</td>\n<td>不支持事务和崩溃后的恢复，系统崩溃后可能需要手动干预修复数据</td>\n</tr>\n</tbody></table>\n<h3 id=\"http-三次握手\"><a href=\"#http-三次握手\" class=\"headerlink\" title=\"http 三次握手\"></a>http 三次握手</h3><p><img src=\"/2024/03/21/meituan-interview/image-20240321212159961.png\"></p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p><img src=\"/2024/03/21/meituan-interview/image-20240321212210047.png\"></p>\n<h2 id=\"手撕算法-leetcode-形式\"><a href=\"#手撕算法-leetcode-形式\" class=\"headerlink\" title=\"手撕算法 leetcode 形式\"></a>手撕算法 leetcode 形式</h2><h3 id=\"第-k-大数，时间复杂度为-O-nlogn\"><a href=\"#第-k-大数，时间复杂度为-O-nlogn\" class=\"headerlink\" title=\"第 k 大数，时间复杂度为 O(nlogn)\"></a>第 k 大数，时间复杂度为 O(nlogn)</h3><p><img src=\"/2024/03/21/meituan-interview/image-20240321213127087.png\"></p>\n<h4 id=\"有想过排序的方法吗？\"><a href=\"#有想过排序的方法吗？\" class=\"headerlink\" title=\"有想过排序的方法吗？\"></a>有想过排序的方法吗？</h4><p>想过，直接调用 sort，但是时间复杂度是 O(nlong+k)。</p>\n<p>查了一下，好像利用快排的思路可以做，在快排过程中，关注点是 index 左边全部小于，右边全部大于，所以，找到 index 为 k&#x2F;n-k 时的数即可。</p>\n<h3 id=\"已知前序遍历和中序遍历，构造二叉树\"><a href=\"#已知前序遍历和中序遍历，构造二叉树\" class=\"headerlink\" title=\"已知前序遍历和中序遍历，构造二叉树\"></a>已知前序遍历和中序遍历，构造二叉树</h3><p>分治思想，递归构建。</p>\n<p><img src=\"/2024/03/21/meituan-interview/image-20240321213357032.png\"></p>\n<h2 id=\"聊天环节\"><a href=\"#聊天环节\" class=\"headerlink\" title=\"聊天环节\"></a>聊天环节</h2><h3 id=\"看到用-c-和-python-解题，学习-python-是兴趣吗？\"><a href=\"#看到用-c-和-python-解题，学习-python-是兴趣吗？\" class=\"headerlink\" title=\"看到用 c++和 python 解题，学习 python 是兴趣吗？\"></a>看到用 c++和 python 解题，学习 python 是兴趣吗？</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>要深入了解索引，唯一索引和聚簇索引不同。</li>\n<li>只是调包 JWT，要了解底层实现。</li>\n</ul>\n","excerpt":"<h2 id=\"前情提要\"><a href=\"#前情提要\" class=\"headerlink\" title=\"前情提要\"></a>前情提要</h2><ul>\n<li>没有针对某个语言，较熟悉的 C++&#x2F;python。</li>\n<li>项目都是使用 Go 编写：<ul>\n<li>二手交易网站</li>\n<li>IM 即时通信</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2>","more":"<p>不必多说。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\"><a href=\"#二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\" class=\"headerlink\" title=\"二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？\"></a>二手交易网站中职责有数据库模型的设计与实现，聊天相关的数据库如何设计？</h3><p>聊天。因为是二手交易，所以没有群聊。两张表，一张存储用户之间的联系，一张存储聊天记录。消息体有一个字段用于区分文字、表情、图片。</p>\n<h3 id=\"图片怎么上传？\"><a href=\"#图片怎么上传？\" class=\"headerlink\" title=\"图片怎么上传？\"></a>图片怎么上传？</h3><p>两个项目不同的处理方式。二手交易网站项目中，将图片转为 blob 的形式存储在 MySQL。IM 即时通信，将图片存储到本地，再将图片的路径存储到 MySQL。</p>\n<h3 id=\"数据库记录太多如何处理？肯定会很快变成慢查的。\"><a href=\"#数据库记录太多如何处理？肯定会很快变成慢查的。\" class=\"headerlink\" title=\"数据库记录太多如何处理？肯定会很快变成慢查的。\"></a>数据库记录太多如何处理？肯定会很快变成慢查的。</h3><p>水平分片，将发送者字段和接收者字段拼接，做哈希映射，避免同一个联系中的聊天记录随机分到不同的片。</p>\n<h3 id=\"有没有考虑聊天记录什么时候过期？\"><a href=\"#有没有考虑聊天记录什么时候过期？\" class=\"headerlink\" title=\"有没有考虑聊天记录什么时候过期？\"></a>有没有考虑聊天记录什么时候过期？</h3><p>没有。（面试官说这也是解决数据库聊天记录太多的方法）。</p>\n<p>将常用的查询字段，建索引，解决慢查问题。</p>\n<h3 id=\"聊到索引，MySQL-有什么索引？\"><a href=\"#聊到索引，MySQL-有什么索引？\" class=\"headerlink\" title=\"聊到索引，MySQL 有什么索引？\"></a>聊到索引，MySQL 有什么索引？</h3><p>B+树索引、哈希索引、全文索引、空间索引、覆盖索引。</p>\n<p>详细说了一下 B+树索引。</p>\n<h3 id=\"还不够？主索引呢？\"><a href=\"#还不够？主索引呢？\" class=\"headerlink\" title=\"还不够？主索引呢？\"></a>还不够？主索引呢？</h3><p>（这个我不太了解）扯到了聚簇索引和非聚簇索引。在非聚簇索引中找到主键，再去聚簇索引中利用主键找到数据。</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>读未提交、读已提交、可重复读、串行化。</p>\n<h3 id=\"JWT-鉴权中间件的核心功能实现？\"><a href=\"#JWT-鉴权中间件的核心功能实现？\" class=\"headerlink\" title=\"JWT 鉴权中间件的核心功能实现？\"></a>JWT 鉴权中间件的核心功能实现？</h3><p>只是调包，不了解底层的实现。</p>\n<h3 id=\"IM-即时通信如何做到消息不发错对象呢？\"><a href=\"#IM-即时通信如何做到消息不发错对象呢？\" class=\"headerlink\" title=\"IM 即时通信如何做到消息不发错对象呢？\"></a>IM 即时通信如何做到消息不发错对象呢？</h3><p>实现一个 node 结构体，包含客户端 id，channel 用于传输信息，set 用于存储群聊。建立 map 映射。</p>\n<p>服务端为每个客户端开启两个协程，服务端接收的协程很简单，发送的写成需要解析消息体。IM 中的消息体多了一个字段 cmd，用于区分是否为私聊或群聊。如果 cmd 为私聊，直接将消息输发送对象的 channel；如果为群聊，需要遍历 map，查找发送对象是否位于每个节点的 set 中，如果存在，将消息输入该客户端的 channel。</p>\n<h3 id=\"为什么用事务添加好友？\"><a href=\"#为什么用事务添加好友？\" class=\"headerlink\" title=\"为什么用事务添加好友？\"></a>为什么用事务添加好友？</h3><p>防止一方丢失聊天对象。</p>\n<h3 id=\"说一下事务的特性\"><a href=\"#说一下事务的特性\" class=\"headerlink\" title=\"说一下事务的特性\"></a>说一下事务的特性</h3><p>ACID。</p>\n<p>原子性：（真该死啊，突然想不起来）事务的操作要么全部提交成功，要么全部失败回滚。</p>\n<p>一致性：事务执行前后保持一致性的状态。</p>\n<p>隔离性：一个事务在提交之前，对其它事务是不可见的。</p>\n<p>持久性：事务一旦提交，修改会永远保存在数据库中。发生崩溃可以用重做日志恢复。</p>\n<h3 id=\"你有了解过微信的底层实现吗？\"><a href=\"#你有了解过微信的底层实现吗？\" class=\"headerlink\" title=\"你有了解过微信的底层实现吗？\"></a>你有了解过微信的底层实现吗？</h3><p>没有。</p>\n<h3 id=\"单机可支持数百人聊天，意思是-IM-上线了吗？\"><a href=\"#单机可支持数百人聊天，意思是-IM-上线了吗？\" class=\"headerlink\" title=\"单机可支持数百人聊天，意思是 IM 上线了吗？\"></a>单机可支持数百人聊天，意思是 IM 上线了吗？</h3><p>没有，最近在服务器部署个人博客。</p>\n<h3 id=\"InnoDB-的索引和-MyISAM-有什么区别？\"><a href=\"#InnoDB-的索引和-MyISAM-有什么区别？\" class=\"headerlink\" title=\"InnoDB 的索引和 MyISAM 有什么区别？\"></a>InnoDB 的索引和 MyISAM 有什么区别？</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>索引类型</td>\n<td>支持全文索引（MySQL 5.6 及以后版本），支持外键和外键约束</td>\n<td>支持全文索引，不支持外键和外键约束</td>\n</tr>\n<tr>\n<td>索引结构</td>\n<td>使用聚簇索引，数据按照主键顺序存储。对于主键查询，InnoDB 只需要查找一次（。对于非主键查询，需要在辅助索引上查找到主键，再通过主键在聚簇索引上查找到数据。</td>\n<td>使用非聚簇索引，数据文件和索引文件是分开的。索引文件只保存了数据记录的地址。</td>\n</tr>\n<tr>\n<td>并发性能</td>\n<td>支持事务和行级锁定，适合高并发写入</td>\n<td>只支持表级锁定，可能在高并发写入场景下成为性能瓶颈</td>\n</tr>\n<tr>\n<td>数据完整性和恢复</td>\n<td>支持事务，可以进行崩溃后的恢复，支持外键和参照完整性</td>\n<td>不支持事务和崩溃后的恢复，系统崩溃后可能需要手动干预修复数据</td>\n</tr>\n</tbody></table>\n<h3 id=\"http-三次握手\"><a href=\"#http-三次握手\" class=\"headerlink\" title=\"http 三次握手\"></a>http 三次握手</h3><p><img src=\"/2024/03/21/meituan-interview/image-20240321212159961.png\"></p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p><img src=\"/2024/03/21/meituan-interview/image-20240321212210047.png\"></p>\n<h2 id=\"手撕算法-leetcode-形式\"><a href=\"#手撕算法-leetcode-形式\" class=\"headerlink\" title=\"手撕算法 leetcode 形式\"></a>手撕算法 leetcode 形式</h2><h3 id=\"第-k-大数，时间复杂度为-O-nlogn\"><a href=\"#第-k-大数，时间复杂度为-O-nlogn\" class=\"headerlink\" title=\"第 k 大数，时间复杂度为 O(nlogn)\"></a>第 k 大数，时间复杂度为 O(nlogn)</h3><p><img src=\"/2024/03/21/meituan-interview/image-20240321213127087.png\"></p>\n<h4 id=\"有想过排序的方法吗？\"><a href=\"#有想过排序的方法吗？\" class=\"headerlink\" title=\"有想过排序的方法吗？\"></a>有想过排序的方法吗？</h4><p>想过，直接调用 sort，但是时间复杂度是 O(nlong+k)。</p>\n<p>查了一下，好像利用快排的思路可以做，在快排过程中，关注点是 index 左边全部小于，右边全部大于，所以，找到 index 为 k&#x2F;n-k 时的数即可。</p>\n<h3 id=\"已知前序遍历和中序遍历，构造二叉树\"><a href=\"#已知前序遍历和中序遍历，构造二叉树\" class=\"headerlink\" title=\"已知前序遍历和中序遍历，构造二叉树\"></a>已知前序遍历和中序遍历，构造二叉树</h3><p>分治思想，递归构建。</p>\n<p><img src=\"/2024/03/21/meituan-interview/image-20240321213357032.png\"></p>\n<h2 id=\"聊天环节\"><a href=\"#聊天环节\" class=\"headerlink\" title=\"聊天环节\"></a>聊天环节</h2><h3 id=\"看到用-c-和-python-解题，学习-python-是兴趣吗？\"><a href=\"#看到用-c-和-python-解题，学习-python-是兴趣吗？\" class=\"headerlink\" title=\"看到用 c++和 python 解题，学习 python 是兴趣吗？\"></a>看到用 c++和 python 解题，学习 python 是兴趣吗？</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>要深入了解索引，唯一索引和聚簇索引不同。</li>\n<li>只是调包 JWT，要了解底层实现。</li>\n</ul>"},{"title":"MySQL","date":"2024-03-19T15:02:31.000Z","toc":true,"_content":"\n## 一、索引\n\n### B+ Tree 原理\n\n#### 1. 数据结构\n\nB Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是 B Tree 的数据不只是存放在叶子节点。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n<!--more-->\n\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n#### 2. 操作\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。\n\n#### 3. 与红黑树的比较\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为 B+树访问磁盘数据具有更高的性能。\n\n（一）B+ 树有更低的树高\n\n平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。\n\n（二）磁盘访问原理\n\n一次 I/O 能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n\n寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。\n\n（三）磁盘预读特性\n\n能预先载入相邻块：而块之间的数据的 key 又有顺序关系：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n### MySQL 索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\n#### 1. B+ Tree 索引\n\n是大多数 MySQL 存储引擎的默认索引类型。\n\n查找速度快：只需要对树进行搜索。\n\n可用于排序和分组：B+ Tree 的有序性。\n\n适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\n\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。\n\n主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n![image-20240319231655495](mysql/image-20240319231655495.png)\n\n辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n![image-20240319231743225](mysql/image-20240319231743225.png)\n\n#### 2. 哈希索引\n\n哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n\n- 无法用于排序与分组；\n- 只支持精确查找，无法用于部分查找和范围查找。\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n#### 3. 全文索引（没见过，韩了）\n\nInnoDB 和 MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n\n查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n\n全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\n\n#### 4. 空间数据索引（没见过，韩了）\n\nMyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n\n必须使用 GIS 相关的函数来维护数据。\n\n### 索引优化\n\n#### 1. 独立的列\n\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n\n例如下面的查询不能使用 actor_id 列的索引：\n\n```mysql\nSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n```\n\n#### 2. 多列索引\n\n在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\n\n```mysql\nSELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id = 1 AND film_id = 1;\n```\n\n#### 3. 索引列的顺序\n\n让选择性最强的索引列放在前面。\n\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\n```mysql\nSELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n```\n\n```powershell\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049\n```\n\n#### 4. 前缀索引\n\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n\n前缀长度的选取需要根据索引选择性来确定。\n\n#### 5. 覆盖索引\n\n创建包含所有需要查询的字段的索引。\n\n具有以下优点：\n\n- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n### 索引的优点\n\n- 减少服务器扫描的行数\n- 帮助服务器避免排序和分组，以及避免创建临时表。\n- 将随机 I/O 变为顺序 I/O（B+ Tree 特性）。\n\n### 索引的使用条件\n\n1. 跟快排差不多，数据量小的时候反而不如暴力。\n   - 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n   - 对于中到大型的表，索引就非常有效；\n   - 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n2. 频繁地查询操作。尤其是查询的列是固定的，这些列就是索引的好候选。\n3. 排序和分组操作。如果一个查询包含 `ORDER BY` 或 `GROUP BY` 子句，那么在相关列上创建索引可以提高查询效率。因为 B+树索引的 key 有序。\n4. 关联查询。如果关联的列上有索引，那么查询效率会更高。\n5. 唯一性约束。在需要强制唯一性约束的列（例如，用户的电子邮件地址或用户名）上创建唯一索引，可以确保数据的唯一性。\n6. 频繁的更新和插入操作。在经常需要更新的列或者插入新记录的表上创建索引，可以加速这些操作。\n\n### 索引失效的情况\n\n1. 使用非等值查询。（例如使用 `<>`、`!=`、`<`、`<=`、`>`、`>=`）或 `LIKE` 查询时，如果通配符 `%` 在前面，那么索引就无法使用。\n2. 使用函数或表达式。（例如 `WHERE DATE(column) = '2022-01-01'` 或 `WHERE column + 1 = 10`）时，索引无法使用。\n3. 数据类型不匹配。例如，如果索引列是字符串类型，但在查询条件中使用了数字，那么索引可能无法使用。\n4. 不使用索引的列作为查询条件。\n5. 索引列包含 NULL 值。\n6. 使用`or`连接条件。如果这些条件并不都使用索引列，索引就无法使用。\n7. 数据量小，全表扫描更快。\n\n## 二、查询性能优化\n\n### 使用 Explain 进行分析\n\nExplain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。\n\n比较重要的字段有：\n\n- select_type : 查询类型，有简单查询、联合查询、子查询等\n- key : 使用的索引\n- rows : 扫描的行数\n\n### 优化数据访问\n\n#### 1. 减少请求的数据量\n\n- 只返回必要的列：最好不要使用 SELECT \\* 语句。\n- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。\n- **缓存**重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。\n\n#### 2. 减少服务器端扫描的行数\n\n索引覆盖查询。\n\n### 重构查询方式\n\n#### 1. 切分大查询\n\n将大查询切分成多个小查询。\n\n一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。\n\n```mysql\nDELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);\n```\n\n```c++\nrows_affected = 0\ndo {\n    rows_affected = do_query(\n    \"DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\")\n} while rows_affected > 0\n```\n\n#### 2. 分解大连接查询\n\n将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：\n\n- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。\n- 减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。\n- 减少锁竞争。\n- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。\n- 查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。\n\n```mysql\nSELECT * FROM tag\nJOIN tag_post ON tag_post.tag_id=tag.id\nJOIN post ON tag_post.post_id=post.id\nWHERE tag.tag='mysql';\n```\n\n```mysql\nSELECT * FROM tag WHERE tag='mysql';\nSELECT * FROM tag_post WHERE tag_id=1234;\nSELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);\n```\n\n## 三、存储引擎\n\n### InnoDB\n\n是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n\n实现了四个标准的隔离级别，默认级别是可重复读。\n\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n","source":"_posts/mysql.md","raw":"---\ntitle: MySQL\ndate: 2024-03-19 23:02:31\ncategories:\n  - work\n  - review\n  - database systems\ntags:\n  - database\n  - mysql\ntoc: true\n---\n\n## 一、索引\n\n### B+ Tree 原理\n\n#### 1. 数据结构\n\nB Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是 B Tree 的数据不只是存放在叶子节点。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n<!--more-->\n\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n#### 2. 操作\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。\n\n#### 3. 与红黑树的比较\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为 B+树访问磁盘数据具有更高的性能。\n\n（一）B+ 树有更低的树高\n\n平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。\n\n（二）磁盘访问原理\n\n一次 I/O 能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n\n寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。\n\n（三）磁盘预读特性\n\n能预先载入相邻块：而块之间的数据的 key 又有顺序关系：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n### MySQL 索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\n#### 1. B+ Tree 索引\n\n是大多数 MySQL 存储引擎的默认索引类型。\n\n查找速度快：只需要对树进行搜索。\n\n可用于排序和分组：B+ Tree 的有序性。\n\n适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\n\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。\n\n主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n![image-20240319231655495](mysql/image-20240319231655495.png)\n\n辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n![image-20240319231743225](mysql/image-20240319231743225.png)\n\n#### 2. 哈希索引\n\n哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n\n- 无法用于排序与分组；\n- 只支持精确查找，无法用于部分查找和范围查找。\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n#### 3. 全文索引（没见过，韩了）\n\nInnoDB 和 MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n\n查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n\n全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\n\n#### 4. 空间数据索引（没见过，韩了）\n\nMyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n\n必须使用 GIS 相关的函数来维护数据。\n\n### 索引优化\n\n#### 1. 独立的列\n\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n\n例如下面的查询不能使用 actor_id 列的索引：\n\n```mysql\nSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n```\n\n#### 2. 多列索引\n\n在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\n\n```mysql\nSELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id = 1 AND film_id = 1;\n```\n\n#### 3. 索引列的顺序\n\n让选择性最强的索引列放在前面。\n\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\n```mysql\nSELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n```\n\n```powershell\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049\n```\n\n#### 4. 前缀索引\n\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n\n前缀长度的选取需要根据索引选择性来确定。\n\n#### 5. 覆盖索引\n\n创建包含所有需要查询的字段的索引。\n\n具有以下优点：\n\n- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n### 索引的优点\n\n- 减少服务器扫描的行数\n- 帮助服务器避免排序和分组，以及避免创建临时表。\n- 将随机 I/O 变为顺序 I/O（B+ Tree 特性）。\n\n### 索引的使用条件\n\n1. 跟快排差不多，数据量小的时候反而不如暴力。\n   - 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n   - 对于中到大型的表，索引就非常有效；\n   - 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n2. 频繁地查询操作。尤其是查询的列是固定的，这些列就是索引的好候选。\n3. 排序和分组操作。如果一个查询包含 `ORDER BY` 或 `GROUP BY` 子句，那么在相关列上创建索引可以提高查询效率。因为 B+树索引的 key 有序。\n4. 关联查询。如果关联的列上有索引，那么查询效率会更高。\n5. 唯一性约束。在需要强制唯一性约束的列（例如，用户的电子邮件地址或用户名）上创建唯一索引，可以确保数据的唯一性。\n6. 频繁的更新和插入操作。在经常需要更新的列或者插入新记录的表上创建索引，可以加速这些操作。\n\n### 索引失效的情况\n\n1. 使用非等值查询。（例如使用 `<>`、`!=`、`<`、`<=`、`>`、`>=`）或 `LIKE` 查询时，如果通配符 `%` 在前面，那么索引就无法使用。\n2. 使用函数或表达式。（例如 `WHERE DATE(column) = '2022-01-01'` 或 `WHERE column + 1 = 10`）时，索引无法使用。\n3. 数据类型不匹配。例如，如果索引列是字符串类型，但在查询条件中使用了数字，那么索引可能无法使用。\n4. 不使用索引的列作为查询条件。\n5. 索引列包含 NULL 值。\n6. 使用`or`连接条件。如果这些条件并不都使用索引列，索引就无法使用。\n7. 数据量小，全表扫描更快。\n\n## 二、查询性能优化\n\n### 使用 Explain 进行分析\n\nExplain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。\n\n比较重要的字段有：\n\n- select_type : 查询类型，有简单查询、联合查询、子查询等\n- key : 使用的索引\n- rows : 扫描的行数\n\n### 优化数据访问\n\n#### 1. 减少请求的数据量\n\n- 只返回必要的列：最好不要使用 SELECT \\* 语句。\n- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。\n- **缓存**重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。\n\n#### 2. 减少服务器端扫描的行数\n\n索引覆盖查询。\n\n### 重构查询方式\n\n#### 1. 切分大查询\n\n将大查询切分成多个小查询。\n\n一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。\n\n```mysql\nDELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);\n```\n\n```c++\nrows_affected = 0\ndo {\n    rows_affected = do_query(\n    \"DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\")\n} while rows_affected > 0\n```\n\n#### 2. 分解大连接查询\n\n将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：\n\n- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。\n- 减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。\n- 减少锁竞争。\n- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。\n- 查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。\n\n```mysql\nSELECT * FROM tag\nJOIN tag_post ON tag_post.tag_id=tag.id\nJOIN post ON tag_post.post_id=post.id\nWHERE tag.tag='mysql';\n```\n\n```mysql\nSELECT * FROM tag WHERE tag='mysql';\nSELECT * FROM tag_post WHERE tag_id=1234;\nSELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);\n```\n\n## 三、存储引擎\n\n### InnoDB\n\n是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n\n实现了四个标准的隔离级别，默认级别是可重复读。\n\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n","slug":"mysql","published":1,"updated":"2024-03-22T03:36:11.713Z","comments":1,"layout":"post","photos":[],"_id":"clu247pw40013jocgbphx20ez","content":"<h2 id=\"一、索引\"><a href=\"#一、索引\" class=\"headerlink\" title=\"一、索引\"></a>一、索引</h2><h3 id=\"B-Tree-原理\"><a href=\"#B-Tree-原理\" class=\"headerlink\" title=\"B+ Tree 原理\"></a>B+ Tree 原理</h3><h4 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1. 数据结构\"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是 B Tree 的数据不只是存放在叶子节点。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n<span id=\"more\"></span>\n\n<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<h4 id=\"2-操作\"><a href=\"#2-操作\" class=\"headerlink\" title=\"2. 操作\"></a>2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>\n<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>\n<h4 id=\"3-与红黑树的比较\"><a href=\"#3-与红黑树的比较\" class=\"headerlink\" title=\"3. 与红黑树的比较\"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为 B+树访问磁盘数据具有更高的性能。</p>\n<p>（一）B+ 树有更低的树高</p>\n<p>平衡树的树高 O(h)&#x3D;O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>\n<p>（二）磁盘访问原理</p>\n<p>一次 I&#x2F;O 能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。</p>\n<p>寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>\n<p>（三）磁盘预读特性</p>\n<p>能预先载入相邻块：而块之间的数据的 key 又有顺序关系：为了减少磁盘 I&#x2F;O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<h3 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>\n<h4 id=\"1-B-Tree-索引\"><a href=\"#1-B-Tree-索引\" class=\"headerlink\" title=\"1. B+ Tree 索引\"></a>1. B+ Tree 索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p>\n<p>查找速度快：只需要对树进行搜索。</p>\n<p>可用于排序和分组：B+ Tree 的有序性。</p>\n<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>\n<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>\n<p>主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231655495.png\"></p>\n<p>辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231743225.png\"></p>\n<h4 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>\n<ul>\n<li>无法用于排序与分组；</li>\n<li>只支持精确查找，无法用于部分查找和范围查找。</li>\n</ul>\n<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n<h4 id=\"3-全文索引（没见过，韩了）\"><a href=\"#3-全文索引（没见过，韩了）\" class=\"headerlink\" title=\"3. 全文索引（没见过，韩了）\"></a>3. 全文索引（没见过，韩了）</h4><p>InnoDB 和 MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>\n<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>\n<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>\n<h4 id=\"4-空间数据索引（没见过，韩了）\"><a href=\"#4-空间数据索引（没见过，韩了）\" class=\"headerlink\" title=\"4. 空间数据索引（没见过，韩了）\"></a>4. 空间数据索引（没见过，韩了）</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>\n<p>必须使用 GIS 相关的函数来维护数据。</p>\n<h3 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h3><h4 id=\"1-独立的列\"><a href=\"#1-独立的列\" class=\"headerlink\" title=\"1. 独立的列\"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>\n<p>例如下面的查询不能使用 actor_id 列的索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-多列索引\"><a href=\"#2-多列索引\" class=\"headerlink\" title=\"2. 多列索引\"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class=\"line\">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-索引列的顺序\"><a href=\"#3-索引列的顺序\" class=\"headerlink\" title=\"3. 索引列的顺序\"></a>3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p>\n<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>\n<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class=\"line\">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class=\"line\">COUNT(*)</span><br><span class=\"line\">FROM payment;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   staff_id_selectivity: <span class=\"number\">0.0001</span></span><br><span class=\"line\">customer_id_selectivity: <span class=\"number\">0.0373</span></span><br><span class=\"line\">               COUNT(*): <span class=\"number\">16049</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-前缀索引\"><a href=\"#4-前缀索引\" class=\"headerlink\" title=\"4. 前缀索引\"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>\n<p>前缀长度的选取需要根据索引选择性来确定。</p>\n<h4 id=\"5-覆盖索引\"><a href=\"#5-覆盖索引\" class=\"headerlink\" title=\"5. 覆盖索引\"></a>5. 覆盖索引</h4><p>创建包含所有需要查询的字段的索引。</p>\n<p>具有以下优点：</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>\n<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>\n<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>\n</ul>\n<h3 id=\"索引的优点\"><a href=\"#索引的优点\" class=\"headerlink\" title=\"索引的优点\"></a>索引的优点</h3><ul>\n<li>减少服务器扫描的行数</li>\n<li>帮助服务器避免排序和分组，以及避免创建临时表。</li>\n<li>将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+ Tree 特性）。</li>\n</ul>\n<h3 id=\"索引的使用条件\"><a href=\"#索引的使用条件\" class=\"headerlink\" title=\"索引的使用条件\"></a>索引的使用条件</h3><ol>\n<li>跟快排差不多，数据量小的时候反而不如暴力。<ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>\n</ul>\n</li>\n<li>频繁地查询操作。尤其是查询的列是固定的，这些列就是索引的好候选。</li>\n<li>排序和分组操作。如果一个查询包含 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句，那么在相关列上创建索引可以提高查询效率。因为 B+树索引的 key 有序。</li>\n<li>关联查询。如果关联的列上有索引，那么查询效率会更高。</li>\n<li>唯一性约束。在需要强制唯一性约束的列（例如，用户的电子邮件地址或用户名）上创建唯一索引，可以确保数据的唯一性。</li>\n<li>频繁的更新和插入操作。在经常需要更新的列或者插入新记录的表上创建索引，可以加速这些操作。</li>\n</ol>\n<h3 id=\"索引失效的情况\"><a href=\"#索引失效的情况\" class=\"headerlink\" title=\"索引失效的情况\"></a>索引失效的情况</h3><ol>\n<li>使用非等值查询。（例如使用 <code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>）或 <code>LIKE</code> 查询时，如果通配符 <code>%</code> 在前面，那么索引就无法使用。</li>\n<li>使用函数或表达式。（例如 <code>WHERE DATE(column) = &#39;2022-01-01&#39;</code> 或 <code>WHERE column + 1 = 10</code>）时，索引无法使用。</li>\n<li>数据类型不匹配。例如，如果索引列是字符串类型，但在查询条件中使用了数字，那么索引可能无法使用。</li>\n<li>不使用索引的列作为查询条件。</li>\n<li>索引列包含 NULL 值。</li>\n<li>使用<code>or</code>连接条件。如果这些条件并不都使用索引列，索引就无法使用。</li>\n<li>数据量小，全表扫描更快。</li>\n</ol>\n<h2 id=\"二、查询性能优化\"><a href=\"#二、查询性能优化\" class=\"headerlink\" title=\"二、查询性能优化\"></a>二、查询性能优化</h2><h3 id=\"使用-Explain-进行分析\"><a href=\"#使用-Explain-进行分析\" class=\"headerlink\" title=\"使用 Explain 进行分析\"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>\n<p>比较重要的字段有：</p>\n<ul>\n<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>\n<li>key : 使用的索引</li>\n<li>rows : 扫描的行数</li>\n</ul>\n<h3 id=\"优化数据访问\"><a href=\"#优化数据访问\" class=\"headerlink\" title=\"优化数据访问\"></a>优化数据访问</h3><h4 id=\"1-减少请求的数据量\"><a href=\"#1-减少请求的数据量\" class=\"headerlink\" title=\"1. 减少请求的数据量\"></a>1. 减少请求的数据量</h4><ul>\n<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>\n<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>\n<li><strong>缓存</strong>重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>\n</ul>\n<h4 id=\"2-减少服务器端扫描的行数\"><a href=\"#2-减少服务器端扫描的行数\" class=\"headerlink\" title=\"2. 减少服务器端扫描的行数\"></a>2. 减少服务器端扫描的行数</h4><p>索引覆盖查询。</p>\n<h3 id=\"重构查询方式\"><a href=\"#重构查询方式\" class=\"headerlink\" title=\"重构查询方式\"></a>重构查询方式</h3><h4 id=\"1-切分大查询\"><a href=\"#1-切分大查询\" class=\"headerlink\" title=\"1. 切分大查询\"></a>1. 切分大查询</h4><p>将大查询切分成多个小查询。</p>\n<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rows_affected = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    rows_affected = <span class=\"built_in\">do_query</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> rows_affected &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-分解大连接查询\"><a href=\"#2-分解大连接查询\" class=\"headerlink\" title=\"2. 分解大连接查询\"></a>2. 分解大连接查询</h4><p>将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：</p>\n<ul>\n<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>\n<li>减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。</li>\n<li>减少锁竞争。</li>\n<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>\n<li>查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag</span><br><span class=\"line\">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class=\"line\">JOIN post ON tag_post.post_id=post.id</span><br><span class=\"line\">WHERE tag.tag=&#x27;mysql&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;</span><br><span class=\"line\">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class=\"line\">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、存储引擎\"><a href=\"#三、存储引擎\" class=\"headerlink\" title=\"三、存储引擎\"></a>三、存储引擎</h2><h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>\n<p>实现了四个标准的隔离级别，默认级别是可重复读。</p>\n<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>\n<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>\n<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>\n","excerpt":"<h2 id=\"一、索引\"><a href=\"#一、索引\" class=\"headerlink\" title=\"一、索引\"></a>一、索引</h2><h3 id=\"B-Tree-原理\"><a href=\"#B-Tree-原理\" class=\"headerlink\" title=\"B+ Tree 原理\"></a>B+ Tree 原理</h3><h4 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1. 数据结构\"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是 B Tree 的数据不只是存放在叶子节点。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>","more":"<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<h4 id=\"2-操作\"><a href=\"#2-操作\" class=\"headerlink\" title=\"2. 操作\"></a>2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>\n<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>\n<h4 id=\"3-与红黑树的比较\"><a href=\"#3-与红黑树的比较\" class=\"headerlink\" title=\"3. 与红黑树的比较\"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为 B+树访问磁盘数据具有更高的性能。</p>\n<p>（一）B+ 树有更低的树高</p>\n<p>平衡树的树高 O(h)&#x3D;O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>\n<p>（二）磁盘访问原理</p>\n<p>一次 I&#x2F;O 能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。</p>\n<p>寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>\n<p>（三）磁盘预读特性</p>\n<p>能预先载入相邻块：而块之间的数据的 key 又有顺序关系：为了减少磁盘 I&#x2F;O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<h3 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>\n<h4 id=\"1-B-Tree-索引\"><a href=\"#1-B-Tree-索引\" class=\"headerlink\" title=\"1. B+ Tree 索引\"></a>1. B+ Tree 索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p>\n<p>查找速度快：只需要对树进行搜索。</p>\n<p>可用于排序和分组：B+ Tree 的有序性。</p>\n<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>\n<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>\n<p>主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231655495.png\"></p>\n<p>辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231743225.png\"></p>\n<h4 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>\n<ul>\n<li>无法用于排序与分组；</li>\n<li>只支持精确查找，无法用于部分查找和范围查找。</li>\n</ul>\n<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n<h4 id=\"3-全文索引（没见过，韩了）\"><a href=\"#3-全文索引（没见过，韩了）\" class=\"headerlink\" title=\"3. 全文索引（没见过，韩了）\"></a>3. 全文索引（没见过，韩了）</h4><p>InnoDB 和 MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>\n<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>\n<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>\n<h4 id=\"4-空间数据索引（没见过，韩了）\"><a href=\"#4-空间数据索引（没见过，韩了）\" class=\"headerlink\" title=\"4. 空间数据索引（没见过，韩了）\"></a>4. 空间数据索引（没见过，韩了）</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>\n<p>必须使用 GIS 相关的函数来维护数据。</p>\n<h3 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h3><h4 id=\"1-独立的列\"><a href=\"#1-独立的列\" class=\"headerlink\" title=\"1. 独立的列\"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>\n<p>例如下面的查询不能使用 actor_id 列的索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-多列索引\"><a href=\"#2-多列索引\" class=\"headerlink\" title=\"2. 多列索引\"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class=\"line\">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-索引列的顺序\"><a href=\"#3-索引列的顺序\" class=\"headerlink\" title=\"3. 索引列的顺序\"></a>3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p>\n<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>\n<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class=\"line\">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class=\"line\">COUNT(*)</span><br><span class=\"line\">FROM payment;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   staff_id_selectivity: <span class=\"number\">0.0001</span></span><br><span class=\"line\">customer_id_selectivity: <span class=\"number\">0.0373</span></span><br><span class=\"line\">               COUNT(*): <span class=\"number\">16049</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-前缀索引\"><a href=\"#4-前缀索引\" class=\"headerlink\" title=\"4. 前缀索引\"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>\n<p>前缀长度的选取需要根据索引选择性来确定。</p>\n<h4 id=\"5-覆盖索引\"><a href=\"#5-覆盖索引\" class=\"headerlink\" title=\"5. 覆盖索引\"></a>5. 覆盖索引</h4><p>创建包含所有需要查询的字段的索引。</p>\n<p>具有以下优点：</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>\n<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>\n<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>\n</ul>\n<h3 id=\"索引的优点\"><a href=\"#索引的优点\" class=\"headerlink\" title=\"索引的优点\"></a>索引的优点</h3><ul>\n<li>减少服务器扫描的行数</li>\n<li>帮助服务器避免排序和分组，以及避免创建临时表。</li>\n<li>将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+ Tree 特性）。</li>\n</ul>\n<h3 id=\"索引的使用条件\"><a href=\"#索引的使用条件\" class=\"headerlink\" title=\"索引的使用条件\"></a>索引的使用条件</h3><ol>\n<li>跟快排差不多，数据量小的时候反而不如暴力。<ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>\n</ul>\n</li>\n<li>频繁地查询操作。尤其是查询的列是固定的，这些列就是索引的好候选。</li>\n<li>排序和分组操作。如果一个查询包含 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句，那么在相关列上创建索引可以提高查询效率。因为 B+树索引的 key 有序。</li>\n<li>关联查询。如果关联的列上有索引，那么查询效率会更高。</li>\n<li>唯一性约束。在需要强制唯一性约束的列（例如，用户的电子邮件地址或用户名）上创建唯一索引，可以确保数据的唯一性。</li>\n<li>频繁的更新和插入操作。在经常需要更新的列或者插入新记录的表上创建索引，可以加速这些操作。</li>\n</ol>\n<h3 id=\"索引失效的情况\"><a href=\"#索引失效的情况\" class=\"headerlink\" title=\"索引失效的情况\"></a>索引失效的情况</h3><ol>\n<li>使用非等值查询。（例如使用 <code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>）或 <code>LIKE</code> 查询时，如果通配符 <code>%</code> 在前面，那么索引就无法使用。</li>\n<li>使用函数或表达式。（例如 <code>WHERE DATE(column) = &#39;2022-01-01&#39;</code> 或 <code>WHERE column + 1 = 10</code>）时，索引无法使用。</li>\n<li>数据类型不匹配。例如，如果索引列是字符串类型，但在查询条件中使用了数字，那么索引可能无法使用。</li>\n<li>不使用索引的列作为查询条件。</li>\n<li>索引列包含 NULL 值。</li>\n<li>使用<code>or</code>连接条件。如果这些条件并不都使用索引列，索引就无法使用。</li>\n<li>数据量小，全表扫描更快。</li>\n</ol>\n<h2 id=\"二、查询性能优化\"><a href=\"#二、查询性能优化\" class=\"headerlink\" title=\"二、查询性能优化\"></a>二、查询性能优化</h2><h3 id=\"使用-Explain-进行分析\"><a href=\"#使用-Explain-进行分析\" class=\"headerlink\" title=\"使用 Explain 进行分析\"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>\n<p>比较重要的字段有：</p>\n<ul>\n<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>\n<li>key : 使用的索引</li>\n<li>rows : 扫描的行数</li>\n</ul>\n<h3 id=\"优化数据访问\"><a href=\"#优化数据访问\" class=\"headerlink\" title=\"优化数据访问\"></a>优化数据访问</h3><h4 id=\"1-减少请求的数据量\"><a href=\"#1-减少请求的数据量\" class=\"headerlink\" title=\"1. 减少请求的数据量\"></a>1. 减少请求的数据量</h4><ul>\n<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>\n<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>\n<li><strong>缓存</strong>重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>\n</ul>\n<h4 id=\"2-减少服务器端扫描的行数\"><a href=\"#2-减少服务器端扫描的行数\" class=\"headerlink\" title=\"2. 减少服务器端扫描的行数\"></a>2. 减少服务器端扫描的行数</h4><p>索引覆盖查询。</p>\n<h3 id=\"重构查询方式\"><a href=\"#重构查询方式\" class=\"headerlink\" title=\"重构查询方式\"></a>重构查询方式</h3><h4 id=\"1-切分大查询\"><a href=\"#1-切分大查询\" class=\"headerlink\" title=\"1. 切分大查询\"></a>1. 切分大查询</h4><p>将大查询切分成多个小查询。</p>\n<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rows_affected = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    rows_affected = <span class=\"built_in\">do_query</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> rows_affected &gt; <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-分解大连接查询\"><a href=\"#2-分解大连接查询\" class=\"headerlink\" title=\"2. 分解大连接查询\"></a>2. 分解大连接查询</h4><p>将大连接查询分解成对每一个进行单表查询，然后交给应用程序处理：</p>\n<ul>\n<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>\n<li>减少冗余记录查询。分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到。</li>\n<li>减少锁竞争。</li>\n<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>\n<li>查询本身效率可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag</span><br><span class=\"line\">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class=\"line\">JOIN post ON tag_post.post_id=post.id</span><br><span class=\"line\">WHERE tag.tag=&#x27;mysql&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;</span><br><span class=\"line\">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class=\"line\">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、存储引擎\"><a href=\"#三、存储引擎\" class=\"headerlink\" title=\"三、存储引擎\"></a>三、存储引擎</h2><h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>\n<p>实现了四个标准的隔离级别，默认级别是可重复读。</p>\n<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>\n<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>\n<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>"},{"title":"操作系统原理","date":"2024-03-20T09:52:08.000Z","toc":true,"_content":"\n转载自：https://github.com/CyC2018/CS-Notes/tree/master\n\n## 概述\n\n### 基本特征\n\n#### 1. 并发\n\n并发指宏观上一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。\n\n并行需要硬件支持：多流水线、多处理器。\n\n操作系统引入进程和线程，使程序能够并发运行。\n\n<!--more-->\n\n#### 2. 共享\n\n共享指多个进程同时使用系统资源。\n\n两种共享：互斥共享和同时共享。\n\n互斥共享使用的是临界资源，同一时刻只允许一个进程访问，需要用同步机制实现互斥访问。\n\n同步原语：\n\n- 互斥锁\n- 信号量\n- 条件变量\n- 读写锁\n\n#### 3. 虚拟\n\n虚拟技术把一个物理实体转换为多个逻辑实体。\n\n主要有两种虚拟技术：时分复用和空分复用。\n\n多进程在同一个处理器上并发执行使用了时分复用，轮流占用处理器。\n\n虚拟内存使用了空分复用，将物理内存抽象为地址空间，每个进程都有自己的地址空间。\n\n#### 4. 异步\n\n异步指进程不是一次性执行完毕，走走停停。\n\n联想到异步 I/O，应用程序执行系统调用会立即返回，可以继续执行，不会被阻塞。内核在完成所有操作后通知应用程序。\n\n### 基本功能\n\n#### 1. 进程管理\n\n进程控制、进程同步、进程通信、死锁处理、处理机调度等。\n\n#### 2. 内存管理\n\n内存分配、地址映射、内存保护与共享、虚拟内存等。\n\n#### 3. 文件管理\n\n文件存储空间的管理、目录管理、文件读写管理和保护。\n\n#### 4. 设备管理\n\n完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。\n\n主要包括缓冲管理、设备分配、设备处理、虚拟设备等。\n\n### 系统调用\n\n一个进程在用户态要用到内核态的功能，就进行系统调用，从而陷入内核，由操作系统代完成。\n\n![image-20240320175407843](operating-systems/image-20240320175407843.png)\n\nLinux 的系统调用主要有以下这些（暂不了解）：\n\n| Task     | Commands                    |\n| -------- | --------------------------- |\n| 进程控制 | fork(); exit(); wait();     |\n| 进程通信 | pipe(); shmget(); mmap();   |\n| 文件操作 | open(); read(); write();    |\n| 设备操作 | ioctl(); read(); write();   |\n| 信息维护 | getpid(); alarm(); sleep(); |\n| 安全     | chmod(); umask(); chown();  |\n\n### 宏内核和微内核\n\n#### 1. 宏内核\n\n将操作系统作为紧密结合的整体放到内核。\n\n由于各模块共享信息，所以性能高。\n\n#### 2. 微内核\n\n将一部分操作系统功能移出内核，降低内核复杂性。移出部分根据分层原则划分为若干服务，相互独立。\n\n只有微内核运行在内核态，其它模块运行在用户态。\n\n频繁在用户态和内核态切换，有一定的性能损失。\n\n![image-20240320175421234](operating-systems/image-20240320175421234.png)\n\n### 中断分类\n\n#### 1. 外中断\n\n由 CPU 执行指令以外的事件引起（表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求），如 I/O 完成中断、时钟中断、控制台中断等。\n\n#### 2. 异常\n\n由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。\n\n#### 3. 陷入\n\n用户程序使用系统调用。\n\n## 进程管理\n\n### 进程与线程\n\n#### 1. 进程\n\n是资源分配的基本单位。\n\n进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。\n\n下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。（时分复用）\n\n![image-20240320175436050](operating-systems/image-20240320175436050.png)\n\n#### 2. 线程\n\n是独立调度的基本单位。\n\n一个进程中可以有多个线程，共享进程资源。（互斥共享、同时共享）\n\n![image-20240320175446963](operating-systems/image-20240320175446963.png)\n\n浏览器是一个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。\n\n#### 3. 区别\n\n|          | 进程                                                               | 线程                                                                           |\n| -------- | ------------------------------------------------------------------ | ------------------------------------------------------------------------------ |\n| 拥有资源 | 进程是资源分配的基本单位，拥有独立的资源                           | 线程不拥有资源，可以访问隶属进程的资源                                         |\n| 调度     | 进程切换会引起线程切换                                             | 线程是独立调度的基本单位，线程的切换不会引起进程切换（指单个进程中的线程切换） |\n| 系统开销 | 创建或撤销进程的开销大，需要分配或回收资源，如内存空间、I/O 设备等 | 创建或撤销线程的开销小，线程切换时只需保存和设置少量寄存器内容                 |\n| 通信     | 进程间通信需要借助 IPC                                             | 线程间可以通过直接读写同一进程中的数据进行通信                                 |\n\n### 进程状态的切换\n\n![image-20240320175455259](operating-systems/image-20240320175455259.png)\n\n- 就绪（ready）：等待被调度\n- 运行（running）\n- 阻塞（waiting）：等待资源\n\n注意：\n\n- 只有就绪和运行可以相互转换，其它都是单向。就绪的进程通过调度算法获得 CPU 时间，转为运行；运行用完分配的 CPU 时间，转为就绪。\n- 阻塞是运行态缺少资源转换而来，这个资源不包括 CPU 时间。\n\n### 进程调度算法\n\n因地制宜。\n\n#### 1. 批处理系统\n\n没有太多用户操作，目标是保证吞吐量和周转时间。（从**提交**到终止的时间）\n\n##### 1.1 先来先服务 first-come first-served（FCFS）\n\n非抢占式，按请求顺序调度。\n\n不利于短作业，因为要等待前面的长作业执行完毕。\n\n##### 1.2 短作业优先\n\n非抢占，按**估计**运行时间最短调度。\n\n长作业有可能永远得不到调度。\n\n##### 1.3 最短剩余时间有限\n\n短作业优先的**抢占式**版本，按**剩余**运行时间最短的顺序进行调度。新作业到达时，会与当前进程剩余时间比较。如果新进程需要时间更少，则挂起当前进程，运行新的进程（抢占）。\n\n#### 2. 交互式系统\n\n##### 2.1 时间片轮转\n\n所有就绪进程按 FCFS 原则排成队列，CPU 分配时间，轮转执行进程。\n\n效率和时间片的大小相关：\n\n- 时间片太小，导致进程切换频繁，消耗时间。\n- 时间片太大，实时性得不到保证。\n\n![image-20240320175508729](operating-systems/image-20240320175508729.png)\n\n##### 2.2 优先级调度\n\n为每个进程分配优先级，按优先级调度。\n\n为防止低优先级进程等不到调度，可随时间推移增加等待进程的优先级。\n\n##### 2.3 多级反馈队列\n\n一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。\n\n多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列（依然是时间片轮转），每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列（降低优先级）。这种方式下，之前的进程只需要交换 7 次。\n\n只有上一个队列没有进程在排队，才能调度当前队列上的进程。\n\n![image-20240320175525345](operating-systems/image-20240320175525345.png)\n\n#### 3. 实时系统\n\n要求请求在一个确定时间内得到相应。\n\n分为硬实时（必须满足绝对的截止时间）和软实时（可以容忍一定的超时）。\n\n### 进程同步\n\n#### 1. 临界区（这个词多用于描述多线程）\n\n对临界资源进行访问的代码称为临界区。\n\n为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。\n\n```\n// entry section\n// critical section; 只有这一部分是临界区\n// exit section\n```\n\n#### 2. 同步与互斥\n\n- 同步：多进程因合作产生的直接制约关系，使进程有一定的先后执行顺序。\n- 互斥：多进程在同一时刻只能有一个进程进入临界区。\n\n#### 3. 信号量\n\n信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。\n\n- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0（此时还未进入临界区）；\n- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。\n\ndown 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。\n\n如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。\n\n```\ntypedef int semaphore;\nsemaphore mutex = 1;\nvoid P1() {\n    down(&mutex);\n    // 临界区\n    up(&mutex);\n}\n\nvoid P2() {\n    down(&mutex);\n    // 临界区\n    up(&mutex);\n}\n```\n\n**使用信号量实现生产者-消费者问题**\n\n问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。\n\n因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。\n\n为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。\n\n注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。\n\n```\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;\nsemaphore empty = N;\nsemaphore full = 0;\n\nvoid producer() {\n    while(TRUE) {\n        int item = produce_item();\n        down(&empty); // 注意，empty和mutex的顺序不能颠倒\n        down(&mutex);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    while(TRUE) {\n        down(&full);\n        down(&mutex);\n        int item = remove_item();\n        consume_item(item);\n        up(&mutex);\n        up(&empty);\n    }\n}\n```\n\n#### 4. 管程\n\n信号量机制需要客户端代码做很多控制，管程把控制的代码独立出来，客户端只需要调用方法。\n\n一个时刻只能有一个进程使用管程。进程无法执行时不能一直占用管程。\n\n管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。\n\n### 经典同步问题\n\n#### 1. 哲学家进餐问题\n\n![image-20240320175548861](operating-systems/image-20240320175548861.png)\n\n五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。\n\n为了防止死锁：\n\n- 必须同时拿起左右两根筷子；\n- 只有在两个邻居都没有进餐的情况下才允许进餐。\n\n#### 2. 读者-写者问题\n\n允许多进程同时对数据进行读操作，不能同时读写，也不能同时写。\n\n一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。\n\n写者只需要使用 data_mutex 对写的数据加锁。\n\n### 进程通信\n\n进程同步和进程通信的区别：\n\n- 同步：控制多进程按一定顺序执行。\n- 通信：进程间传输消息。\n\n通信是手段，同步是目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。\n\n#### 1. 管道\n\n- 半双工通信。\n- 只能在父子进程或兄弟进程中使用。\n\n![image-20240320175601947](operating-systems/image-20240320175601947.png)\n\n#### 2. FIFO\n\n命名管道，去除了管道只能在父子进程中使用的限制。\n\n常用于 C-S 中。\n\n![image-20240320175609777](operating-systems/image-20240320175609777.png)\n\n#### 3. 消息队列\n\n相比于 FIFO，消息队列具有以下优点：\n\n- 消息队列可以独立于读写进程存在（作为一个独立的实体存在，不依赖于创建它的进程），从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；\n- 避免了 FIFO 的同步阻塞问题（进程可以立即返回并执行其他操作，而不是等待队列可以执行。发送者可以快速地把消息放入队列然后继续执行其他任务，而不需要等待接收者处理消息），不需要进程自己提供同步方法；\n- 读进程可以根据消息类型有选择地接收消息（如只接收优先级最高的消息），而不像 FIFO 那样只能默认地接收（严格按照写入的顺序）。\n\n#### 4. 信号量\n\n计数器。\n\n在进程间通信的情境下，信号量可以用来传递信息或者是信号。一个进程可以通过增加信号量值来向其他进程发送一个信号，其他进程可以通过检查信号量值来接收这个信号。\n\n和进程同步中的信号量是同一种机制，但是使用方式和目的有所不同。\n\n#### 5. 共享存储\n\n允许多个进程共享一个给定的存储区。这是最快的一种 IPC。\n\n需要用信号量来同步对共享存储的访问。\n\n#### 6. 套接字\n\n可用于不同机器间的进程通信。\n\n## 死锁\n\n### 必要条件\n\n![image-20240320175633047](operating-systems/image-20240320175633047.png)\n\n- 互斥：资源要么被分配给一个进程，要么可用。\n- 占有和等待：已得到某个资源的进程，可以继续请求新的资源。\n- 不可抢占：资源只能被占有它的进程显式释放。\n- 环路等待：两个及以上的进程组成环路，该环路中每个进程都在等待下一个进程占有的资源。\n\n### 处理方法\n\n主要有四种：\n\n- 鸵鸟策略\n- 死锁检测与死锁恢复\n- 死锁预防\n- 死锁避免\n\n### 鸵鸟策略\n\n锁了就是锁了？假装根本没发生死锁。\n\n解决死锁代价很高，这种方案会获得很高的性能。\n\n当死锁对用户不会造成多大的影响，或死锁发生的概率很低时，可采取。\n\n大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。\n\n### 死锁检测与死锁恢复\n\n不阻止，检测到死锁发生时，采取措施恢复。\n\n#### 1. 每种类型一个资源的死锁检测\n\n![image-20240320175638377](operating-systems/image-20240320175638377.png)\n\n圆圈表示进程，方框表示资源。进程指向资源表示进程请求获取该资源，反之表示进程已经占有该资源。\n\n图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。\n\n每种类型**一个资源**的死锁检测算法是通过检测**有向图是否存在环**来实现，从一个节点出发进行 dfs，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。\n\n#### 2. 每种类型多个资源的死锁检测\n\n![image-20240320175649285](operating-systems/image-20240320175649285.png)\n\n上图中，有三个进程四个资源，每个数据代表的含义如下：\n\n- E 向量：资源总量\n- A 向量：资源剩余量\n- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量\n- R 矩阵：每个进程请求的资源数量\n\n进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。\n\n```\n初始化所有进程为未标记状态\n设置 A 为可用资源\n\nwhile 存在未标记的进程 Pi，其所请求的资源小于等于 A do\n    将 C 矩阵的第 i 行向量加到 A\n    标记进程 Pi\nend while\n\n检查所有进程，如果存在未被标记的进程，则标记为死锁进程\n```\n\n#### 3. 死锁恢复\n\n- 抢占恢复\n- 回滚恢复\n- 杀死进程恢复\n\n### 死锁预防\n\n程序运行**之前**预防发生死锁，即破坏发生死锁的四个条件。\n\n#### 1. 破坏互斥条件（最难破坏，也有可能无法破坏）\n\n例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。\n\n#### 2. 破坏占有和等待条件\n\n一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。\n\n#### 3. 破坏不可抢占条件\n\n#### 4. 破坏环路等待\n\n给资源统一编号，进程只能按编号顺序来请求资源。\n\n### 死锁避免\n\n程序**运行时**避免发生死锁。（死锁避免其实就是用死锁检测的方法，先检测如果执行了请求，未来的状态是否会发生死锁，然后避免）\n\n#### 1. 安全状态\n\n![image-20240320175712336](operating-systems/image-20240320175712336.png)\n\n图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。\n\n定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。\n\n安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。\n\n#### 2. 单个资源的银行家算法\n\n一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。\n\n![image-20240320175725276](operating-systems/image-20240320175725276.png)\n\n上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。\n\n#### 3. 多个资源的银行家算法\n\n![image-20240320175747301](operating-systems/image-20240320175747301.png)\n\n上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。\n\n检查一个状态是否安全的算法如下：\n\n- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。\n- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。\n- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。\n\n如果一个状态不是安全的，需要拒绝进入这个状态。\n\n## 内存管理\n\n### 虚拟内存\n\n虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。\n\n为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。\n\n从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。\n\n![image-20240320180056054](operating-systems/image-20240320180056054.png)\n\n### 分页系统地址映射\n\n内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。\n\n一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。\n\n下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于**虚拟**地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的**页框**的地址为 （110 000000000100）。少了一位。\n\n![image-20240320180104512](operating-systems/image-20240320180104512.png)\n\n### 页面置换算法\n\n在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。\n\n页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。\n\n页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。\n\n#### 1. 最佳\n\n> OPT, Optimal replacement algorithm\n\n所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。\n\n是一种理论上的算法，因为无法知道一个页面多长时间（未来的时间）不再被访问。\n\n举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：\n\n```\n7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1\n```\n\n开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，看后续页面，7, 0, 1 出现的先后顺序为 0, 1, 7，即页面 7 再次被访问的时间最长。\n\n#### 2. 最近最久未使用\n\n> LRU, Least Recently Used\n\n虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。\n\n为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。\n\n因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。\n\n```\n4，7，0，7，1，0，1，2，1，2，6\n```\n\n下图中最后一个才涉及到页面置换，最久未使用的 4 被移出。\n\n![image-20240320180115680](operating-systems/image-20240320180115680.png)\n\n#### 3. 最近未使用\n\n> NRU, Not Recently Used\n\n每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：\n\n- R=0，M=0\n- R=0，M=1\n- R=1，M=0\n- R=1，M=1\n\n当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。\n\nNRU 优先换出**已经被修改的脏页面**（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。\n\n#### 4. 先进先出\n\n> FIFO, First In First Out\n\n选择换出的页面是最先进入的页面。\n\n该算法会将那些经常被访问的页面换出，导致缺页率升高。\n\n#### 5. 第二次机会算法\n\nFIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：\n\n当页面被访问 (读或写) 时设置该页面的 R 位为 1（说明该页面之前被访问过，获得了复活甲，R = 1）。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0（复活甲掉了），并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。\n\n![image-20240320180128128](operating-systems/image-20240320180128128.png)\n\n#### 6. 时钟\n\n> Clock\n\n第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。\n\n![image-20240320180134569](operating-systems/image-20240320180134569.png)\n\n### 分段（暂无）\n","source":"_posts/operating-systems.md","raw":"---\ntitle: 操作系统原理\ndate: 2024-03-20 17:52:08\ncategories:\n  - work\n  - review\n  - operating systems\ntags:\n  - operating systems\n  - principles\ntoc: true\n---\n\n转载自：https://github.com/CyC2018/CS-Notes/tree/master\n\n## 概述\n\n### 基本特征\n\n#### 1. 并发\n\n并发指宏观上一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。\n\n并行需要硬件支持：多流水线、多处理器。\n\n操作系统引入进程和线程，使程序能够并发运行。\n\n<!--more-->\n\n#### 2. 共享\n\n共享指多个进程同时使用系统资源。\n\n两种共享：互斥共享和同时共享。\n\n互斥共享使用的是临界资源，同一时刻只允许一个进程访问，需要用同步机制实现互斥访问。\n\n同步原语：\n\n- 互斥锁\n- 信号量\n- 条件变量\n- 读写锁\n\n#### 3. 虚拟\n\n虚拟技术把一个物理实体转换为多个逻辑实体。\n\n主要有两种虚拟技术：时分复用和空分复用。\n\n多进程在同一个处理器上并发执行使用了时分复用，轮流占用处理器。\n\n虚拟内存使用了空分复用，将物理内存抽象为地址空间，每个进程都有自己的地址空间。\n\n#### 4. 异步\n\n异步指进程不是一次性执行完毕，走走停停。\n\n联想到异步 I/O，应用程序执行系统调用会立即返回，可以继续执行，不会被阻塞。内核在完成所有操作后通知应用程序。\n\n### 基本功能\n\n#### 1. 进程管理\n\n进程控制、进程同步、进程通信、死锁处理、处理机调度等。\n\n#### 2. 内存管理\n\n内存分配、地址映射、内存保护与共享、虚拟内存等。\n\n#### 3. 文件管理\n\n文件存储空间的管理、目录管理、文件读写管理和保护。\n\n#### 4. 设备管理\n\n完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。\n\n主要包括缓冲管理、设备分配、设备处理、虚拟设备等。\n\n### 系统调用\n\n一个进程在用户态要用到内核态的功能，就进行系统调用，从而陷入内核，由操作系统代完成。\n\n![image-20240320175407843](operating-systems/image-20240320175407843.png)\n\nLinux 的系统调用主要有以下这些（暂不了解）：\n\n| Task     | Commands                    |\n| -------- | --------------------------- |\n| 进程控制 | fork(); exit(); wait();     |\n| 进程通信 | pipe(); shmget(); mmap();   |\n| 文件操作 | open(); read(); write();    |\n| 设备操作 | ioctl(); read(); write();   |\n| 信息维护 | getpid(); alarm(); sleep(); |\n| 安全     | chmod(); umask(); chown();  |\n\n### 宏内核和微内核\n\n#### 1. 宏内核\n\n将操作系统作为紧密结合的整体放到内核。\n\n由于各模块共享信息，所以性能高。\n\n#### 2. 微内核\n\n将一部分操作系统功能移出内核，降低内核复杂性。移出部分根据分层原则划分为若干服务，相互独立。\n\n只有微内核运行在内核态，其它模块运行在用户态。\n\n频繁在用户态和内核态切换，有一定的性能损失。\n\n![image-20240320175421234](operating-systems/image-20240320175421234.png)\n\n### 中断分类\n\n#### 1. 外中断\n\n由 CPU 执行指令以外的事件引起（表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求），如 I/O 完成中断、时钟中断、控制台中断等。\n\n#### 2. 异常\n\n由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。\n\n#### 3. 陷入\n\n用户程序使用系统调用。\n\n## 进程管理\n\n### 进程与线程\n\n#### 1. 进程\n\n是资源分配的基本单位。\n\n进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。\n\n下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。（时分复用）\n\n![image-20240320175436050](operating-systems/image-20240320175436050.png)\n\n#### 2. 线程\n\n是独立调度的基本单位。\n\n一个进程中可以有多个线程，共享进程资源。（互斥共享、同时共享）\n\n![image-20240320175446963](operating-systems/image-20240320175446963.png)\n\n浏览器是一个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。\n\n#### 3. 区别\n\n|          | 进程                                                               | 线程                                                                           |\n| -------- | ------------------------------------------------------------------ | ------------------------------------------------------------------------------ |\n| 拥有资源 | 进程是资源分配的基本单位，拥有独立的资源                           | 线程不拥有资源，可以访问隶属进程的资源                                         |\n| 调度     | 进程切换会引起线程切换                                             | 线程是独立调度的基本单位，线程的切换不会引起进程切换（指单个进程中的线程切换） |\n| 系统开销 | 创建或撤销进程的开销大，需要分配或回收资源，如内存空间、I/O 设备等 | 创建或撤销线程的开销小，线程切换时只需保存和设置少量寄存器内容                 |\n| 通信     | 进程间通信需要借助 IPC                                             | 线程间可以通过直接读写同一进程中的数据进行通信                                 |\n\n### 进程状态的切换\n\n![image-20240320175455259](operating-systems/image-20240320175455259.png)\n\n- 就绪（ready）：等待被调度\n- 运行（running）\n- 阻塞（waiting）：等待资源\n\n注意：\n\n- 只有就绪和运行可以相互转换，其它都是单向。就绪的进程通过调度算法获得 CPU 时间，转为运行；运行用完分配的 CPU 时间，转为就绪。\n- 阻塞是运行态缺少资源转换而来，这个资源不包括 CPU 时间。\n\n### 进程调度算法\n\n因地制宜。\n\n#### 1. 批处理系统\n\n没有太多用户操作，目标是保证吞吐量和周转时间。（从**提交**到终止的时间）\n\n##### 1.1 先来先服务 first-come first-served（FCFS）\n\n非抢占式，按请求顺序调度。\n\n不利于短作业，因为要等待前面的长作业执行完毕。\n\n##### 1.2 短作业优先\n\n非抢占，按**估计**运行时间最短调度。\n\n长作业有可能永远得不到调度。\n\n##### 1.3 最短剩余时间有限\n\n短作业优先的**抢占式**版本，按**剩余**运行时间最短的顺序进行调度。新作业到达时，会与当前进程剩余时间比较。如果新进程需要时间更少，则挂起当前进程，运行新的进程（抢占）。\n\n#### 2. 交互式系统\n\n##### 2.1 时间片轮转\n\n所有就绪进程按 FCFS 原则排成队列，CPU 分配时间，轮转执行进程。\n\n效率和时间片的大小相关：\n\n- 时间片太小，导致进程切换频繁，消耗时间。\n- 时间片太大，实时性得不到保证。\n\n![image-20240320175508729](operating-systems/image-20240320175508729.png)\n\n##### 2.2 优先级调度\n\n为每个进程分配优先级，按优先级调度。\n\n为防止低优先级进程等不到调度，可随时间推移增加等待进程的优先级。\n\n##### 2.3 多级反馈队列\n\n一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。\n\n多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列（依然是时间片轮转），每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列（降低优先级）。这种方式下，之前的进程只需要交换 7 次。\n\n只有上一个队列没有进程在排队，才能调度当前队列上的进程。\n\n![image-20240320175525345](operating-systems/image-20240320175525345.png)\n\n#### 3. 实时系统\n\n要求请求在一个确定时间内得到相应。\n\n分为硬实时（必须满足绝对的截止时间）和软实时（可以容忍一定的超时）。\n\n### 进程同步\n\n#### 1. 临界区（这个词多用于描述多线程）\n\n对临界资源进行访问的代码称为临界区。\n\n为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。\n\n```\n// entry section\n// critical section; 只有这一部分是临界区\n// exit section\n```\n\n#### 2. 同步与互斥\n\n- 同步：多进程因合作产生的直接制约关系，使进程有一定的先后执行顺序。\n- 互斥：多进程在同一时刻只能有一个进程进入临界区。\n\n#### 3. 信号量\n\n信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。\n\n- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0（此时还未进入临界区）；\n- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。\n\ndown 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。\n\n如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。\n\n```\ntypedef int semaphore;\nsemaphore mutex = 1;\nvoid P1() {\n    down(&mutex);\n    // 临界区\n    up(&mutex);\n}\n\nvoid P2() {\n    down(&mutex);\n    // 临界区\n    up(&mutex);\n}\n```\n\n**使用信号量实现生产者-消费者问题**\n\n问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。\n\n因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。\n\n为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。\n\n注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。\n\n```\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;\nsemaphore empty = N;\nsemaphore full = 0;\n\nvoid producer() {\n    while(TRUE) {\n        int item = produce_item();\n        down(&empty); // 注意，empty和mutex的顺序不能颠倒\n        down(&mutex);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    while(TRUE) {\n        down(&full);\n        down(&mutex);\n        int item = remove_item();\n        consume_item(item);\n        up(&mutex);\n        up(&empty);\n    }\n}\n```\n\n#### 4. 管程\n\n信号量机制需要客户端代码做很多控制，管程把控制的代码独立出来，客户端只需要调用方法。\n\n一个时刻只能有一个进程使用管程。进程无法执行时不能一直占用管程。\n\n管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。\n\n### 经典同步问题\n\n#### 1. 哲学家进餐问题\n\n![image-20240320175548861](operating-systems/image-20240320175548861.png)\n\n五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。\n\n为了防止死锁：\n\n- 必须同时拿起左右两根筷子；\n- 只有在两个邻居都没有进餐的情况下才允许进餐。\n\n#### 2. 读者-写者问题\n\n允许多进程同时对数据进行读操作，不能同时读写，也不能同时写。\n\n一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。\n\n写者只需要使用 data_mutex 对写的数据加锁。\n\n### 进程通信\n\n进程同步和进程通信的区别：\n\n- 同步：控制多进程按一定顺序执行。\n- 通信：进程间传输消息。\n\n通信是手段，同步是目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。\n\n#### 1. 管道\n\n- 半双工通信。\n- 只能在父子进程或兄弟进程中使用。\n\n![image-20240320175601947](operating-systems/image-20240320175601947.png)\n\n#### 2. FIFO\n\n命名管道，去除了管道只能在父子进程中使用的限制。\n\n常用于 C-S 中。\n\n![image-20240320175609777](operating-systems/image-20240320175609777.png)\n\n#### 3. 消息队列\n\n相比于 FIFO，消息队列具有以下优点：\n\n- 消息队列可以独立于读写进程存在（作为一个独立的实体存在，不依赖于创建它的进程），从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；\n- 避免了 FIFO 的同步阻塞问题（进程可以立即返回并执行其他操作，而不是等待队列可以执行。发送者可以快速地把消息放入队列然后继续执行其他任务，而不需要等待接收者处理消息），不需要进程自己提供同步方法；\n- 读进程可以根据消息类型有选择地接收消息（如只接收优先级最高的消息），而不像 FIFO 那样只能默认地接收（严格按照写入的顺序）。\n\n#### 4. 信号量\n\n计数器。\n\n在进程间通信的情境下，信号量可以用来传递信息或者是信号。一个进程可以通过增加信号量值来向其他进程发送一个信号，其他进程可以通过检查信号量值来接收这个信号。\n\n和进程同步中的信号量是同一种机制，但是使用方式和目的有所不同。\n\n#### 5. 共享存储\n\n允许多个进程共享一个给定的存储区。这是最快的一种 IPC。\n\n需要用信号量来同步对共享存储的访问。\n\n#### 6. 套接字\n\n可用于不同机器间的进程通信。\n\n## 死锁\n\n### 必要条件\n\n![image-20240320175633047](operating-systems/image-20240320175633047.png)\n\n- 互斥：资源要么被分配给一个进程，要么可用。\n- 占有和等待：已得到某个资源的进程，可以继续请求新的资源。\n- 不可抢占：资源只能被占有它的进程显式释放。\n- 环路等待：两个及以上的进程组成环路，该环路中每个进程都在等待下一个进程占有的资源。\n\n### 处理方法\n\n主要有四种：\n\n- 鸵鸟策略\n- 死锁检测与死锁恢复\n- 死锁预防\n- 死锁避免\n\n### 鸵鸟策略\n\n锁了就是锁了？假装根本没发生死锁。\n\n解决死锁代价很高，这种方案会获得很高的性能。\n\n当死锁对用户不会造成多大的影响，或死锁发生的概率很低时，可采取。\n\n大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。\n\n### 死锁检测与死锁恢复\n\n不阻止，检测到死锁发生时，采取措施恢复。\n\n#### 1. 每种类型一个资源的死锁检测\n\n![image-20240320175638377](operating-systems/image-20240320175638377.png)\n\n圆圈表示进程，方框表示资源。进程指向资源表示进程请求获取该资源，反之表示进程已经占有该资源。\n\n图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。\n\n每种类型**一个资源**的死锁检测算法是通过检测**有向图是否存在环**来实现，从一个节点出发进行 dfs，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。\n\n#### 2. 每种类型多个资源的死锁检测\n\n![image-20240320175649285](operating-systems/image-20240320175649285.png)\n\n上图中，有三个进程四个资源，每个数据代表的含义如下：\n\n- E 向量：资源总量\n- A 向量：资源剩余量\n- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量\n- R 矩阵：每个进程请求的资源数量\n\n进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。\n\n```\n初始化所有进程为未标记状态\n设置 A 为可用资源\n\nwhile 存在未标记的进程 Pi，其所请求的资源小于等于 A do\n    将 C 矩阵的第 i 行向量加到 A\n    标记进程 Pi\nend while\n\n检查所有进程，如果存在未被标记的进程，则标记为死锁进程\n```\n\n#### 3. 死锁恢复\n\n- 抢占恢复\n- 回滚恢复\n- 杀死进程恢复\n\n### 死锁预防\n\n程序运行**之前**预防发生死锁，即破坏发生死锁的四个条件。\n\n#### 1. 破坏互斥条件（最难破坏，也有可能无法破坏）\n\n例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。\n\n#### 2. 破坏占有和等待条件\n\n一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。\n\n#### 3. 破坏不可抢占条件\n\n#### 4. 破坏环路等待\n\n给资源统一编号，进程只能按编号顺序来请求资源。\n\n### 死锁避免\n\n程序**运行时**避免发生死锁。（死锁避免其实就是用死锁检测的方法，先检测如果执行了请求，未来的状态是否会发生死锁，然后避免）\n\n#### 1. 安全状态\n\n![image-20240320175712336](operating-systems/image-20240320175712336.png)\n\n图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。\n\n定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。\n\n安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。\n\n#### 2. 单个资源的银行家算法\n\n一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。\n\n![image-20240320175725276](operating-systems/image-20240320175725276.png)\n\n上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。\n\n#### 3. 多个资源的银行家算法\n\n![image-20240320175747301](operating-systems/image-20240320175747301.png)\n\n上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。\n\n检查一个状态是否安全的算法如下：\n\n- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。\n- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。\n- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。\n\n如果一个状态不是安全的，需要拒绝进入这个状态。\n\n## 内存管理\n\n### 虚拟内存\n\n虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。\n\n为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。\n\n从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。\n\n![image-20240320180056054](operating-systems/image-20240320180056054.png)\n\n### 分页系统地址映射\n\n内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。\n\n一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。\n\n下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于**虚拟**地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的**页框**的地址为 （110 000000000100）。少了一位。\n\n![image-20240320180104512](operating-systems/image-20240320180104512.png)\n\n### 页面置换算法\n\n在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。\n\n页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。\n\n页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。\n\n#### 1. 最佳\n\n> OPT, Optimal replacement algorithm\n\n所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。\n\n是一种理论上的算法，因为无法知道一个页面多长时间（未来的时间）不再被访问。\n\n举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：\n\n```\n7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1\n```\n\n开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，看后续页面，7, 0, 1 出现的先后顺序为 0, 1, 7，即页面 7 再次被访问的时间最长。\n\n#### 2. 最近最久未使用\n\n> LRU, Least Recently Used\n\n虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。\n\n为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。\n\n因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。\n\n```\n4，7，0，7，1，0，1，2，1，2，6\n```\n\n下图中最后一个才涉及到页面置换，最久未使用的 4 被移出。\n\n![image-20240320180115680](operating-systems/image-20240320180115680.png)\n\n#### 3. 最近未使用\n\n> NRU, Not Recently Used\n\n每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：\n\n- R=0，M=0\n- R=0，M=1\n- R=1，M=0\n- R=1，M=1\n\n当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。\n\nNRU 优先换出**已经被修改的脏页面**（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。\n\n#### 4. 先进先出\n\n> FIFO, First In First Out\n\n选择换出的页面是最先进入的页面。\n\n该算法会将那些经常被访问的页面换出，导致缺页率升高。\n\n#### 5. 第二次机会算法\n\nFIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：\n\n当页面被访问 (读或写) 时设置该页面的 R 位为 1（说明该页面之前被访问过，获得了复活甲，R = 1）。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0（复活甲掉了），并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。\n\n![image-20240320180128128](operating-systems/image-20240320180128128.png)\n\n#### 6. 时钟\n\n> Clock\n\n第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。\n\n![image-20240320180134569](operating-systems/image-20240320180134569.png)\n\n### 分段（暂无）\n","slug":"operating-systems","published":1,"updated":"2024-03-22T03:36:11.717Z","comments":1,"layout":"post","photos":[],"_id":"clu247pw50015jocgdaui4i6o","content":"<p>转载自：<a href=\"https://github.com/CyC2018/CS-Notes/tree/master\">https://github.com/CyC2018/CS-Notes/tree/master</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"基本特征\"><a href=\"#基本特征\" class=\"headerlink\" title=\"基本特征\"></a>基本特征</h3><h4 id=\"1-并发\"><a href=\"#1-并发\" class=\"headerlink\" title=\"1. 并发\"></a>1. 并发</h4><p>并发指宏观上一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。</p>\n<p>并行需要硬件支持：多流水线、多处理器。</p>\n<p>操作系统引入进程和线程，使程序能够并发运行。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"2-共享\"><a href=\"#2-共享\" class=\"headerlink\" title=\"2. 共享\"></a>2. 共享</h4><p>共享指多个进程同时使用系统资源。</p>\n<p>两种共享：互斥共享和同时共享。</p>\n<p>互斥共享使用的是临界资源，同一时刻只允许一个进程访问，需要用同步机制实现互斥访问。</p>\n<p>同步原语：</p>\n<ul>\n<li>互斥锁</li>\n<li>信号量</li>\n<li>条件变量</li>\n<li>读写锁</li>\n</ul>\n<h4 id=\"3-虚拟\"><a href=\"#3-虚拟\" class=\"headerlink\" title=\"3. 虚拟\"></a>3. 虚拟</h4><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>\n<p>主要有两种虚拟技术：时分复用和空分复用。</p>\n<p>多进程在同一个处理器上并发执行使用了时分复用，轮流占用处理器。</p>\n<p>虚拟内存使用了空分复用，将物理内存抽象为地址空间，每个进程都有自己的地址空间。</p>\n<h4 id=\"4-异步\"><a href=\"#4-异步\" class=\"headerlink\" title=\"4. 异步\"></a>4. 异步</h4><p>异步指进程不是一次性执行完毕，走走停停。</p>\n<p>联想到异步 I&#x2F;O，应用程序执行系统调用会立即返回，可以继续执行，不会被阻塞。内核在完成所有操作后通知应用程序。</p>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><h4 id=\"1-进程管理\"><a href=\"#1-进程管理\" class=\"headerlink\" title=\"1. 进程管理\"></a>1. 进程管理</h4><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>\n<h4 id=\"2-内存管理\"><a href=\"#2-内存管理\" class=\"headerlink\" title=\"2. 内存管理\"></a>2. 内存管理</h4><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>\n<h4 id=\"3-文件管理\"><a href=\"#3-文件管理\" class=\"headerlink\" title=\"3. 文件管理\"></a>3. 文件管理</h4><p>文件存储空间的管理、目录管理、文件读写管理和保护。</p>\n<h4 id=\"4-设备管理\"><a href=\"#4-设备管理\" class=\"headerlink\" title=\"4. 设备管理\"></a>4. 设备管理</h4><p>完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率。</p>\n<p>主要包括缓冲管理、设备分配、设备处理、虚拟设备等。</p>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>一个进程在用户态要用到内核态的功能，就进行系统调用，从而陷入内核，由操作系统代完成。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175407843.png\"></p>\n<p>Linux 的系统调用主要有以下这些（暂不了解）：</p>\n<table>\n<thead>\n<tr>\n<th>Task</th>\n<th>Commands</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>进程控制</td>\n<td>fork(); exit(); wait();</td>\n</tr>\n<tr>\n<td>进程通信</td>\n<td>pipe(); shmget(); mmap();</td>\n</tr>\n<tr>\n<td>文件操作</td>\n<td>open(); read(); write();</td>\n</tr>\n<tr>\n<td>设备操作</td>\n<td>ioctl(); read(); write();</td>\n</tr>\n<tr>\n<td>信息维护</td>\n<td>getpid(); alarm(); sleep();</td>\n</tr>\n<tr>\n<td>安全</td>\n<td>chmod(); umask(); chown();</td>\n</tr>\n</tbody></table>\n<h3 id=\"宏内核和微内核\"><a href=\"#宏内核和微内核\" class=\"headerlink\" title=\"宏内核和微内核\"></a>宏内核和微内核</h3><h4 id=\"1-宏内核\"><a href=\"#1-宏内核\" class=\"headerlink\" title=\"1. 宏内核\"></a>1. 宏内核</h4><p>将操作系统作为紧密结合的整体放到内核。</p>\n<p>由于各模块共享信息，所以性能高。</p>\n<h4 id=\"2-微内核\"><a href=\"#2-微内核\" class=\"headerlink\" title=\"2. 微内核\"></a>2. 微内核</h4><p>将一部分操作系统功能移出内核，降低内核复杂性。移出部分根据分层原则划分为若干服务，相互独立。</p>\n<p>只有微内核运行在内核态，其它模块运行在用户态。</p>\n<p>频繁在用户态和内核态切换，有一定的性能损失。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175421234.png\"></p>\n<h3 id=\"中断分类\"><a href=\"#中断分类\" class=\"headerlink\" title=\"中断分类\"></a>中断分类</h3><h4 id=\"1-外中断\"><a href=\"#1-外中断\" class=\"headerlink\" title=\"1. 外中断\"></a>1. 外中断</h4><p>由 CPU 执行指令以外的事件引起（表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求），如 I&#x2F;O 完成中断、时钟中断、控制台中断等。</p>\n<h4 id=\"2-异常\"><a href=\"#2-异常\" class=\"headerlink\" title=\"2. 异常\"></a>2. 异常</h4><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>\n<h4 id=\"3-陷入\"><a href=\"#3-陷入\" class=\"headerlink\" title=\"3. 陷入\"></a>3. 陷入</h4><p>用户程序使用系统调用。</p>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><h3 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h3><h4 id=\"1-进程\"><a href=\"#1-进程\" class=\"headerlink\" title=\"1. 进程\"></a>1. 进程</h4><p>是资源分配的基本单位。</p>\n<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>\n<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。（时分复用）</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175436050.png\"></p>\n<h4 id=\"2-线程\"><a href=\"#2-线程\" class=\"headerlink\" title=\"2. 线程\"></a>2. 线程</h4><p>是独立调度的基本单位。</p>\n<p>一个进程中可以有多个线程，共享进程资源。（互斥共享、同时共享）</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175446963.png\"></p>\n<p>浏览器是一个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>\n<h4 id=\"3-区别\"><a href=\"#3-区别\" class=\"headerlink\" title=\"3. 区别\"></a>3. 区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th>线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>拥有资源</td>\n<td>进程是资源分配的基本单位，拥有独立的资源</td>\n<td>线程不拥有资源，可以访问隶属进程的资源</td>\n</tr>\n<tr>\n<td>调度</td>\n<td>进程切换会引起线程切换</td>\n<td>线程是独立调度的基本单位，线程的切换不会引起进程切换（指单个进程中的线程切换）</td>\n</tr>\n<tr>\n<td>系统开销</td>\n<td>创建或撤销进程的开销大，需要分配或回收资源，如内存空间、I&#x2F;O 设备等</td>\n<td>创建或撤销线程的开销小，线程切换时只需保存和设置少量寄存器内容</td>\n</tr>\n<tr>\n<td>通信</td>\n<td>进程间通信需要借助 IPC</td>\n<td>线程间可以通过直接读写同一进程中的数据进行通信</td>\n</tr>\n</tbody></table>\n<h3 id=\"进程状态的切换\"><a href=\"#进程状态的切换\" class=\"headerlink\" title=\"进程状态的切换\"></a>进程状态的切换</h3><p><img src=\"/2024/03/20/operating-systems/image-20240320175455259.png\"></p>\n<ul>\n<li>就绪（ready）：等待被调度</li>\n<li>运行（running）</li>\n<li>阻塞（waiting）：等待资源</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>只有就绪和运行可以相互转换，其它都是单向。就绪的进程通过调度算法获得 CPU 时间，转为运行；运行用完分配的 CPU 时间，转为就绪。</li>\n<li>阻塞是运行态缺少资源转换而来，这个资源不包括 CPU 时间。</li>\n</ul>\n<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3><p>因地制宜。</p>\n<h4 id=\"1-批处理系统\"><a href=\"#1-批处理系统\" class=\"headerlink\" title=\"1. 批处理系统\"></a>1. 批处理系统</h4><p>没有太多用户操作，目标是保证吞吐量和周转时间。（从<strong>提交</strong>到终止的时间）</p>\n<h5 id=\"1-1-先来先服务-first-come-first-served（FCFS）\"><a href=\"#1-1-先来先服务-first-come-first-served（FCFS）\" class=\"headerlink\" title=\"1.1 先来先服务 first-come first-served（FCFS）\"></a>1.1 先来先服务 first-come first-served（FCFS）</h5><p>非抢占式，按请求顺序调度。</p>\n<p>不利于短作业，因为要等待前面的长作业执行完毕。</p>\n<h5 id=\"1-2-短作业优先\"><a href=\"#1-2-短作业优先\" class=\"headerlink\" title=\"1.2 短作业优先\"></a>1.2 短作业优先</h5><p>非抢占，按<strong>估计</strong>运行时间最短调度。</p>\n<p>长作业有可能永远得不到调度。</p>\n<h5 id=\"1-3-最短剩余时间有限\"><a href=\"#1-3-最短剩余时间有限\" class=\"headerlink\" title=\"1.3 最短剩余时间有限\"></a>1.3 最短剩余时间有限</h5><p>短作业优先的<strong>抢占式</strong>版本，按<strong>剩余</strong>运行时间最短的顺序进行调度。新作业到达时，会与当前进程剩余时间比较。如果新进程需要时间更少，则挂起当前进程，运行新的进程（抢占）。</p>\n<h4 id=\"2-交互式系统\"><a href=\"#2-交互式系统\" class=\"headerlink\" title=\"2. 交互式系统\"></a>2. 交互式系统</h4><h5 id=\"2-1-时间片轮转\"><a href=\"#2-1-时间片轮转\" class=\"headerlink\" title=\"2.1 时间片轮转\"></a>2.1 时间片轮转</h5><p>所有就绪进程按 FCFS 原则排成队列，CPU 分配时间，轮转执行进程。</p>\n<p>效率和时间片的大小相关：</p>\n<ul>\n<li>时间片太小，导致进程切换频繁，消耗时间。</li>\n<li>时间片太大，实时性得不到保证。</li>\n</ul>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175508729.png\"></p>\n<h5 id=\"2-2-优先级调度\"><a href=\"#2-2-优先级调度\" class=\"headerlink\" title=\"2.2 优先级调度\"></a>2.2 优先级调度</h5><p>为每个进程分配优先级，按优先级调度。</p>\n<p>为防止低优先级进程等不到调度，可随时间推移增加等待进程的优先级。</p>\n<h5 id=\"2-3-多级反馈队列\"><a href=\"#2-3-多级反馈队列\" class=\"headerlink\" title=\"2.3 多级反馈队列\"></a>2.3 多级反馈队列</h5><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>\n<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列（依然是时间片轮转），每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列（降低优先级）。这种方式下，之前的进程只需要交换 7 次。</p>\n<p>只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175525345.png\"></p>\n<h4 id=\"3-实时系统\"><a href=\"#3-实时系统\" class=\"headerlink\" title=\"3. 实时系统\"></a>3. 实时系统</h4><p>要求请求在一个确定时间内得到相应。</p>\n<p>分为硬实时（必须满足绝对的截止时间）和软实时（可以容忍一定的超时）。</p>\n<h3 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h3><h4 id=\"1-临界区（这个词多用于描述多线程）\"><a href=\"#1-临界区（这个词多用于描述多线程）\" class=\"headerlink\" title=\"1. 临界区（这个词多用于描述多线程）\"></a>1. 临界区（这个词多用于描述多线程）</h4><p>对临界资源进行访问的代码称为临界区。</p>\n<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry section</span><br><span class=\"line\">// critical section; 只有这一部分是临界区</span><br><span class=\"line\">// exit section</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-同步与互斥\"><a href=\"#2-同步与互斥\" class=\"headerlink\" title=\"2. 同步与互斥\"></a>2. 同步与互斥</h4><ul>\n<li>同步：多进程因合作产生的直接制约关系，使进程有一定的先后执行顺序。</li>\n<li>互斥：多进程在同一时刻只能有一个进程进入临界区。</li>\n</ul>\n<h4 id=\"3-信号量\"><a href=\"#3-信号量\" class=\"headerlink\" title=\"3. 信号量\"></a>3. 信号量</h4><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>\n<ul>\n<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0（此时还未进入临界区）；</li>\n<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>\n</ul>\n<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>\n<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int semaphore;</span><br><span class=\"line\">semaphore mutex = 1;</span><br><span class=\"line\">void P1() &#123;</span><br><span class=\"line\">    down(&amp;mutex);</span><br><span class=\"line\">    // 临界区</span><br><span class=\"line\">    up(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void P2() &#123;</span><br><span class=\"line\">    down(&amp;mutex);</span><br><span class=\"line\">    // 临界区</span><br><span class=\"line\">    up(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用信号量实现生产者-消费者问题</strong></p>\n<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>\n<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>\n<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>\n<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty &#x3D; 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define N 100</span><br><span class=\"line\">typedef int semaphore;</span><br><span class=\"line\">semaphore mutex = 1;</span><br><span class=\"line\">semaphore empty = N;</span><br><span class=\"line\">semaphore full = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">void producer() &#123;</span><br><span class=\"line\">    while(TRUE) &#123;</span><br><span class=\"line\">        int item = produce_item();</span><br><span class=\"line\">        down(&amp;empty); // 注意，empty和mutex的顺序不能颠倒</span><br><span class=\"line\">        down(&amp;mutex);</span><br><span class=\"line\">        insert_item(item);</span><br><span class=\"line\">        up(&amp;mutex);</span><br><span class=\"line\">        up(&amp;full);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void consumer() &#123;</span><br><span class=\"line\">    while(TRUE) &#123;</span><br><span class=\"line\">        down(&amp;full);</span><br><span class=\"line\">        down(&amp;mutex);</span><br><span class=\"line\">        int item = remove_item();</span><br><span class=\"line\">        consume_item(item);</span><br><span class=\"line\">        up(&amp;mutex);</span><br><span class=\"line\">        up(&amp;empty);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-管程\"><a href=\"#4-管程\" class=\"headerlink\" title=\"4. 管程\"></a>4. 管程</h4><p>信号量机制需要客户端代码做很多控制，管程把控制的代码独立出来，客户端只需要调用方法。</p>\n<p>一个时刻只能有一个进程使用管程。进程无法执行时不能一直占用管程。</p>\n<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>\n<h3 id=\"经典同步问题\"><a href=\"#经典同步问题\" class=\"headerlink\" title=\"经典同步问题\"></a>经典同步问题</h3><h4 id=\"1-哲学家进餐问题\"><a href=\"#1-哲学家进餐问题\" class=\"headerlink\" title=\"1. 哲学家进餐问题\"></a>1. 哲学家进餐问题</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175548861.png\"></p>\n<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>\n<p>为了防止死锁：</p>\n<ul>\n<li>必须同时拿起左右两根筷子；</li>\n<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>\n</ul>\n<h4 id=\"2-读者-写者问题\"><a href=\"#2-读者-写者问题\" class=\"headerlink\" title=\"2. 读者-写者问题\"></a>2. 读者-写者问题</h4><p>允许多进程同时对数据进行读操作，不能同时读写，也不能同时写。</p>\n<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>\n<p>写者只需要使用 data_mutex 对写的数据加锁。</p>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><p>进程同步和进程通信的区别：</p>\n<ul>\n<li>同步：控制多进程按一定顺序执行。</li>\n<li>通信：进程间传输消息。</li>\n</ul>\n<p>通信是手段，同步是目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>\n<h4 id=\"1-管道\"><a href=\"#1-管道\" class=\"headerlink\" title=\"1. 管道\"></a>1. 管道</h4><ul>\n<li>半双工通信。</li>\n<li>只能在父子进程或兄弟进程中使用。</li>\n</ul>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175601947.png\"></p>\n<h4 id=\"2-FIFO\"><a href=\"#2-FIFO\" class=\"headerlink\" title=\"2. FIFO\"></a>2. FIFO</h4><p>命名管道，去除了管道只能在父子进程中使用的限制。</p>\n<p>常用于 C-S 中。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175609777.png\"></p>\n<h4 id=\"3-消息队列\"><a href=\"#3-消息队列\" class=\"headerlink\" title=\"3. 消息队列\"></a>3. 消息队列</h4><p>相比于 FIFO，消息队列具有以下优点：</p>\n<ul>\n<li>消息队列可以独立于读写进程存在（作为一个独立的实体存在，不依赖于创建它的进程），从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>\n<li>避免了 FIFO 的同步阻塞问题（进程可以立即返回并执行其他操作，而不是等待队列可以执行。发送者可以快速地把消息放入队列然后继续执行其他任务，而不需要等待接收者处理消息），不需要进程自己提供同步方法；</li>\n<li>读进程可以根据消息类型有选择地接收消息（如只接收优先级最高的消息），而不像 FIFO 那样只能默认地接收（严格按照写入的顺序）。</li>\n</ul>\n<h4 id=\"4-信号量\"><a href=\"#4-信号量\" class=\"headerlink\" title=\"4. 信号量\"></a>4. 信号量</h4><p>计数器。</p>\n<p>在进程间通信的情境下，信号量可以用来传递信息或者是信号。一个进程可以通过增加信号量值来向其他进程发送一个信号，其他进程可以通过检查信号量值来接收这个信号。</p>\n<p>和进程同步中的信号量是同一种机制，但是使用方式和目的有所不同。</p>\n<h4 id=\"5-共享存储\"><a href=\"#5-共享存储\" class=\"headerlink\" title=\"5. 共享存储\"></a>5. 共享存储</h4><p>允许多个进程共享一个给定的存储区。这是最快的一种 IPC。</p>\n<p>需要用信号量来同步对共享存储的访问。</p>\n<h4 id=\"6-套接字\"><a href=\"#6-套接字\" class=\"headerlink\" title=\"6. 套接字\"></a>6. 套接字</h4><p>可用于不同机器间的进程通信。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><h3 id=\"必要条件\"><a href=\"#必要条件\" class=\"headerlink\" title=\"必要条件\"></a>必要条件</h3><p><img src=\"/2024/03/20/operating-systems/image-20240320175633047.png\"></p>\n<ul>\n<li>互斥：资源要么被分配给一个进程，要么可用。</li>\n<li>占有和等待：已得到某个资源的进程，可以继续请求新的资源。</li>\n<li>不可抢占：资源只能被占有它的进程显式释放。</li>\n<li>环路等待：两个及以上的进程组成环路，该环路中每个进程都在等待下一个进程占有的资源。</li>\n</ul>\n<h3 id=\"处理方法\"><a href=\"#处理方法\" class=\"headerlink\" title=\"处理方法\"></a>处理方法</h3><p>主要有四种：</p>\n<ul>\n<li>鸵鸟策略</li>\n<li>死锁检测与死锁恢复</li>\n<li>死锁预防</li>\n<li>死锁避免</li>\n</ul>\n<h3 id=\"鸵鸟策略\"><a href=\"#鸵鸟策略\" class=\"headerlink\" title=\"鸵鸟策略\"></a>鸵鸟策略</h3><p>锁了就是锁了？假装根本没发生死锁。</p>\n<p>解决死锁代价很高，这种方案会获得很高的性能。</p>\n<p>当死锁对用户不会造成多大的影响，或死锁发生的概率很低时，可采取。</p>\n<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>\n<h3 id=\"死锁检测与死锁恢复\"><a href=\"#死锁检测与死锁恢复\" class=\"headerlink\" title=\"死锁检测与死锁恢复\"></a>死锁检测与死锁恢复</h3><p>不阻止，检测到死锁发生时，采取措施恢复。</p>\n<h4 id=\"1-每种类型一个资源的死锁检测\"><a href=\"#1-每种类型一个资源的死锁检测\" class=\"headerlink\" title=\"1. 每种类型一个资源的死锁检测\"></a>1. 每种类型一个资源的死锁检测</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175638377.png\"></p>\n<p>圆圈表示进程，方框表示资源。进程指向资源表示进程请求获取该资源，反之表示进程已经占有该资源。</p>\n<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>\n<p>每种类型<strong>一个资源</strong>的死锁检测算法是通过检测<strong>有向图是否存在环</strong>来实现，从一个节点出发进行 dfs，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>\n<h4 id=\"2-每种类型多个资源的死锁检测\"><a href=\"#2-每种类型多个资源的死锁检测\" class=\"headerlink\" title=\"2. 每种类型多个资源的死锁检测\"></a>2. 每种类型多个资源的死锁检测</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175649285.png\"></p>\n<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>\n<ul>\n<li>E 向量：资源总量</li>\n<li>A 向量：资源剩余量</li>\n<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>\n<li>R 矩阵：每个进程请求的资源数量</li>\n</ul>\n<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始化所有进程为未标记状态</span><br><span class=\"line\">设置 A 为可用资源</span><br><span class=\"line\"></span><br><span class=\"line\">while 存在未标记的进程 Pi，其所请求的资源小于等于 A do</span><br><span class=\"line\">    将 C 矩阵的第 i 行向量加到 A</span><br><span class=\"line\">    标记进程 Pi</span><br><span class=\"line\">end while</span><br><span class=\"line\"></span><br><span class=\"line\">检查所有进程，如果存在未被标记的进程，则标记为死锁进程</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-死锁恢复\"><a href=\"#3-死锁恢复\" class=\"headerlink\" title=\"3. 死锁恢复\"></a>3. 死锁恢复</h4><ul>\n<li>抢占恢复</li>\n<li>回滚恢复</li>\n<li>杀死进程恢复</li>\n</ul>\n<h3 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"死锁预防\"></a>死锁预防</h3><p>程序运行<strong>之前</strong>预防发生死锁，即破坏发生死锁的四个条件。</p>\n<h4 id=\"1-破坏互斥条件（最难破坏，也有可能无法破坏）\"><a href=\"#1-破坏互斥条件（最难破坏，也有可能无法破坏）\" class=\"headerlink\" title=\"1. 破坏互斥条件（最难破坏，也有可能无法破坏）\"></a>1. 破坏互斥条件（最难破坏，也有可能无法破坏）</h4><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>\n<h4 id=\"2-破坏占有和等待条件\"><a href=\"#2-破坏占有和等待条件\" class=\"headerlink\" title=\"2. 破坏占有和等待条件\"></a>2. 破坏占有和等待条件</h4><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>\n<h4 id=\"3-破坏不可抢占条件\"><a href=\"#3-破坏不可抢占条件\" class=\"headerlink\" title=\"3. 破坏不可抢占条件\"></a>3. 破坏不可抢占条件</h4><h4 id=\"4-破坏环路等待\"><a href=\"#4-破坏环路等待\" class=\"headerlink\" title=\"4. 破坏环路等待\"></a>4. 破坏环路等待</h4><p>给资源统一编号，进程只能按编号顺序来请求资源。</p>\n<h3 id=\"死锁避免\"><a href=\"#死锁避免\" class=\"headerlink\" title=\"死锁避免\"></a>死锁避免</h3><p>程序<strong>运行时</strong>避免发生死锁。（死锁避免其实就是用死锁检测的方法，先检测如果执行了请求，未来的状态是否会发生死锁，然后避免）</p>\n<h4 id=\"1-安全状态\"><a href=\"#1-安全状态\" class=\"headerlink\" title=\"1. 安全状态\"></a>1. 安全状态</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175712336.png\"></p>\n<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>\n<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>\n<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>\n<h4 id=\"2-单个资源的银行家算法\"><a href=\"#2-单个资源的银行家算法\" class=\"headerlink\" title=\"2. 单个资源的银行家算法\"></a>2. 单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175725276.png\"></p>\n<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>\n<h4 id=\"3-多个资源的银行家算法\"><a href=\"#3-多个资源的银行家算法\" class=\"headerlink\" title=\"3. 多个资源的银行家算法\"></a>3. 多个资源的银行家算法</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175747301.png\"></p>\n<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p>\n<p>检查一个状态是否安全的算法如下：</p>\n<ul>\n<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>\n<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>\n<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>\n</ul>\n<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>\n<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>\n<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180056054.png\"></p>\n<h3 id=\"分页系统地址映射\"><a href=\"#分页系统地址映射\" class=\"headerlink\" title=\"分页系统地址映射\"></a>分页系统地址映射</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>\n<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>\n<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于<strong>虚拟</strong>地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的<strong>页框</strong>的地址为 （110 000000000100）。少了一位。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180104512.png\"></p>\n<h3 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>\n<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>\n<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>\n<h4 id=\"1-最佳\"><a href=\"#1-最佳\" class=\"headerlink\" title=\"1. 最佳\"></a>1. 最佳</h4><blockquote>\n<p>OPT, Optimal replacement algorithm</p>\n</blockquote>\n<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>\n<p>是一种理论上的算法，因为无法知道一个页面多长时间（未来的时间）不再被访问。</p>\n<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure>\n\n<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，看后续页面，7, 0, 1 出现的先后顺序为 0, 1, 7，即页面 7 再次被访问的时间最长。</p>\n<h4 id=\"2-最近最久未使用\"><a href=\"#2-最近最久未使用\" class=\"headerlink\" title=\"2. 最近最久未使用\"></a>2. 最近最久未使用</h4><blockquote>\n<p>LRU, Least Recently Used</p>\n</blockquote>\n<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>\n<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>\n<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure>\n\n<p>下图中最后一个才涉及到页面置换，最久未使用的 4 被移出。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180115680.png\"></p>\n<h4 id=\"3-最近未使用\"><a href=\"#3-最近未使用\" class=\"headerlink\" title=\"3. 最近未使用\"></a>3. 最近未使用</h4><blockquote>\n<p>NRU, Not Recently Used</p>\n</blockquote>\n<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R&#x3D;1，当页面被修改时设置 M&#x3D;1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>\n<ul>\n<li>R&#x3D;0，M&#x3D;0</li>\n<li>R&#x3D;0，M&#x3D;1</li>\n<li>R&#x3D;1，M&#x3D;0</li>\n<li>R&#x3D;1，M&#x3D;1</li>\n</ul>\n<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>\n<p>NRU 优先换出<strong>已经被修改的脏页面</strong>（R&#x3D;0，M&#x3D;1），而不是被频繁使用的干净页面（R&#x3D;1，M&#x3D;0）。</p>\n<h4 id=\"4-先进先出\"><a href=\"#4-先进先出\" class=\"headerlink\" title=\"4. 先进先出\"></a>4. 先进先出</h4><blockquote>\n<p>FIFO, First In First Out</p>\n</blockquote>\n<p>选择换出的页面是最先进入的页面。</p>\n<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>\n<h4 id=\"5-第二次机会算法\"><a href=\"#5-第二次机会算法\" class=\"headerlink\" title=\"5. 第二次机会算法\"></a>5. 第二次机会算法</h4><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>\n<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1（说明该页面之前被访问过，获得了复活甲，R &#x3D; 1）。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0（复活甲掉了），并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180128128.png\"></p>\n<h4 id=\"6-时钟\"><a href=\"#6-时钟\" class=\"headerlink\" title=\"6. 时钟\"></a>6. 时钟</h4><blockquote>\n<p>Clock</p>\n</blockquote>\n<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180134569.png\"></p>\n<h3 id=\"分段（暂无）\"><a href=\"#分段（暂无）\" class=\"headerlink\" title=\"分段（暂无）\"></a>分段（暂无）</h3>","excerpt":"<p>转载自：<a href=\"https://github.com/CyC2018/CS-Notes/tree/master\">https://github.com/CyC2018/CS-Notes/tree/master</a></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"基本特征\"><a href=\"#基本特征\" class=\"headerlink\" title=\"基本特征\"></a>基本特征</h3><h4 id=\"1-并发\"><a href=\"#1-并发\" class=\"headerlink\" title=\"1. 并发\"></a>1. 并发</h4><p>并发指宏观上一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。</p>\n<p>并行需要硬件支持：多流水线、多处理器。</p>\n<p>操作系统引入进程和线程，使程序能够并发运行。</p>","more":"<h4 id=\"2-共享\"><a href=\"#2-共享\" class=\"headerlink\" title=\"2. 共享\"></a>2. 共享</h4><p>共享指多个进程同时使用系统资源。</p>\n<p>两种共享：互斥共享和同时共享。</p>\n<p>互斥共享使用的是临界资源，同一时刻只允许一个进程访问，需要用同步机制实现互斥访问。</p>\n<p>同步原语：</p>\n<ul>\n<li>互斥锁</li>\n<li>信号量</li>\n<li>条件变量</li>\n<li>读写锁</li>\n</ul>\n<h4 id=\"3-虚拟\"><a href=\"#3-虚拟\" class=\"headerlink\" title=\"3. 虚拟\"></a>3. 虚拟</h4><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>\n<p>主要有两种虚拟技术：时分复用和空分复用。</p>\n<p>多进程在同一个处理器上并发执行使用了时分复用，轮流占用处理器。</p>\n<p>虚拟内存使用了空分复用，将物理内存抽象为地址空间，每个进程都有自己的地址空间。</p>\n<h4 id=\"4-异步\"><a href=\"#4-异步\" class=\"headerlink\" title=\"4. 异步\"></a>4. 异步</h4><p>异步指进程不是一次性执行完毕，走走停停。</p>\n<p>联想到异步 I&#x2F;O，应用程序执行系统调用会立即返回，可以继续执行，不会被阻塞。内核在完成所有操作后通知应用程序。</p>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><h4 id=\"1-进程管理\"><a href=\"#1-进程管理\" class=\"headerlink\" title=\"1. 进程管理\"></a>1. 进程管理</h4><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>\n<h4 id=\"2-内存管理\"><a href=\"#2-内存管理\" class=\"headerlink\" title=\"2. 内存管理\"></a>2. 内存管理</h4><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>\n<h4 id=\"3-文件管理\"><a href=\"#3-文件管理\" class=\"headerlink\" title=\"3. 文件管理\"></a>3. 文件管理</h4><p>文件存储空间的管理、目录管理、文件读写管理和保护。</p>\n<h4 id=\"4-设备管理\"><a href=\"#4-设备管理\" class=\"headerlink\" title=\"4. 设备管理\"></a>4. 设备管理</h4><p>完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率。</p>\n<p>主要包括缓冲管理、设备分配、设备处理、虚拟设备等。</p>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>一个进程在用户态要用到内核态的功能，就进行系统调用，从而陷入内核，由操作系统代完成。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175407843.png\"></p>\n<p>Linux 的系统调用主要有以下这些（暂不了解）：</p>\n<table>\n<thead>\n<tr>\n<th>Task</th>\n<th>Commands</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>进程控制</td>\n<td>fork(); exit(); wait();</td>\n</tr>\n<tr>\n<td>进程通信</td>\n<td>pipe(); shmget(); mmap();</td>\n</tr>\n<tr>\n<td>文件操作</td>\n<td>open(); read(); write();</td>\n</tr>\n<tr>\n<td>设备操作</td>\n<td>ioctl(); read(); write();</td>\n</tr>\n<tr>\n<td>信息维护</td>\n<td>getpid(); alarm(); sleep();</td>\n</tr>\n<tr>\n<td>安全</td>\n<td>chmod(); umask(); chown();</td>\n</tr>\n</tbody></table>\n<h3 id=\"宏内核和微内核\"><a href=\"#宏内核和微内核\" class=\"headerlink\" title=\"宏内核和微内核\"></a>宏内核和微内核</h3><h4 id=\"1-宏内核\"><a href=\"#1-宏内核\" class=\"headerlink\" title=\"1. 宏内核\"></a>1. 宏内核</h4><p>将操作系统作为紧密结合的整体放到内核。</p>\n<p>由于各模块共享信息，所以性能高。</p>\n<h4 id=\"2-微内核\"><a href=\"#2-微内核\" class=\"headerlink\" title=\"2. 微内核\"></a>2. 微内核</h4><p>将一部分操作系统功能移出内核，降低内核复杂性。移出部分根据分层原则划分为若干服务，相互独立。</p>\n<p>只有微内核运行在内核态，其它模块运行在用户态。</p>\n<p>频繁在用户态和内核态切换，有一定的性能损失。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175421234.png\"></p>\n<h3 id=\"中断分类\"><a href=\"#中断分类\" class=\"headerlink\" title=\"中断分类\"></a>中断分类</h3><h4 id=\"1-外中断\"><a href=\"#1-外中断\" class=\"headerlink\" title=\"1. 外中断\"></a>1. 外中断</h4><p>由 CPU 执行指令以外的事件引起（表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求），如 I&#x2F;O 完成中断、时钟中断、控制台中断等。</p>\n<h4 id=\"2-异常\"><a href=\"#2-异常\" class=\"headerlink\" title=\"2. 异常\"></a>2. 异常</h4><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>\n<h4 id=\"3-陷入\"><a href=\"#3-陷入\" class=\"headerlink\" title=\"3. 陷入\"></a>3. 陷入</h4><p>用户程序使用系统调用。</p>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><h3 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h3><h4 id=\"1-进程\"><a href=\"#1-进程\" class=\"headerlink\" title=\"1. 进程\"></a>1. 进程</h4><p>是资源分配的基本单位。</p>\n<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>\n<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。（时分复用）</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175436050.png\"></p>\n<h4 id=\"2-线程\"><a href=\"#2-线程\" class=\"headerlink\" title=\"2. 线程\"></a>2. 线程</h4><p>是独立调度的基本单位。</p>\n<p>一个进程中可以有多个线程，共享进程资源。（互斥共享、同时共享）</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175446963.png\"></p>\n<p>浏览器是一个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>\n<h4 id=\"3-区别\"><a href=\"#3-区别\" class=\"headerlink\" title=\"3. 区别\"></a>3. 区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th>线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>拥有资源</td>\n<td>进程是资源分配的基本单位，拥有独立的资源</td>\n<td>线程不拥有资源，可以访问隶属进程的资源</td>\n</tr>\n<tr>\n<td>调度</td>\n<td>进程切换会引起线程切换</td>\n<td>线程是独立调度的基本单位，线程的切换不会引起进程切换（指单个进程中的线程切换）</td>\n</tr>\n<tr>\n<td>系统开销</td>\n<td>创建或撤销进程的开销大，需要分配或回收资源，如内存空间、I&#x2F;O 设备等</td>\n<td>创建或撤销线程的开销小，线程切换时只需保存和设置少量寄存器内容</td>\n</tr>\n<tr>\n<td>通信</td>\n<td>进程间通信需要借助 IPC</td>\n<td>线程间可以通过直接读写同一进程中的数据进行通信</td>\n</tr>\n</tbody></table>\n<h3 id=\"进程状态的切换\"><a href=\"#进程状态的切换\" class=\"headerlink\" title=\"进程状态的切换\"></a>进程状态的切换</h3><p><img src=\"/2024/03/20/operating-systems/image-20240320175455259.png\"></p>\n<ul>\n<li>就绪（ready）：等待被调度</li>\n<li>运行（running）</li>\n<li>阻塞（waiting）：等待资源</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>只有就绪和运行可以相互转换，其它都是单向。就绪的进程通过调度算法获得 CPU 时间，转为运行；运行用完分配的 CPU 时间，转为就绪。</li>\n<li>阻塞是运行态缺少资源转换而来，这个资源不包括 CPU 时间。</li>\n</ul>\n<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3><p>因地制宜。</p>\n<h4 id=\"1-批处理系统\"><a href=\"#1-批处理系统\" class=\"headerlink\" title=\"1. 批处理系统\"></a>1. 批处理系统</h4><p>没有太多用户操作，目标是保证吞吐量和周转时间。（从<strong>提交</strong>到终止的时间）</p>\n<h5 id=\"1-1-先来先服务-first-come-first-served（FCFS）\"><a href=\"#1-1-先来先服务-first-come-first-served（FCFS）\" class=\"headerlink\" title=\"1.1 先来先服务 first-come first-served（FCFS）\"></a>1.1 先来先服务 first-come first-served（FCFS）</h5><p>非抢占式，按请求顺序调度。</p>\n<p>不利于短作业，因为要等待前面的长作业执行完毕。</p>\n<h5 id=\"1-2-短作业优先\"><a href=\"#1-2-短作业优先\" class=\"headerlink\" title=\"1.2 短作业优先\"></a>1.2 短作业优先</h5><p>非抢占，按<strong>估计</strong>运行时间最短调度。</p>\n<p>长作业有可能永远得不到调度。</p>\n<h5 id=\"1-3-最短剩余时间有限\"><a href=\"#1-3-最短剩余时间有限\" class=\"headerlink\" title=\"1.3 最短剩余时间有限\"></a>1.3 最短剩余时间有限</h5><p>短作业优先的<strong>抢占式</strong>版本，按<strong>剩余</strong>运行时间最短的顺序进行调度。新作业到达时，会与当前进程剩余时间比较。如果新进程需要时间更少，则挂起当前进程，运行新的进程（抢占）。</p>\n<h4 id=\"2-交互式系统\"><a href=\"#2-交互式系统\" class=\"headerlink\" title=\"2. 交互式系统\"></a>2. 交互式系统</h4><h5 id=\"2-1-时间片轮转\"><a href=\"#2-1-时间片轮转\" class=\"headerlink\" title=\"2.1 时间片轮转\"></a>2.1 时间片轮转</h5><p>所有就绪进程按 FCFS 原则排成队列，CPU 分配时间，轮转执行进程。</p>\n<p>效率和时间片的大小相关：</p>\n<ul>\n<li>时间片太小，导致进程切换频繁，消耗时间。</li>\n<li>时间片太大，实时性得不到保证。</li>\n</ul>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175508729.png\"></p>\n<h5 id=\"2-2-优先级调度\"><a href=\"#2-2-优先级调度\" class=\"headerlink\" title=\"2.2 优先级调度\"></a>2.2 优先级调度</h5><p>为每个进程分配优先级，按优先级调度。</p>\n<p>为防止低优先级进程等不到调度，可随时间推移增加等待进程的优先级。</p>\n<h5 id=\"2-3-多级反馈队列\"><a href=\"#2-3-多级反馈队列\" class=\"headerlink\" title=\"2.3 多级反馈队列\"></a>2.3 多级反馈队列</h5><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>\n<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列（依然是时间片轮转），每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列（降低优先级）。这种方式下，之前的进程只需要交换 7 次。</p>\n<p>只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175525345.png\"></p>\n<h4 id=\"3-实时系统\"><a href=\"#3-实时系统\" class=\"headerlink\" title=\"3. 实时系统\"></a>3. 实时系统</h4><p>要求请求在一个确定时间内得到相应。</p>\n<p>分为硬实时（必须满足绝对的截止时间）和软实时（可以容忍一定的超时）。</p>\n<h3 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h3><h4 id=\"1-临界区（这个词多用于描述多线程）\"><a href=\"#1-临界区（这个词多用于描述多线程）\" class=\"headerlink\" title=\"1. 临界区（这个词多用于描述多线程）\"></a>1. 临界区（这个词多用于描述多线程）</h4><p>对临界资源进行访问的代码称为临界区。</p>\n<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry section</span><br><span class=\"line\">// critical section; 只有这一部分是临界区</span><br><span class=\"line\">// exit section</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-同步与互斥\"><a href=\"#2-同步与互斥\" class=\"headerlink\" title=\"2. 同步与互斥\"></a>2. 同步与互斥</h4><ul>\n<li>同步：多进程因合作产生的直接制约关系，使进程有一定的先后执行顺序。</li>\n<li>互斥：多进程在同一时刻只能有一个进程进入临界区。</li>\n</ul>\n<h4 id=\"3-信号量\"><a href=\"#3-信号量\" class=\"headerlink\" title=\"3. 信号量\"></a>3. 信号量</h4><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>\n<ul>\n<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0（此时还未进入临界区）；</li>\n<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>\n</ul>\n<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>\n<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int semaphore;</span><br><span class=\"line\">semaphore mutex = 1;</span><br><span class=\"line\">void P1() &#123;</span><br><span class=\"line\">    down(&amp;mutex);</span><br><span class=\"line\">    // 临界区</span><br><span class=\"line\">    up(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void P2() &#123;</span><br><span class=\"line\">    down(&amp;mutex);</span><br><span class=\"line\">    // 临界区</span><br><span class=\"line\">    up(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用信号量实现生产者-消费者问题</strong></p>\n<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>\n<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>\n<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>\n<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty &#x3D; 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define N 100</span><br><span class=\"line\">typedef int semaphore;</span><br><span class=\"line\">semaphore mutex = 1;</span><br><span class=\"line\">semaphore empty = N;</span><br><span class=\"line\">semaphore full = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">void producer() &#123;</span><br><span class=\"line\">    while(TRUE) &#123;</span><br><span class=\"line\">        int item = produce_item();</span><br><span class=\"line\">        down(&amp;empty); // 注意，empty和mutex的顺序不能颠倒</span><br><span class=\"line\">        down(&amp;mutex);</span><br><span class=\"line\">        insert_item(item);</span><br><span class=\"line\">        up(&amp;mutex);</span><br><span class=\"line\">        up(&amp;full);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void consumer() &#123;</span><br><span class=\"line\">    while(TRUE) &#123;</span><br><span class=\"line\">        down(&amp;full);</span><br><span class=\"line\">        down(&amp;mutex);</span><br><span class=\"line\">        int item = remove_item();</span><br><span class=\"line\">        consume_item(item);</span><br><span class=\"line\">        up(&amp;mutex);</span><br><span class=\"line\">        up(&amp;empty);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-管程\"><a href=\"#4-管程\" class=\"headerlink\" title=\"4. 管程\"></a>4. 管程</h4><p>信号量机制需要客户端代码做很多控制，管程把控制的代码独立出来，客户端只需要调用方法。</p>\n<p>一个时刻只能有一个进程使用管程。进程无法执行时不能一直占用管程。</p>\n<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>\n<h3 id=\"经典同步问题\"><a href=\"#经典同步问题\" class=\"headerlink\" title=\"经典同步问题\"></a>经典同步问题</h3><h4 id=\"1-哲学家进餐问题\"><a href=\"#1-哲学家进餐问题\" class=\"headerlink\" title=\"1. 哲学家进餐问题\"></a>1. 哲学家进餐问题</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175548861.png\"></p>\n<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>\n<p>为了防止死锁：</p>\n<ul>\n<li>必须同时拿起左右两根筷子；</li>\n<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>\n</ul>\n<h4 id=\"2-读者-写者问题\"><a href=\"#2-读者-写者问题\" class=\"headerlink\" title=\"2. 读者-写者问题\"></a>2. 读者-写者问题</h4><p>允许多进程同时对数据进行读操作，不能同时读写，也不能同时写。</p>\n<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>\n<p>写者只需要使用 data_mutex 对写的数据加锁。</p>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><p>进程同步和进程通信的区别：</p>\n<ul>\n<li>同步：控制多进程按一定顺序执行。</li>\n<li>通信：进程间传输消息。</li>\n</ul>\n<p>通信是手段，同步是目的。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>\n<h4 id=\"1-管道\"><a href=\"#1-管道\" class=\"headerlink\" title=\"1. 管道\"></a>1. 管道</h4><ul>\n<li>半双工通信。</li>\n<li>只能在父子进程或兄弟进程中使用。</li>\n</ul>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175601947.png\"></p>\n<h4 id=\"2-FIFO\"><a href=\"#2-FIFO\" class=\"headerlink\" title=\"2. FIFO\"></a>2. FIFO</h4><p>命名管道，去除了管道只能在父子进程中使用的限制。</p>\n<p>常用于 C-S 中。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175609777.png\"></p>\n<h4 id=\"3-消息队列\"><a href=\"#3-消息队列\" class=\"headerlink\" title=\"3. 消息队列\"></a>3. 消息队列</h4><p>相比于 FIFO，消息队列具有以下优点：</p>\n<ul>\n<li>消息队列可以独立于读写进程存在（作为一个独立的实体存在，不依赖于创建它的进程），从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>\n<li>避免了 FIFO 的同步阻塞问题（进程可以立即返回并执行其他操作，而不是等待队列可以执行。发送者可以快速地把消息放入队列然后继续执行其他任务，而不需要等待接收者处理消息），不需要进程自己提供同步方法；</li>\n<li>读进程可以根据消息类型有选择地接收消息（如只接收优先级最高的消息），而不像 FIFO 那样只能默认地接收（严格按照写入的顺序）。</li>\n</ul>\n<h4 id=\"4-信号量\"><a href=\"#4-信号量\" class=\"headerlink\" title=\"4. 信号量\"></a>4. 信号量</h4><p>计数器。</p>\n<p>在进程间通信的情境下，信号量可以用来传递信息或者是信号。一个进程可以通过增加信号量值来向其他进程发送一个信号，其他进程可以通过检查信号量值来接收这个信号。</p>\n<p>和进程同步中的信号量是同一种机制，但是使用方式和目的有所不同。</p>\n<h4 id=\"5-共享存储\"><a href=\"#5-共享存储\" class=\"headerlink\" title=\"5. 共享存储\"></a>5. 共享存储</h4><p>允许多个进程共享一个给定的存储区。这是最快的一种 IPC。</p>\n<p>需要用信号量来同步对共享存储的访问。</p>\n<h4 id=\"6-套接字\"><a href=\"#6-套接字\" class=\"headerlink\" title=\"6. 套接字\"></a>6. 套接字</h4><p>可用于不同机器间的进程通信。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><h3 id=\"必要条件\"><a href=\"#必要条件\" class=\"headerlink\" title=\"必要条件\"></a>必要条件</h3><p><img src=\"/2024/03/20/operating-systems/image-20240320175633047.png\"></p>\n<ul>\n<li>互斥：资源要么被分配给一个进程，要么可用。</li>\n<li>占有和等待：已得到某个资源的进程，可以继续请求新的资源。</li>\n<li>不可抢占：资源只能被占有它的进程显式释放。</li>\n<li>环路等待：两个及以上的进程组成环路，该环路中每个进程都在等待下一个进程占有的资源。</li>\n</ul>\n<h3 id=\"处理方法\"><a href=\"#处理方法\" class=\"headerlink\" title=\"处理方法\"></a>处理方法</h3><p>主要有四种：</p>\n<ul>\n<li>鸵鸟策略</li>\n<li>死锁检测与死锁恢复</li>\n<li>死锁预防</li>\n<li>死锁避免</li>\n</ul>\n<h3 id=\"鸵鸟策略\"><a href=\"#鸵鸟策略\" class=\"headerlink\" title=\"鸵鸟策略\"></a>鸵鸟策略</h3><p>锁了就是锁了？假装根本没发生死锁。</p>\n<p>解决死锁代价很高，这种方案会获得很高的性能。</p>\n<p>当死锁对用户不会造成多大的影响，或死锁发生的概率很低时，可采取。</p>\n<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>\n<h3 id=\"死锁检测与死锁恢复\"><a href=\"#死锁检测与死锁恢复\" class=\"headerlink\" title=\"死锁检测与死锁恢复\"></a>死锁检测与死锁恢复</h3><p>不阻止，检测到死锁发生时，采取措施恢复。</p>\n<h4 id=\"1-每种类型一个资源的死锁检测\"><a href=\"#1-每种类型一个资源的死锁检测\" class=\"headerlink\" title=\"1. 每种类型一个资源的死锁检测\"></a>1. 每种类型一个资源的死锁检测</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175638377.png\"></p>\n<p>圆圈表示进程，方框表示资源。进程指向资源表示进程请求获取该资源，反之表示进程已经占有该资源。</p>\n<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>\n<p>每种类型<strong>一个资源</strong>的死锁检测算法是通过检测<strong>有向图是否存在环</strong>来实现，从一个节点出发进行 dfs，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>\n<h4 id=\"2-每种类型多个资源的死锁检测\"><a href=\"#2-每种类型多个资源的死锁检测\" class=\"headerlink\" title=\"2. 每种类型多个资源的死锁检测\"></a>2. 每种类型多个资源的死锁检测</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175649285.png\"></p>\n<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>\n<ul>\n<li>E 向量：资源总量</li>\n<li>A 向量：资源剩余量</li>\n<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>\n<li>R 矩阵：每个进程请求的资源数量</li>\n</ul>\n<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始化所有进程为未标记状态</span><br><span class=\"line\">设置 A 为可用资源</span><br><span class=\"line\"></span><br><span class=\"line\">while 存在未标记的进程 Pi，其所请求的资源小于等于 A do</span><br><span class=\"line\">    将 C 矩阵的第 i 行向量加到 A</span><br><span class=\"line\">    标记进程 Pi</span><br><span class=\"line\">end while</span><br><span class=\"line\"></span><br><span class=\"line\">检查所有进程，如果存在未被标记的进程，则标记为死锁进程</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-死锁恢复\"><a href=\"#3-死锁恢复\" class=\"headerlink\" title=\"3. 死锁恢复\"></a>3. 死锁恢复</h4><ul>\n<li>抢占恢复</li>\n<li>回滚恢复</li>\n<li>杀死进程恢复</li>\n</ul>\n<h3 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"死锁预防\"></a>死锁预防</h3><p>程序运行<strong>之前</strong>预防发生死锁，即破坏发生死锁的四个条件。</p>\n<h4 id=\"1-破坏互斥条件（最难破坏，也有可能无法破坏）\"><a href=\"#1-破坏互斥条件（最难破坏，也有可能无法破坏）\" class=\"headerlink\" title=\"1. 破坏互斥条件（最难破坏，也有可能无法破坏）\"></a>1. 破坏互斥条件（最难破坏，也有可能无法破坏）</h4><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>\n<h4 id=\"2-破坏占有和等待条件\"><a href=\"#2-破坏占有和等待条件\" class=\"headerlink\" title=\"2. 破坏占有和等待条件\"></a>2. 破坏占有和等待条件</h4><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>\n<h4 id=\"3-破坏不可抢占条件\"><a href=\"#3-破坏不可抢占条件\" class=\"headerlink\" title=\"3. 破坏不可抢占条件\"></a>3. 破坏不可抢占条件</h4><h4 id=\"4-破坏环路等待\"><a href=\"#4-破坏环路等待\" class=\"headerlink\" title=\"4. 破坏环路等待\"></a>4. 破坏环路等待</h4><p>给资源统一编号，进程只能按编号顺序来请求资源。</p>\n<h3 id=\"死锁避免\"><a href=\"#死锁避免\" class=\"headerlink\" title=\"死锁避免\"></a>死锁避免</h3><p>程序<strong>运行时</strong>避免发生死锁。（死锁避免其实就是用死锁检测的方法，先检测如果执行了请求，未来的状态是否会发生死锁，然后避免）</p>\n<h4 id=\"1-安全状态\"><a href=\"#1-安全状态\" class=\"headerlink\" title=\"1. 安全状态\"></a>1. 安全状态</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175712336.png\"></p>\n<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>\n<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>\n<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>\n<h4 id=\"2-单个资源的银行家算法\"><a href=\"#2-单个资源的银行家算法\" class=\"headerlink\" title=\"2. 单个资源的银行家算法\"></a>2. 单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320175725276.png\"></p>\n<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>\n<h4 id=\"3-多个资源的银行家算法\"><a href=\"#3-多个资源的银行家算法\" class=\"headerlink\" title=\"3. 多个资源的银行家算法\"></a>3. 多个资源的银行家算法</h4><p><img src=\"/2024/03/20/operating-systems/image-20240320175747301.png\"></p>\n<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p>\n<p>检查一个状态是否安全的算法如下：</p>\n<ul>\n<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>\n<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>\n<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>\n</ul>\n<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>\n<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>\n<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180056054.png\"></p>\n<h3 id=\"分页系统地址映射\"><a href=\"#分页系统地址映射\" class=\"headerlink\" title=\"分页系统地址映射\"></a>分页系统地址映射</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>\n<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>\n<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于<strong>虚拟</strong>地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的<strong>页框</strong>的地址为 （110 000000000100）。少了一位。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180104512.png\"></p>\n<h3 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>\n<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>\n<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>\n<h4 id=\"1-最佳\"><a href=\"#1-最佳\" class=\"headerlink\" title=\"1. 最佳\"></a>1. 最佳</h4><blockquote>\n<p>OPT, Optimal replacement algorithm</p>\n</blockquote>\n<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>\n<p>是一种理论上的算法，因为无法知道一个页面多长时间（未来的时间）不再被访问。</p>\n<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure>\n\n<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，看后续页面，7, 0, 1 出现的先后顺序为 0, 1, 7，即页面 7 再次被访问的时间最长。</p>\n<h4 id=\"2-最近最久未使用\"><a href=\"#2-最近最久未使用\" class=\"headerlink\" title=\"2. 最近最久未使用\"></a>2. 最近最久未使用</h4><blockquote>\n<p>LRU, Least Recently Used</p>\n</blockquote>\n<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>\n<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>\n<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure>\n\n<p>下图中最后一个才涉及到页面置换，最久未使用的 4 被移出。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180115680.png\"></p>\n<h4 id=\"3-最近未使用\"><a href=\"#3-最近未使用\" class=\"headerlink\" title=\"3. 最近未使用\"></a>3. 最近未使用</h4><blockquote>\n<p>NRU, Not Recently Used</p>\n</blockquote>\n<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R&#x3D;1，当页面被修改时设置 M&#x3D;1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>\n<ul>\n<li>R&#x3D;0，M&#x3D;0</li>\n<li>R&#x3D;0，M&#x3D;1</li>\n<li>R&#x3D;1，M&#x3D;0</li>\n<li>R&#x3D;1，M&#x3D;1</li>\n</ul>\n<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>\n<p>NRU 优先换出<strong>已经被修改的脏页面</strong>（R&#x3D;0，M&#x3D;1），而不是被频繁使用的干净页面（R&#x3D;1，M&#x3D;0）。</p>\n<h4 id=\"4-先进先出\"><a href=\"#4-先进先出\" class=\"headerlink\" title=\"4. 先进先出\"></a>4. 先进先出</h4><blockquote>\n<p>FIFO, First In First Out</p>\n</blockquote>\n<p>选择换出的页面是最先进入的页面。</p>\n<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>\n<h4 id=\"5-第二次机会算法\"><a href=\"#5-第二次机会算法\" class=\"headerlink\" title=\"5. 第二次机会算法\"></a>5. 第二次机会算法</h4><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>\n<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1（说明该页面之前被访问过，获得了复活甲，R &#x3D; 1）。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0（复活甲掉了），并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180128128.png\"></p>\n<h4 id=\"6-时钟\"><a href=\"#6-时钟\" class=\"headerlink\" title=\"6. 时钟\"></a>6. 时钟</h4><blockquote>\n<p>Clock</p>\n</blockquote>\n<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>\n<p><img src=\"/2024/03/20/operating-systems/image-20240320180134569.png\"></p>\n<h3 id=\"分段（暂无）\"><a href=\"#分段（暂无）\" class=\"headerlink\" title=\"分段（暂无）\"></a>分段（暂无）</h3>"},{"title":"Socket","date":"2024-03-20T03:01:14.000Z","toc":true,"_content":"\n## 一、I/O 模型\n\n一个输入操作通常包括两个阶段：\n\n- 等待数据准备好\n- 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nUnix 有五种 I/O 模型：\n\n<!--more-->\n\n- 阻塞式 I/O\n- 非阻塞式 I/O\n- I/O 多路复用（select 和 poll）\n- 信号驱动式 I/O（SIGIO）\n- 异步 I/O（AIO）\n\n### 阻塞式 I/O\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。\n\n下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\n```c\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n```\n\n![image-20240320110531226](socket/image-20240320110531226.png)\n\n### 非阻塞式 I/O\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为**轮询（polling）**。\n\n由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。\n\n![image-20240320110625558](socket/image-20240320110625558.png)\n\n### I/O 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O（对这句保持质疑）。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n![image-20240320111122789](socket/image-20240320111122789.png)\n\n### 信号驱动 I/O\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n![image-20240320120005597](socket/image-20240320120005597.png)\n\n### 异步 I/O\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步是通知应用进程 I/O 完成，信号驱动是通知可以开始 I/O。\n\n### 五大 I/O 模型比较\n\n- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。\n- 异步 I/O：第二阶段应用进程不会阻塞。\n\n除了异步 I/O，其它的都是同步 I/O。\n\n非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。\n\n![image-20240320120231930](socket/image-20240320120231930.png)\n\n## 二、I/O 复用\n\nselect/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n### select\n\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n```\n\nselect 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。\n\n- fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听**少于 FD_SETSIZE 数量**的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。\n- timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。\n- 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。\n\n### poll\n\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout);\n```\n\npoll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。\n\n### 比较\n\n#### 1. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n- select 会修改描述符，而 poll 不会；\n- select 监听的描述符数量比 poll 少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；\n- poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n- 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n#### 2. 速度\n\nselect 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n\n#### 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n### epoll\n\n```c\nint epoll_create(int size);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵**红黑树**上，通过回调函数内核会将 I/O **准备好的描述符加入到一个链表中**管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。\n\n从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 Linux OS。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n### 工作模式\n\nepoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。\n\n#### 1. LT 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以**不立即处理**该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n#### 2. ET 模式\n\n和 LT 模式不同的是，通知之后进程必须**立即处理**事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n### 应用场景\n\n#### 1. select 应用场景\n\n实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。\n\n可移植性。几乎被所有主流平台所支持。\n\n#### 2. poll 应用场景\n\n实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。\n\n#### 3. epoll 应用场景\n\n只需要运行在 Linux 上，有大量描述符需要监控，并且连接为长连接。\n\n少于 1000 的描述符没必要用。\n\n描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。\n","source":"_posts/socket.md","raw":"---\ntitle: Socket\ndate: 2024-03-20 11:01:14\ncategories:\n  - work\n  - review\n  - computer networks\ntags:\n  - computer networks\n  - socket\ntoc: true\n---\n\n## 一、I/O 模型\n\n一个输入操作通常包括两个阶段：\n\n- 等待数据准备好\n- 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nUnix 有五种 I/O 模型：\n\n<!--more-->\n\n- 阻塞式 I/O\n- 非阻塞式 I/O\n- I/O 多路复用（select 和 poll）\n- 信号驱动式 I/O（SIGIO）\n- 异步 I/O（AIO）\n\n### 阻塞式 I/O\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。\n\n下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\n```c\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n```\n\n![image-20240320110531226](socket/image-20240320110531226.png)\n\n### 非阻塞式 I/O\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为**轮询（polling）**。\n\n由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。\n\n![image-20240320110625558](socket/image-20240320110625558.png)\n\n### I/O 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O（对这句保持质疑）。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n![image-20240320111122789](socket/image-20240320111122789.png)\n\n### 信号驱动 I/O\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n![image-20240320120005597](socket/image-20240320120005597.png)\n\n### 异步 I/O\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步是通知应用进程 I/O 完成，信号驱动是通知可以开始 I/O。\n\n### 五大 I/O 模型比较\n\n- 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。\n- 异步 I/O：第二阶段应用进程不会阻塞。\n\n除了异步 I/O，其它的都是同步 I/O。\n\n非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。\n\n![image-20240320120231930](socket/image-20240320120231930.png)\n\n## 二、I/O 复用\n\nselect/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n### select\n\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n```\n\nselect 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。\n\n- fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听**少于 FD_SETSIZE 数量**的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。\n- timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。\n- 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。\n\n### poll\n\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout);\n```\n\npoll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。\n\n### 比较\n\n#### 1. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n- select 会修改描述符，而 poll 不会；\n- select 监听的描述符数量比 poll 少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；\n- poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n- 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n#### 2. 速度\n\nselect 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n\n#### 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n### epoll\n\n```c\nint epoll_create(int size);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵**红黑树**上，通过回调函数内核会将 I/O **准备好的描述符加入到一个链表中**管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。\n\n从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 Linux OS。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n### 工作模式\n\nepoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。\n\n#### 1. LT 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以**不立即处理**该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n#### 2. ET 模式\n\n和 LT 模式不同的是，通知之后进程必须**立即处理**事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n### 应用场景\n\n#### 1. select 应用场景\n\n实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。\n\n可移植性。几乎被所有主流平台所支持。\n\n#### 2. poll 应用场景\n\n实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。\n\n#### 3. epoll 应用场景\n\n只需要运行在 Linux 上，有大量描述符需要监控，并且连接为长连接。\n\n少于 1000 的描述符没必要用。\n\n描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。\n","slug":"socket","published":1,"updated":"2024-03-22T03:36:11.720Z","comments":1,"layout":"post","photos":[],"_id":"clu247pw70017jocg1kprgsj2","content":"<h2 id=\"一、I-O-模型\"><a href=\"#一、I-O-模型\" class=\"headerlink\" title=\"一、I&#x2F;O 模型\"></a>一、I&#x2F;O 模型</h2><p>一个输入操作通常包括两个阶段：</p>\n<ul>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ul>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p>Unix 有五种 I&#x2F;O 模型：</p>\n<span id=\"more\"></span>\n\n<ul>\n<li>阻塞式 I&#x2F;O</li>\n<li>非阻塞式 I&#x2F;O</li>\n<li>I&#x2F;O 多路复用（select 和 poll）</li>\n<li>信号驱动式 I&#x2F;O（SIGIO）</li>\n<li>异步 I&#x2F;O（AIO）</li>\n</ul>\n<h3 id=\"阻塞式-I-O\"><a href=\"#阻塞式-I-O\" class=\"headerlink\" title=\"阻塞式 I&#x2F;O\"></a>阻塞式 I&#x2F;O</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>\n<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>\n<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">recvfrom</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags, <span class=\"keyword\">struct</span> sockaddr *src_addr, <span class=\"type\">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/03/20/socket/image-20240320110531226.png\"></p>\n<h3 id=\"非阻塞式-I-O\"><a href=\"#非阻塞式-I-O\" class=\"headerlink\" title=\"非阻塞式 I&#x2F;O\"></a>非阻塞式 I&#x2F;O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为<strong>轮询（polling）</strong>。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320110625558.png\"></p>\n<h3 id=\"I-O-复用\"><a href=\"#I-O-复用\" class=\"headerlink\" title=\"I&#x2F;O 复用\"></a>I&#x2F;O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。</p>\n<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O（对这句保持质疑）。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320111122789.png\"></p>\n<h3 id=\"信号驱动-I-O\"><a href=\"#信号驱动-I-O\" class=\"headerlink\" title=\"信号驱动 I&#x2F;O\"></a>信号驱动 I&#x2F;O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120005597.png\"></p>\n<h3 id=\"异步-I-O\"><a href=\"#异步-I-O\" class=\"headerlink\" title=\"异步 I&#x2F;O\"></a>异步 I&#x2F;O</h3><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步是通知应用进程 I&#x2F;O 完成，信号驱动是通知可以开始 I&#x2F;O。</p>\n<h3 id=\"五大-I-O-模型比较\"><a href=\"#五大-I-O-模型比较\" class=\"headerlink\" title=\"五大 I&#x2F;O 模型比较\"></a>五大 I&#x2F;O 模型比较</h3><ul>\n<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>\n<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li>\n</ul>\n<p>除了异步 I&#x2F;O，其它的都是同步 I&#x2F;O。</p>\n<p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120231930.png\"></p>\n<h2 id=\"二、I-O-复用\"><a href=\"#二、I-O-复用\" class=\"headerlink\" title=\"二、I&#x2F;O 复用\"></a>二、I&#x2F;O 复用</h2><p>select&#x2F;poll&#x2F;epoll 都是 I&#x2F;O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>\n<h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I&#x2F;O 操作。</p>\n<ul>\n<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听<strong>少于 FD_SETSIZE 数量</strong>的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>\n<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>\n<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>\n</ul>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><h4 id=\"1-功能\"><a href=\"#1-功能\" class=\"headerlink\" title=\"1. 功能\"></a>1. 功能</h4><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>\n<ul>\n<li>select 会修改描述符，而 poll 不会；</li>\n<li>select 监听的描述符数量比 poll 少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>\n<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>\n<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>\n</ul>\n<h4 id=\"2-速度\"><a href=\"#2-速度\" class=\"headerlink\" title=\"2. 速度\"></a>2. 速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>\n<h4 id=\"3-可移植性\"><a href=\"#3-可移植性\" class=\"headerlink\" title=\"3. 可移植性\"></a>3. 可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>\n<h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>；</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，通过回调函数内核会将 I&#x2F;O <strong>准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>\n<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>\n<p>epoll 仅适用于 Linux OS。</p>\n<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>\n<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>\n<h3 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>\n<h4 id=\"1-LT-模式\"><a href=\"#1-LT-模式\" class=\"headerlink\" title=\"1. LT 模式\"></a>1. LT 模式</h4><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以<strong>不立即处理</strong>该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>\n<h4 id=\"2-ET-模式\"><a href=\"#2-ET-模式\" class=\"headerlink\" title=\"2. ET 模式\"></a>2. ET 模式</h4><p>和 LT 模式不同的是，通知之后进程必须<strong>立即处理</strong>事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>\n<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-select-应用场景\"><a href=\"#1-select-应用场景\" class=\"headerlink\" title=\"1. select 应用场景\"></a>1. select 应用场景</h4><p>实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。</p>\n<p>可移植性。几乎被所有主流平台所支持。</p>\n<h4 id=\"2-poll-应用场景\"><a href=\"#2-poll-应用场景\" class=\"headerlink\" title=\"2. poll 应用场景\"></a>2. poll 应用场景</h4><p>实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。</p>\n<h4 id=\"3-epoll-应用场景\"><a href=\"#3-epoll-应用场景\" class=\"headerlink\" title=\"3. epoll 应用场景\"></a>3. epoll 应用场景</h4><p>只需要运行在 Linux 上，有大量描述符需要监控，并且连接为长连接。</p>\n<p>少于 1000 的描述符没必要用。</p>\n<p>描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>\n","excerpt":"<h2 id=\"一、I-O-模型\"><a href=\"#一、I-O-模型\" class=\"headerlink\" title=\"一、I&#x2F;O 模型\"></a>一、I&#x2F;O 模型</h2><p>一个输入操作通常包括两个阶段：</p>\n<ul>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ul>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p>Unix 有五种 I&#x2F;O 模型：</p>","more":"<ul>\n<li>阻塞式 I&#x2F;O</li>\n<li>非阻塞式 I&#x2F;O</li>\n<li>I&#x2F;O 多路复用（select 和 poll）</li>\n<li>信号驱动式 I&#x2F;O（SIGIO）</li>\n<li>异步 I&#x2F;O（AIO）</li>\n</ul>\n<h3 id=\"阻塞式-I-O\"><a href=\"#阻塞式-I-O\" class=\"headerlink\" title=\"阻塞式 I&#x2F;O\"></a>阻塞式 I&#x2F;O</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>\n<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>\n<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">recvfrom</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags, <span class=\"keyword\">struct</span> sockaddr *src_addr, <span class=\"type\">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/03/20/socket/image-20240320110531226.png\"></p>\n<h3 id=\"非阻塞式-I-O\"><a href=\"#非阻塞式-I-O\" class=\"headerlink\" title=\"非阻塞式 I&#x2F;O\"></a>非阻塞式 I&#x2F;O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为<strong>轮询（polling）</strong>。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320110625558.png\"></p>\n<h3 id=\"I-O-复用\"><a href=\"#I-O-复用\" class=\"headerlink\" title=\"I&#x2F;O 复用\"></a>I&#x2F;O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。虽然是通过等待事件的发生来驱动程序，但是内部实现是采用轮询（系统轮询）的方式。</p>\n<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O（对这句保持质疑）。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320111122789.png\"></p>\n<h3 id=\"信号驱动-I-O\"><a href=\"#信号驱动-I-O\" class=\"headerlink\" title=\"信号驱动 I&#x2F;O\"></a>信号驱动 I&#x2F;O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120005597.png\"></p>\n<h3 id=\"异步-I-O\"><a href=\"#异步-I-O\" class=\"headerlink\" title=\"异步 I&#x2F;O\"></a>异步 I&#x2F;O</h3><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步是通知应用进程 I&#x2F;O 完成，信号驱动是通知可以开始 I&#x2F;O。</p>\n<h3 id=\"五大-I-O-模型比较\"><a href=\"#五大-I-O-模型比较\" class=\"headerlink\" title=\"五大 I&#x2F;O 模型比较\"></a>五大 I&#x2F;O 模型比较</h3><ul>\n<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>\n<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li>\n</ul>\n<p>除了异步 I&#x2F;O，其它的都是同步 I&#x2F;O。</p>\n<p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p>\n<p><img src=\"/2024/03/20/socket/image-20240320120231930.png\"></p>\n<h2 id=\"二、I-O-复用\"><a href=\"#二、I-O-复用\" class=\"headerlink\" title=\"二、I&#x2F;O 复用\"></a>二、I&#x2F;O 复用</h2><p>select&#x2F;poll&#x2F;epoll 都是 I&#x2F;O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>\n<h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I&#x2F;O 操作。</p>\n<ul>\n<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听<strong>少于 FD_SETSIZE 数量</strong>的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>\n<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>\n<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>\n</ul>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><h4 id=\"1-功能\"><a href=\"#1-功能\" class=\"headerlink\" title=\"1. 功能\"></a>1. 功能</h4><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>\n<ul>\n<li>select 会修改描述符，而 poll 不会；</li>\n<li>select 监听的描述符数量比 poll 少。select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>\n<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>\n<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>\n</ul>\n<h4 id=\"2-速度\"><a href=\"#2-速度\" class=\"headerlink\" title=\"2. 速度\"></a>2. 速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>\n<h4 id=\"3-可移植性\"><a href=\"#3-可移植性\" class=\"headerlink\" title=\"3. 可移植性\"></a>3. 可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>\n<h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>；</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，通过回调函数内核会将 I&#x2F;O <strong>准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>\n<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>\n<p>epoll 仅适用于 Linux OS。</p>\n<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>\n<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>\n<h3 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>\n<h4 id=\"1-LT-模式\"><a href=\"#1-LT-模式\" class=\"headerlink\" title=\"1. LT 模式\"></a>1. LT 模式</h4><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以<strong>不立即处理</strong>该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>\n<h4 id=\"2-ET-模式\"><a href=\"#2-ET-模式\" class=\"headerlink\" title=\"2. ET 模式\"></a>2. ET 模式</h4><p>和 LT 模式不同的是，通知之后进程必须<strong>立即处理</strong>事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>\n<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"1-select-应用场景\"><a href=\"#1-select-应用场景\" class=\"headerlink\" title=\"1. select 应用场景\"></a>1. select 应用场景</h4><p>实时性要求高。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒。如核反应堆的控制。</p>\n<p>可移植性。几乎被所有主流平台所支持。</p>\n<h4 id=\"2-poll-应用场景\"><a href=\"#2-poll-应用场景\" class=\"headerlink\" title=\"2. poll 应用场景\"></a>2. poll 应用场景</h4><p>实时性要求不高，文件描述符多。poll 没有最大描述符数量的限制。</p>\n<h4 id=\"3-epoll-应用场景\"><a href=\"#3-epoll-应用场景\" class=\"headerlink\" title=\"3. epoll 应用场景\"></a>3. epoll 应用场景</h4><p>只需要运行在 Linux 上，有大量描述符需要监控，并且连接为长连接。</p>\n<p>少于 1000 的描述符没必要用。</p>\n<p>描述符状态变化多，且短暂，也没必要用。因为 epoll 中的所有描述符都存储在内核中，每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>"}],"PostAsset":[{"_id":"source/_posts/computer-networks/image-20240318105358847.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240318105358847.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240318105418710.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240318105418710.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240318105431532.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240318105431532.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240318110448792.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240318110448792.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240318123102054.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240318123102054.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240318124318116.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240318124318116.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240318124331487.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240318124331487.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240319094259385.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240319094259385.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240319094315691.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240319094315691.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231501917.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231501917.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231555984.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231555984.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231606870.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231606870.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231617299.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231617299.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231628966.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231628966.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231639197.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231639197.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231707214.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231707214.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231718044.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231718044.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231728699.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231728699.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231741490.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231741490.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320231946518.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320231946518.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320232029117.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320232029117.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320232052656.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320232052656.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320232244255.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320232244255.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233356850.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233356850.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233404661.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233404661.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233517464.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233517464.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233535616.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233535616.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233614781.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233614781.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233622336.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233622336.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233632927.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233632927.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233705195.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233705195.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233735273.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233735273.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233824232.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233824232.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233838217.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233838217.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233852959.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233852959.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233906140.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233906140.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320233951219.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320233951219.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234048388.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234048388.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234214934.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234214934.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234247573.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234247573.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234310912.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234310912.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234736573.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234736573.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234748836.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234748836.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234811272.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234811272.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320234840219.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320234840219.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320235442988.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320235442988.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320235524028.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320235524028.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320235533138.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320235533138.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320235655694.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320235655694.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320235718371.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320235718371.png","modified":1,"renderable":0},{"_id":"source/_posts/computer-networks/image-20240320235727170.png","post":"clu247pua0000jocg4vdhcnxo","slug":"image-20240320235727170.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319215933046.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319215933046.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319220740283.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319220740283.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319220943892.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319220943892.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221024695.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319221024695.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221039549.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319221039549.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221109092.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319221109092.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221128098.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319221128098.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222609279.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319222609279.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222621455.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319222621455.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222801904.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319222801904.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222832886.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319222832886.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222857283.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319222857283.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319223152453.png","post":"clu247pug0001jocg2piu9ggw","slug":"image-20240319223152453.png","modified":1,"renderable":0},{"_id":"source/_posts/hw1/image-20240319110624835.png","post":"clu247pun0005jocgfmgu6ova","slug":"image-20240319110624835.png","modified":1,"renderable":0},{"_id":"source/_posts/golang/image-20240320181645811.png","post":"clu247puo0006jocg6nk66mv2","slug":"image-20240320181645811.png","modified":1,"renderable":0},{"_id":"source/_posts/meituan-interview/image-20240321212159961.png","post":"clu247pw40012jocgc15jdmdg","slug":"image-20240321212159961.png","modified":1,"renderable":0},{"_id":"source/_posts/meituan-interview/image-20240321212210047.png","post":"clu247pw40012jocgc15jdmdg","slug":"image-20240321212210047.png","modified":1,"renderable":0},{"_id":"source/_posts/meituan-interview/image-20240321213051186.png","post":"clu247pw40012jocgc15jdmdg","slug":"image-20240321213051186.png","modified":1,"renderable":0},{"_id":"source/_posts/meituan-interview/image-20240321213127087.png","post":"clu247pw40012jocgc15jdmdg","slug":"image-20240321213127087.png","modified":1,"renderable":0},{"_id":"source/_posts/meituan-interview/image-20240321213357032.png","post":"clu247pw40012jocgc15jdmdg","slug":"image-20240321213357032.png","modified":1,"renderable":0},{"_id":"source/_posts/mysql/image-20240319231655495.png","post":"clu247pw40013jocgbphx20ez","slug":"image-20240319231655495.png","modified":1,"renderable":0},{"_id":"source/_posts/mysql/image-20240319231743225.png","post":"clu247pw40013jocgbphx20ez","slug":"image-20240319231743225.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175407843.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175407843.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175421234.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175421234.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175436050.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175436050.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175446963.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175446963.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175455259.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175455259.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175508729.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175508729.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175525345.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175525345.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175548861.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175548861.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175601947.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175601947.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175609777.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175609777.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175633047.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175633047.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175638377.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175638377.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175649285.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175649285.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175712336.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175712336.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175725276.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175725276.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320175747301.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320175747301.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320180056054.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320180056054.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320180104512.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320180104512.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320180115680.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320180115680.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320180128128.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320180128128.png","modified":1,"renderable":0},{"_id":"source/_posts/operating-systems/image-20240320180134569.png","post":"clu247pw50015jocgdaui4i6o","slug":"image-20240320180134569.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320110531226.png","post":"clu247pw70017jocg1kprgsj2","slug":"image-20240320110531226.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320110625558.png","post":"clu247pw70017jocg1kprgsj2","slug":"image-20240320110625558.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320111122789.png","post":"clu247pw70017jocg1kprgsj2","slug":"image-20240320111122789.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320120005597.png","post":"clu247pw70017jocg1kprgsj2","slug":"image-20240320120005597.png","modified":1,"renderable":0},{"_id":"source/_posts/socket/image-20240320120231930.png","post":"clu247pw70017jocg1kprgsj2","slug":"image-20240320120231930.png","modified":1,"renderable":0}],"PostCategory":[{"post_id":"clu247pun0005jocgfmgu6ova","category_id":"clu247pvs000ajocg04n1bqen","_id":"clu247pvx000pjocg3m4i1uv3"},{"post_id":"clu247pun0005jocgfmgu6ova","category_id":"clu247pvw000ljocgdv795msq","_id":"clu247pvy000rjocga3z138bn"},{"post_id":"clu247pua0000jocg4vdhcnxo","category_id":"clu247puj0002jocg7rbb5paz","_id":"clu247pvy000sjocgdl9w3z71"},{"post_id":"clu247pua0000jocg4vdhcnxo","category_id":"clu247pvt000cjocg8dsi788h","_id":"clu247pvy000ujocg0geage92"},{"post_id":"clu247pua0000jocg4vdhcnxo","category_id":"clu247pvx000njocg1fkib00l","_id":"clu247pvy000vjocg4c9a0j9u"},{"post_id":"clu247puo0006jocg6nk66mv2","category_id":"clu247puj0002jocg7rbb5paz","_id":"clu247pvz000wjocg7vdzgmbn"},{"post_id":"clu247puo0006jocg6nk66mv2","category_id":"clu247pvt000cjocg8dsi788h","_id":"clu247pvz000xjocga2zu4obe"},{"post_id":"clu247puo0006jocg6nk66mv2","category_id":"clu247pvx000qjocg4jqvblnu","_id":"clu247pvz000yjocg04s02ysb"},{"post_id":"clu247pug0001jocg2piu9ggw","category_id":"clu247puj0002jocg7rbb5paz","_id":"clu247pvz000zjocgd0d7843m"},{"post_id":"clu247pug0001jocg2piu9ggw","category_id":"clu247pvt000cjocg8dsi788h","_id":"clu247pvz0010jocg2dum58js"},{"post_id":"clu247pug0001jocg2piu9ggw","category_id":"clu247pvy000tjocg0eh14q53","_id":"clu247pvz0011jocge84z7e2n"},{"post_id":"clu247pw40013jocgbphx20ez","category_id":"clu247puj0002jocg7rbb5paz","_id":"clu247pw8001ajocgbiafd0s3"},{"post_id":"clu247pw40013jocgbphx20ez","category_id":"clu247pvt000cjocg8dsi788h","_id":"clu247pw9001bjocg4pxdgccl"},{"post_id":"clu247pw40013jocgbphx20ez","category_id":"clu247pvy000tjocg0eh14q53","_id":"clu247pw9001djocggfe37hn0"},{"post_id":"clu247pw40012jocgc15jdmdg","category_id":"clu247puj0002jocg7rbb5paz","_id":"clu247pw9001ejocg69q6c8bi"},{"post_id":"clu247pw40012jocgc15jdmdg","category_id":"clu247pw60016jocg3qy59wh1","_id":"clu247pw9001fjocge35kgqow"},{"post_id":"clu247pw70017jocg1kprgsj2","category_id":"clu247puj0002jocg7rbb5paz","_id":"clu247pwa001ijocg76j35bin"},{"post_id":"clu247pw70017jocg1kprgsj2","category_id":"clu247pvt000cjocg8dsi788h","_id":"clu247pwa001kjocgeesb6d4g"},{"post_id":"clu247pw70017jocg1kprgsj2","category_id":"clu247pvx000njocg1fkib00l","_id":"clu247pwa001njocgebh0efe9"},{"post_id":"clu247pw50015jocgdaui4i6o","category_id":"clu247puj0002jocg7rbb5paz","_id":"clu247pwa001pjocg2efx12om"},{"post_id":"clu247pw50015jocgdaui4i6o","category_id":"clu247pvt000cjocg8dsi788h","_id":"clu247pwb001sjocgcno3fuy2"},{"post_id":"clu247pw50015jocgdaui4i6o","category_id":"clu247pw80019jocgdhth6jlh","_id":"clu247pwb001ujocg8d5988gk"}],"PostTag":[{"post_id":"clu247pua0000jocg4vdhcnxo","tag_id":"clu247pul0003jocgfuwhbaf3","_id":"clu247pvr0009jocgd14z812x"},{"post_id":"clu247pug0001jocg2piu9ggw","tag_id":"clu247pup0008jocg8j6ccklp","_id":"clu247pvt000ejocgb02e7jwx"},{"post_id":"clu247pug0001jocg2piu9ggw","tag_id":"clu247pvs000bjocgfdoi007d","_id":"clu247pvt000fjocg3w54ds17"},{"post_id":"clu247pun0005jocgfmgu6ova","tag_id":"clu247pvt000djocgdhpuh8yr","_id":"clu247pvv000ijocg188z5m7w"},{"post_id":"clu247puo0006jocg6nk66mv2","tag_id":"clu247pvu000hjocgfer35v0z","_id":"clu247pvx000mjocg5a339ah6"},{"post_id":"clu247puo0006jocg6nk66mv2","tag_id":"clu247pvw000kjocg4zgo2yqh","_id":"clu247pvx000ojocg1kdg0x1v"},{"post_id":"clu247pw40012jocgc15jdmdg","tag_id":"clu247pw50014jocgbbx24rv8","_id":"clu247pwa001hjocg3raxhlbb"},{"post_id":"clu247pw40012jocgc15jdmdg","tag_id":"clu247pw80018jocgdk4l5xtf","_id":"clu247pwa001jjocge2thc50w"},{"post_id":"clu247pw40012jocgc15jdmdg","tag_id":"clu247pw9001cjocg7b8n3lkr","_id":"clu247pwa001mjocgffrgecj9"},{"post_id":"clu247pw40013jocgbphx20ez","tag_id":"clu247pup0008jocg8j6ccklp","_id":"clu247pwa001ojocgdtlk3qxb"},{"post_id":"clu247pw40013jocgbphx20ez","tag_id":"clu247pw9001gjocgce171a0t","_id":"clu247pwb001rjocggb59d3k7"},{"post_id":"clu247pw50015jocgdaui4i6o","tag_id":"clu247pwa001ljocgc7s958nb","_id":"clu247pwb001tjocghzb5d2p1"},{"post_id":"clu247pw50015jocgdaui4i6o","tag_id":"clu247pvs000bjocgfdoi007d","_id":"clu247pwb001vjocgdzc68sct"},{"post_id":"clu247pw70017jocg1kprgsj2","tag_id":"clu247pul0003jocgfuwhbaf3","_id":"clu247pwb001wjocg9he9ch8d"},{"post_id":"clu247pw70017jocg1kprgsj2","tag_id":"clu247pwa001qjocge4f55cwj","_id":"clu247pwb001xjocg3cm88h3f"}],"Tag":[{"name":"computer networks","_id":"clu247pul0003jocgfuwhbaf3"},{"name":"database","_id":"clu247pup0008jocg8j6ccklp"},{"name":"principles","_id":"clu247pvs000bjocgfdoi007d"},{"name":"homework","_id":"clu247pvt000djocgdhpuh8yr"},{"name":"go","_id":"clu247pvu000hjocgfer35v0z"},{"name":"language","_id":"clu247pvw000kjocg4zgo2yqh"},{"name":"work","_id":"clu247pw50014jocgbbx24rv8"},{"name":"interview","_id":"clu247pw80018jocgdk4l5xtf"},{"name":"backend","_id":"clu247pw9001cjocg7b8n3lkr"},{"name":"mysql","_id":"clu247pw9001gjocgce171a0t"},{"name":"operating systems","_id":"clu247pwa001ljocgc7s958nb"},{"name":"socket","_id":"clu247pwa001qjocge4f55cwj"}]}}