{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/database-system-principles.md","hash":"66a43d025e5335d2f73dc6187b43ef29750a63f5","modified":1710859346580},{"_id":"source/_posts/hello-world.md","hash":"777d9387caf698574064318ecab5c2bb5abe878e","modified":1710854010145},{"_id":"source/_posts/mysql.md","hash":"a857a53d192a2a993806f66a8a919ec8ef43226a","modified":1710862186757},{"_id":"source/_posts/database-system-principles/image-20240319215933046.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710856773068},{"_id":"source/_posts/database-system-principles/image-20240319221024695.png","hash":"69b6c0175dac118c71e167c90c33a4e4c4e47757","modified":1710857424710},{"_id":"source/_posts/database-system-principles/image-20240319220740283.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710857260304},{"_id":"source/_posts/database-system-principles/image-20240319220943892.png","hash":"bc60779a7c294034e7de4e6be05037b95b659ef2","modified":1710857383912},{"_id":"source/_posts/database-system-principles/image-20240319221039549.png","hash":"cbf322064326a4abe99ace20077060f2a27aad4d","modified":1710857439571},{"_id":"source/_posts/database-system-principles/image-20240319221128098.png","hash":"28269ef73d73a53ece9fa0df1015be097b0fad25","modified":1710857488129},{"_id":"source/_posts/database-system-principles/image-20240319221109092.png","hash":"bd4b34fb787786b5be792b6517a2c236f7705e0b","modified":1710857469113},{"_id":"source/_posts/database-system-principles/image-20240319222609279.png","hash":"225bd2c408a4105dca17e4a59cf266b12d11fb02","modified":1710858369294},{"_id":"source/_posts/database-system-principles/image-20240319222832886.png","hash":"96be249738a4b864e738436b19edae3f1f21d8ea","modified":1710858512908},{"_id":"source/_posts/database-system-principles/image-20240319222621455.png","hash":"a7b9939d28d10aa06158df97048a5fc3bdd683f9","modified":1710858381475},{"_id":"source/_posts/database-system-principles/image-20240319222801904.png","hash":"634e1a8d7ae85ac963b833bf27488be2e832913a","modified":1710858481926},{"_id":"source/_posts/mysql/image-20240319231655495.png","hash":"1f4a4feb12d773b0e2ba01d66dc32191c220fffc","modified":1710861415501},{"_id":"source/_posts/mysql/image-20240319231743225.png","hash":"9d372fbdb6b582c5446a56ab11de5d6044670974","modified":1710861463230},{"_id":"source/_posts/database-system-principles/image-20240319223152453.png","hash":"cb4ef05fc4b820636c20f0b08364f4c5f2aad45b","modified":1710858712480},{"_id":"source/_posts/database-system-principles/image-20240319222857283.png","hash":"d06e64e0562cf03313a31c9cb24cf3a5b5e37db8","modified":1710858537309},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1710853243691},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1710853240416},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1710853243689},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1710853243712},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1710853243714},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1710853243714},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1710853243716},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1710853243715},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1710853243718},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1710853243719},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1710853243717},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1710853243720},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1710853243721},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1710853243721},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1710853243722},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1710853243722},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1710853243723},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1710853243724},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1710853243724},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1710853243727},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1710853243725},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1710853243726},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1710853243728},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1710853243727},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1710853243729},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1710853243731},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1710853243730},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1710853243731},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1710853243732},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1710853243733},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1710853243734},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1710853243737},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1710853243736},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1710853243739},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1710853243738},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1710853243740},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1710853242449},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1710853240443},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1710853240430},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1710853240435},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1710853240449},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1710853240445},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1710853240452},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1710853240458},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1710853240423},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1710853240425},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1710853240427},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1710853240437},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1710853240431},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1710853240441},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1710853240440},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1710853240439},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1710853240443},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1710853240445},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1710853240454},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1710853240429},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1710853240434},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1710853240453},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1710853240457},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1710853240459},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1710853243693},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1710853243695},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1710853243711},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1710853240421},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1710853243689},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1710853240433},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1710853240436},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1710853240447},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1710853240438},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1710853240461},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1710853240456},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1710853243697},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1710853243698},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1710853243699},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1710853243700},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1710853243703},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1710853243707},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1710853243704},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1710853243708},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1710853243708},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1710853243709},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1710853243702},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1710853243706},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1710853242453},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1710853243687},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1710853242448},{"_id":"public/2024/03/19/hello-world/index.html","hash":"2ede77267f6614d66dbda557ea403e3f7ee663b3","modified":1710862432488},{"_id":"public/archives/index.html","hash":"35d673efb44e915c6020e4b6e34991d96c3bf23a","modified":1710862432488},{"_id":"public/archives/2024/index.html","hash":"2c4e52aa08fe966f268cecb1f415712b69c8954a","modified":1710862432488},{"_id":"public/2024/03/19/mysql/index.html","hash":"2b7166ef2a75269814eadf43da07f85ef7ba03c4","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/index.html","hash":"04824097c8ab628ebfa3ae4dd406fecd1458423d","modified":1710862432488},{"_id":"public/archives/2024/03/index.html","hash":"a4f720953f63c1f9ea76a6f7ff431348dd44242d","modified":1710862432488},{"_id":"public/index.html","hash":"abe8de1cd777a98e8992706d6b9d13a689f731fe","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319215933046.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319220740283.png","hash":"0540ae5f8e4c2c0539f7e289b5fa1c2be4ba8eff","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319221024695.png","hash":"69b6c0175dac118c71e167c90c33a4e4c4e47757","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319220943892.png","hash":"bc60779a7c294034e7de4e6be05037b95b659ef2","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319221039549.png","hash":"cbf322064326a4abe99ace20077060f2a27aad4d","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319221128098.png","hash":"28269ef73d73a53ece9fa0df1015be097b0fad25","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319221109092.png","hash":"bd4b34fb787786b5be792b6517a2c236f7705e0b","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319222609279.png","hash":"225bd2c408a4105dca17e4a59cf266b12d11fb02","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319222621455.png","hash":"a7b9939d28d10aa06158df97048a5fc3bdd683f9","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319222801904.png","hash":"634e1a8d7ae85ac963b833bf27488be2e832913a","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319222832886.png","hash":"96be249738a4b864e738436b19edae3f1f21d8ea","modified":1710862432488},{"_id":"public/2024/03/19/mysql/image-20240319231743225.png","hash":"9d372fbdb6b582c5446a56ab11de5d6044670974","modified":1710862432488},{"_id":"public/2024/03/19/mysql/image-20240319231655495.png","hash":"1f4a4feb12d773b0e2ba01d66dc32191c220fffc","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319222857283.png","hash":"d06e64e0562cf03313a31c9cb24cf3a5b5e37db8","modified":1710862432488},{"_id":"public/2024/03/19/database-system-principles/image-20240319223152453.png","hash":"cb4ef05fc4b820636c20f0b08364f4c5f2aad45b","modified":1710862432488},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1710862432488},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1710862432488},{"_id":"public/css/style.css","hash":"ddb3792605d744ab3d9f0a649c82b62e9b16daa6","modified":1710862432488},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1710862432488},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1710862432488},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1710862432488}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"database-system-principles","date":"2024-03-19T13:54:44.000Z","_content":"\n# 数据库系统原理\n\nhttps://zhuanlan.zhihu.com/p/476601594\n\nhttps://blog.csdn.net/Xupixel/article/details/120405501\n\nhttps://www.hwpo.top/posts/d87f7e0c/index.html\n\nhttps://developer.aliyun.com/article/815625\n\n## 一、事务\n\n### 概念\n\n事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\n![image-20240319220740283](database-system-principles/image-20240319220740283.png)\n\n#### 1. 原子性（Atomicity）\n\n事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\n#### 2. 一致性（Consistency）\n\n数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）\n\n#### 3. 隔离性（Isolation）\n\n一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\n#### 4. 持久性（Durability）\n\n一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n\n系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n\n---\n\n事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n\n- 只有满足一致性，事务的执行结果才是正确的。\n- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n- 事务满足持久化是为了能应对系统崩溃的情况。\n\n![image-20240319220943892](database-system-principles/image-20240319220943892.png)\n\n### AUTOCOMMIT\n\nMySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n\n## 二、并发一致性问题\n\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n\n### 丢失修改\n\n丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。\n\n![image-20240319221024695](database-system-principles/image-20240319221024695.png)\n\n### 读脏数据\n\n读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n\n![image-20240319221039549](database-system-principles/image-20240319221039549.png)\n\n### 不可重复读（读已提交导致）\n\n不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。\n\n![image-20240319221109092](database-system-principles/image-20240319221109092.png)\n\n### 幻影读\n\n幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n![image-20240319221128098](database-system-principles/image-20240319221128098.png)\n\n解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n\n## 三、封锁\n\n### 封锁粒度\n\nMySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n\n### 封锁类型\n\n#### 1. 读写锁\n\n- 互斥锁（Exclusive），简写为 X 锁，又称写锁。\n- 共享锁（Shared），简写为 S 锁，又称读锁。\n\n有以下两个规定：\n\n- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n锁的兼容关系如下：\n\n![image-20240319222609279](database-system-principles/image-20240319222609279.png)\n\n#### 2. 意向锁\n\n使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n\n- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n\n各种锁的兼容关系如下：\n\n![image-20240319222621455](database-system-principles/image-20240319222621455.png)\n\n### 封锁协议\n\n#### 1. 三级封锁协议\n\n**一级封锁协议**\n\n事务 T 要修改数据 A 时必须加**X 锁**，直到 **T 结束**才释放锁。\n\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n\n![image-20240319222801904](database-system-principles/image-20240319222801904.png)\n\n**二级封锁协议**\n\n在一级的基础上，要求读取数据 A 时必须加 **S 锁**，**读取完**马上释放 S 锁。\n\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\n![image-20240319222832886](database-system-principles/image-20240319222832886.png)\n\n**三级封锁协议**\n\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n![image-20240319222857283](database-system-principles/image-20240319222857283.png)\n\n#### 2. 两段锁协议\n\n加锁和解锁分为两个阶段进行。\n\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\n\n```\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n```\n\n但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\n\n```\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\n```\n\n### MySQL 隐式与显式锁定\n\nMySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\n\nInnoDB 也可以使用特定的语句进行显示锁定：\n\n```\nSELECT ... LOCK In SHARE MODE;\nSELECT ... FOR UPDATE;\n```\n\n## 四、隔离级别\n\n### 未提交读（READ UNCOMMITTED）\n\n事务中的修改即使没有提交，对其它事务也是可见的。\n\n### 提交读（READ COMMITTED）\n\n一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n### 可重复读（REPEATABLE READ）\n\n保证在同一个事务中多次读取同一数据的结果是一样的。\n\n### 可串行化（SERIALIZABLE）\n\n强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n![image-20240319223152453](database-system-principles/image-20240319223152453.png)\n\n## 五、多版本并发控制（暂时没见过）\n\n## 六、Next-Key Locks（暂时没见过）\n\n## 七、关系数据库设计理论（以后补充完整）\n\n### 函数依赖\n\n记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n\n如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n\n对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。\n\n对于 A->B，B->C，则 A->C 是一个传递函数依赖。\n\n#### 1. 第一范式 (1NF)\n\n属性不可分。满足原子性。\n\n#### 2. 第二范式 (2NF)\n\n每个非主属性完全函数依赖于键码。消除部分依赖。\n\n#### 3. 第三范式 (3NF)\n\n非主属性不传递函数依赖于键码。消除传递依赖。\n\n## 八、ER 图（以后再补充）\n","source":"_posts/database-system-principles.md","raw":"---\ntitle: database-system-principles\ndate: 2024-03-19 21:54:44\ntags:\n\n---\n\n# 数据库系统原理\n\nhttps://zhuanlan.zhihu.com/p/476601594\n\nhttps://blog.csdn.net/Xupixel/article/details/120405501\n\nhttps://www.hwpo.top/posts/d87f7e0c/index.html\n\nhttps://developer.aliyun.com/article/815625\n\n## 一、事务\n\n### 概念\n\n事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\n![image-20240319220740283](database-system-principles/image-20240319220740283.png)\n\n#### 1. 原子性（Atomicity）\n\n事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\n#### 2. 一致性（Consistency）\n\n数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）\n\n#### 3. 隔离性（Isolation）\n\n一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\n#### 4. 持久性（Durability）\n\n一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n\n系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n\n---\n\n事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n\n- 只有满足一致性，事务的执行结果才是正确的。\n- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n- 事务满足持久化是为了能应对系统崩溃的情况。\n\n![image-20240319220943892](database-system-principles/image-20240319220943892.png)\n\n### AUTOCOMMIT\n\nMySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n\n## 二、并发一致性问题\n\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n\n### 丢失修改\n\n丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。\n\n![image-20240319221024695](database-system-principles/image-20240319221024695.png)\n\n### 读脏数据\n\n读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n\n![image-20240319221039549](database-system-principles/image-20240319221039549.png)\n\n### 不可重复读（读已提交导致）\n\n不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。\n\n![image-20240319221109092](database-system-principles/image-20240319221109092.png)\n\n### 幻影读\n\n幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n![image-20240319221128098](database-system-principles/image-20240319221128098.png)\n\n解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n\n## 三、封锁\n\n### 封锁粒度\n\nMySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n\n### 封锁类型\n\n#### 1. 读写锁\n\n- 互斥锁（Exclusive），简写为 X 锁，又称写锁。\n- 共享锁（Shared），简写为 S 锁，又称读锁。\n\n有以下两个规定：\n\n- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n锁的兼容关系如下：\n\n![image-20240319222609279](database-system-principles/image-20240319222609279.png)\n\n#### 2. 意向锁\n\n使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n\n- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；\n- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n\n各种锁的兼容关系如下：\n\n![image-20240319222621455](database-system-principles/image-20240319222621455.png)\n\n### 封锁协议\n\n#### 1. 三级封锁协议\n\n**一级封锁协议**\n\n事务 T 要修改数据 A 时必须加**X 锁**，直到 **T 结束**才释放锁。\n\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n\n![image-20240319222801904](database-system-principles/image-20240319222801904.png)\n\n**二级封锁协议**\n\n在一级的基础上，要求读取数据 A 时必须加 **S 锁**，**读取完**马上释放 S 锁。\n\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\n![image-20240319222832886](database-system-principles/image-20240319222832886.png)\n\n**三级封锁协议**\n\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n![image-20240319222857283](database-system-principles/image-20240319222857283.png)\n\n#### 2. 两段锁协议\n\n加锁和解锁分为两个阶段进行。\n\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\n\n```\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n```\n\n但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\n\n```\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\n```\n\n### MySQL 隐式与显式锁定\n\nMySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\n\nInnoDB 也可以使用特定的语句进行显示锁定：\n\n```\nSELECT ... LOCK In SHARE MODE;\nSELECT ... FOR UPDATE;\n```\n\n## 四、隔离级别\n\n### 未提交读（READ UNCOMMITTED）\n\n事务中的修改即使没有提交，对其它事务也是可见的。\n\n### 提交读（READ COMMITTED）\n\n一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n### 可重复读（REPEATABLE READ）\n\n保证在同一个事务中多次读取同一数据的结果是一样的。\n\n### 可串行化（SERIALIZABLE）\n\n强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n![image-20240319223152453](database-system-principles/image-20240319223152453.png)\n\n## 五、多版本并发控制（暂时没见过）\n\n## 六、Next-Key Locks（暂时没见过）\n\n## 七、关系数据库设计理论（以后补充完整）\n\n### 函数依赖\n\n记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n\n如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n\n对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。\n\n对于 A->B，B->C，则 A->C 是一个传递函数依赖。\n\n#### 1. 第一范式 (1NF)\n\n属性不可分。满足原子性。\n\n#### 2. 第二范式 (2NF)\n\n每个非主属性完全函数依赖于键码。消除部分依赖。\n\n#### 3. 第三范式 (3NF)\n\n非主属性不传递函数依赖于键码。消除传递依赖。\n\n## 八、ER 图（以后再补充）\n","slug":"database-system-principles","published":1,"updated":"2024-03-19T14:42:26.580Z","comments":1,"layout":"post","photos":[],"_id":"cltyjbhzw0000m0cgd4kp170j","content":"<h1 id=\"数据库系统原理\"><a href=\"#数据库系统原理\" class=\"headerlink\" title=\"数据库系统原理\"></a>数据库系统原理</h1><p><a href=\"https://zhuanlan.zhihu.com/p/476601594\">https://zhuanlan.zhihu.com/p/476601594</a></p>\n<p><a href=\"https://blog.csdn.net/Xupixel/article/details/120405501\">https://blog.csdn.net/Xupixel/article/details/120405501</a></p>\n<p><a href=\"https://www.hwpo.top/posts/d87f7e0c/index.html\">https://www.hwpo.top/posts/d87f7e0c/index.html</a></p>\n<p><a href=\"https://developer.aliyun.com/article/815625\">https://developer.aliyun.com/article/815625</a></p>\n<h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220740283.png\"></p>\n<h4 id=\"1-原子性（Atomicity）\"><a href=\"#1-原子性（Atomicity）\" class=\"headerlink\" title=\"1. 原子性（Atomicity）\"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>\n<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>\n<h4 id=\"2-一致性（Consistency）\"><a href=\"#2-一致性（Consistency）\" class=\"headerlink\" title=\"2. 一致性（Consistency）\"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）</p>\n<h4 id=\"3-隔离性（Isolation）\"><a href=\"#3-隔离性（Isolation）\" class=\"headerlink\" title=\"3. 隔离性（Isolation）\"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>\n<h4 id=\"4-持久性（Durability）\"><a href=\"#4-持久性（Durability）\" class=\"headerlink\" title=\"4. 持久性（Durability）\"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>\n<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>\n<hr>\n<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>\n<ul>\n<li>只有满足一致性，事务的执行结果才是正确的。</li>\n<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>\n<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>\n<li>事务满足持久化是为了能应对系统崩溃的情况。</li>\n</ul>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220943892.png\"></p>\n<h3 id=\"AUTOCOMMIT\"><a href=\"#AUTOCOMMIT\" class=\"headerlink\" title=\"AUTOCOMMIT\"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>\n<h2 id=\"二、并发一致性问题\"><a href=\"#二、并发一致性问题\" class=\"headerlink\" title=\"二、并发一致性问题\"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221024695.png\"></p>\n<h3 id=\"读脏数据\"><a href=\"#读脏数据\" class=\"headerlink\" title=\"读脏数据\"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221039549.png\"></p>\n<h3 id=\"不可重复读（读已提交导致）\"><a href=\"#不可重复读（读已提交导致）\" class=\"headerlink\" title=\"不可重复读（读已提交导致）\"></a>不可重复读（读已提交导致）</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221109092.png\"></p>\n<h3 id=\"幻影读\"><a href=\"#幻影读\" class=\"headerlink\" title=\"幻影读\"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221128098.png\"></p>\n<p>解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>\n<h2 id=\"三、封锁\"><a href=\"#三、封锁\" class=\"headerlink\" title=\"三、封锁\"></a>三、封锁</h2><h3 id=\"封锁粒度\"><a href=\"#封锁粒度\" class=\"headerlink\" title=\"封锁粒度\"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>\n<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>\n<h3 id=\"封锁类型\"><a href=\"#封锁类型\" class=\"headerlink\" title=\"封锁类型\"></a>封锁类型</h3><h4 id=\"1-读写锁\"><a href=\"#1-读写锁\" class=\"headerlink\" title=\"1. 读写锁\"></a>1. 读写锁</h4><ul>\n<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>\n<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>\n</ul>\n<p>有以下两个规定：</p>\n<ul>\n<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>\n</ul>\n<p>锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222609279.png\"></p>\n<h4 id=\"2-意向锁\"><a href=\"#2-意向锁\" class=\"headerlink\" title=\"2. 意向锁\"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>\n<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>\n<p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，IX&#x2F;IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>\n<ul>\n<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>\n<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>\n</ul>\n<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>\n<p>各种锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222621455.png\"></p>\n<h3 id=\"封锁协议\"><a href=\"#封锁协议\" class=\"headerlink\" title=\"封锁协议\"></a>封锁协议</h3><h4 id=\"1-三级封锁协议\"><a href=\"#1-三级封锁协议\" class=\"headerlink\" title=\"1. 三级封锁协议\"></a>1. 三级封锁协议</h4><p><strong>一级封锁协议</strong></p>\n<p>事务 T 要修改数据 A 时必须加<strong>X 锁</strong>，直到 <strong>T 结束</strong>才释放锁。</p>\n<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222801904.png\"></p>\n<p><strong>二级封锁协议</strong></p>\n<p>在一级的基础上，要求读取数据 A 时必须加 <strong>S 锁</strong>，<strong>读取完</strong>马上释放 S 锁。</p>\n<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222832886.png\"></p>\n<p><strong>三级封锁协议</strong></p>\n<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>\n<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222857283.png\"></p>\n<h4 id=\"2-两段锁协议\"><a href=\"#2-两段锁协议\" class=\"headerlink\" title=\"2. 两段锁协议\"></a>2. 两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>\n<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>\n<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>\n\n<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MySQL-隐式与显式锁定\"><a href=\"#MySQL-隐式与显式锁定\" class=\"headerlink\" title=\"MySQL 隐式与显式锁定\"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>\n<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ... LOCK In SHARE MODE;</span><br><span class=\"line\">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、隔离级别\"><a href=\"#四、隔离级别\" class=\"headerlink\" title=\"四、隔离级别\"></a>四、隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>\n<h3 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319223152453.png\"></p>\n<h2 id=\"五、多版本并发控制（暂时没见过）\"><a href=\"#五、多版本并发控制（暂时没见过）\" class=\"headerlink\" title=\"五、多版本并发控制（暂时没见过）\"></a>五、多版本并发控制（暂时没见过）</h2><h2 id=\"六、Next-Key-Locks（暂时没见过）\"><a href=\"#六、Next-Key-Locks（暂时没见过）\" class=\"headerlink\" title=\"六、Next-Key Locks（暂时没见过）\"></a>六、Next-Key Locks（暂时没见过）</h2><h2 id=\"七、关系数据库设计理论（以后补充完整）\"><a href=\"#七、关系数据库设计理论（以后补充完整）\" class=\"headerlink\" title=\"七、关系数据库设计理论（以后补充完整）\"></a>七、关系数据库设计理论（以后补充完整）</h2><h3 id=\"函数依赖\"><a href=\"#函数依赖\" class=\"headerlink\" title=\"函数依赖\"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>\n<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>\n<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>\n<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>\n<h4 id=\"1-第一范式-1NF\"><a href=\"#1-第一范式-1NF\" class=\"headerlink\" title=\"1. 第一范式 (1NF)\"></a>1. 第一范式 (1NF)</h4><p>属性不可分。满足原子性。</p>\n<h4 id=\"2-第二范式-2NF\"><a href=\"#2-第二范式-2NF\" class=\"headerlink\" title=\"2. 第二范式 (2NF)\"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。消除部分依赖。</p>\n<h4 id=\"3-第三范式-3NF\"><a href=\"#3-第三范式-3NF\" class=\"headerlink\" title=\"3. 第三范式 (3NF)\"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。消除传递依赖。</p>\n<h2 id=\"八、ER-图（以后再补充）\"><a href=\"#八、ER-图（以后再补充）\" class=\"headerlink\" title=\"八、ER 图（以后再补充）\"></a>八、ER 图（以后再补充）</h2>","excerpt":"","more":"<h1 id=\"数据库系统原理\"><a href=\"#数据库系统原理\" class=\"headerlink\" title=\"数据库系统原理\"></a>数据库系统原理</h1><p><a href=\"https://zhuanlan.zhihu.com/p/476601594\">https://zhuanlan.zhihu.com/p/476601594</a></p>\n<p><a href=\"https://blog.csdn.net/Xupixel/article/details/120405501\">https://blog.csdn.net/Xupixel/article/details/120405501</a></p>\n<p><a href=\"https://www.hwpo.top/posts/d87f7e0c/index.html\">https://www.hwpo.top/posts/d87f7e0c/index.html</a></p>\n<p><a href=\"https://developer.aliyun.com/article/815625\">https://developer.aliyun.com/article/815625</a></p>\n<h2 id=\"一、事务\"><a href=\"#一、事务\" class=\"headerlink\" title=\"一、事务\"></a>一、事务</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220740283.png\"></p>\n<h4 id=\"1-原子性（Atomicity）\"><a href=\"#1-原子性（Atomicity）\" class=\"headerlink\" title=\"1. 原子性（Atomicity）\"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>\n<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>\n<h4 id=\"2-一致性（Consistency）\"><a href=\"#2-一致性（Consistency）\" class=\"headerlink\" title=\"2. 一致性（Consistency）\"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。（可以看做所有执行都要遵守规则）</p>\n<h4 id=\"3-隔离性（Isolation）\"><a href=\"#3-隔离性（Isolation）\" class=\"headerlink\" title=\"3. 隔离性（Isolation）\"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>\n<h4 id=\"4-持久性（Durability）\"><a href=\"#4-持久性（Durability）\" class=\"headerlink\" title=\"4. 持久性（Durability）\"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>\n<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>\n<hr>\n<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>\n<ul>\n<li>只有满足一致性，事务的执行结果才是正确的。</li>\n<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>\n<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>\n<li>事务满足持久化是为了能应对系统崩溃的情况。</li>\n</ul>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319220943892.png\"></p>\n<h3 id=\"AUTOCOMMIT\"><a href=\"#AUTOCOMMIT\" class=\"headerlink\" title=\"AUTOCOMMIT\"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>\n<h2 id=\"二、并发一致性问题\"><a href=\"#二、并发一致性问题\" class=\"headerlink\" title=\"二、并发一致性问题\"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221024695.png\"></p>\n<h3 id=\"读脏数据\"><a href=\"#读脏数据\" class=\"headerlink\" title=\"读脏数据\"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221039549.png\"></p>\n<h3 id=\"不可重复读（读已提交导致）\"><a href=\"#不可重复读（读已提交导致）\" class=\"headerlink\" title=\"不可重复读（读已提交导致）\"></a>不可重复读（读已提交导致）</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221109092.png\"></p>\n<h3 id=\"幻影读\"><a href=\"#幻影读\" class=\"headerlink\" title=\"幻影读\"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319221128098.png\"></p>\n<p>解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>\n<h2 id=\"三、封锁\"><a href=\"#三、封锁\" class=\"headerlink\" title=\"三、封锁\"></a>三、封锁</h2><h3 id=\"封锁粒度\"><a href=\"#封锁粒度\" class=\"headerlink\" title=\"封锁粒度\"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>\n<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>\n<h3 id=\"封锁类型\"><a href=\"#封锁类型\" class=\"headerlink\" title=\"封锁类型\"></a>封锁类型</h3><h4 id=\"1-读写锁\"><a href=\"#1-读写锁\" class=\"headerlink\" title=\"1. 读写锁\"></a>1. 读写锁</h4><ul>\n<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>\n<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>\n</ul>\n<p>有以下两个规定：</p>\n<ul>\n<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>\n</ul>\n<p>锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222609279.png\"></p>\n<h4 id=\"2-意向锁\"><a href=\"#2-意向锁\" class=\"headerlink\" title=\"2. 意向锁\"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>\n<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁（实际上，意向锁就是只针对写一行和写另一行其实可以并发执行的问题），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>\n<p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，IX&#x2F;IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>\n<ul>\n<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>\n<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>\n</ul>\n<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>\n<p>各种锁的兼容关系如下：</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222621455.png\"></p>\n<h3 id=\"封锁协议\"><a href=\"#封锁协议\" class=\"headerlink\" title=\"封锁协议\"></a>封锁协议</h3><h4 id=\"1-三级封锁协议\"><a href=\"#1-三级封锁协议\" class=\"headerlink\" title=\"1. 三级封锁协议\"></a>1. 三级封锁协议</h4><p><strong>一级封锁协议</strong></p>\n<p>事务 T 要修改数据 A 时必须加<strong>X 锁</strong>，直到 <strong>T 结束</strong>才释放锁。</p>\n<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222801904.png\"></p>\n<p><strong>二级封锁协议</strong></p>\n<p>在一级的基础上，要求读取数据 A 时必须加 <strong>S 锁</strong>，<strong>读取完</strong>马上释放 S 锁。</p>\n<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222832886.png\"></p>\n<p><strong>三级封锁协议</strong></p>\n<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>\n<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319222857283.png\"></p>\n<h4 id=\"2-两段锁协议\"><a href=\"#2-两段锁协议\" class=\"headerlink\" title=\"2. 两段锁协议\"></a>2. 两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p>\n<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>\n<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>\n\n<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MySQL-隐式与显式锁定\"><a href=\"#MySQL-隐式与显式锁定\" class=\"headerlink\" title=\"MySQL 隐式与显式锁定\"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>\n<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ... LOCK In SHARE MODE;</span><br><span class=\"line\">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、隔离级别\"><a href=\"#四、隔离级别\" class=\"headerlink\" title=\"四、隔离级别\"></a>四、隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>\n<h3 id=\"可串行化（SERIALIZABLE）\"><a href=\"#可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化（SERIALIZABLE）\"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<p><img src=\"/2024/03/19/database-system-principles/image-20240319223152453.png\"></p>\n<h2 id=\"五、多版本并发控制（暂时没见过）\"><a href=\"#五、多版本并发控制（暂时没见过）\" class=\"headerlink\" title=\"五、多版本并发控制（暂时没见过）\"></a>五、多版本并发控制（暂时没见过）</h2><h2 id=\"六、Next-Key-Locks（暂时没见过）\"><a href=\"#六、Next-Key-Locks（暂时没见过）\" class=\"headerlink\" title=\"六、Next-Key Locks（暂时没见过）\"></a>六、Next-Key Locks（暂时没见过）</h2><h2 id=\"七、关系数据库设计理论（以后补充完整）\"><a href=\"#七、关系数据库设计理论（以后补充完整）\" class=\"headerlink\" title=\"七、关系数据库设计理论（以后补充完整）\"></a>七、关系数据库设计理论（以后补充完整）</h2><h3 id=\"函数依赖\"><a href=\"#函数依赖\" class=\"headerlink\" title=\"函数依赖\"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>\n<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>\n<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>\n<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>\n<h4 id=\"1-第一范式-1NF\"><a href=\"#1-第一范式-1NF\" class=\"headerlink\" title=\"1. 第一范式 (1NF)\"></a>1. 第一范式 (1NF)</h4><p>属性不可分。满足原子性。</p>\n<h4 id=\"2-第二范式-2NF\"><a href=\"#2-第二范式-2NF\" class=\"headerlink\" title=\"2. 第二范式 (2NF)\"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。消除部分依赖。</p>\n<h4 id=\"3-第三范式-3NF\"><a href=\"#3-第三范式-3NF\" class=\"headerlink\" title=\"3. 第三范式 (3NF)\"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。消除传递依赖。</p>\n<h2 id=\"八、ER-图（以后再补充）\"><a href=\"#八、ER-图（以后再补充）\" class=\"headerlink\" title=\"八、ER 图（以后再补充）\"></a>八、ER 图（以后再补充）</h2>"},{"title":"what the fuck","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: what the fuck\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-03-19T13:00:06.749Z","updated":"2024-03-19T13:13:30.145Z","comments":1,"layout":"post","photos":[],"_id":"cltyjbi030001m0cgeaz5h5ge","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"mysql","date":"2024-03-19T15:02:31.000Z","_content":"\n# MySQL\n\n## 一、索引\n\n### B+ Tree原理\n\n#### 1. 数据结构\n\nB Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n#### 2. 操作\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。\n\n#### 3. 与红黑树的比较\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。\n\n（一）B+ 树有更低的树高\n\n平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。\n\n（二）磁盘访问原理\n\n一次I/O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n\n寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。\n\n（三）磁盘预读特性\n\n能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n### MySQL 索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\n#### 1. B+ Tree索引\n\n是大多数 MySQL 存储引擎的默认索引类型。\n\n查找速度快：只需要对树进行搜索。\n\n可用于排序和分组：B+ Tree的有序性。\n\n适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\n\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。\n\n主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n![image-20240319231655495](mysql/image-20240319231655495.png)\n\n辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n![image-20240319231743225](mysql/image-20240319231743225.png)\n\n#### 2. 哈希索引\n\n哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n\n- 无法用于排序与分组；\n- 只支持精确查找，无法用于部分查找和范围查找。\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n#### 3. 全文索引（没见过，韩了）\n\nInnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n\n查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n\n全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\n\n#### 4. 空间数据索引（没见过，韩了）\n\nMyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n\n必须使用 GIS 相关的函数来维护数据。\n\n### 索引优化\n\n#### 1. 独立的列\n\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n\n例如下面的查询不能使用 actor_id 列的索引：\n\n```mysql\nSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n```\n\n#### 2. 多列索引\n\n在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\n\n```mysql\nSELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id = 1 AND film_id = 1;\n```\n\n#### 3. 索引列的顺序\n\n让选择性最强的索引列放在前面。\n\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\n```mysql\nSELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n```\n\n```powershell\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049\n```\n\n#### 4. 前缀索引\n\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n\n前缀长度的选取需要根据索引选择性来确定。\n\n#### 5. 覆盖索引\n\n创建包含所有需要查询的字段的索引。\n\n具有以下优点：\n\n- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n### 索引的优点\n\n- 减少服务器扫描的行数\n- 帮助服务器避免排序和分组，以及避免创建临时表。\n- 将随机I/O变为顺序I/O（B+ Tree特性）。\n\n### 索引的使用条件\n\n跟快排差不多，数据量小的时候反而不如暴力。\n\n- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n- 对于中到大型的表，索引就非常有效；\n- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n## 二、查询性能优化\n","source":"_posts/mysql.md","raw":"---\ntitle: mysql\ndate: 2024-03-19 23:02:31\ntags:\n---\n\n# MySQL\n\n## 一、索引\n\n### B+ Tree原理\n\n#### 1. 数据结构\n\nB Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。\n\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n#### 2. 操作\n\n进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n\n插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。\n\n#### 3. 与红黑树的比较\n\n红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。\n\n（一）B+ 树有更低的树高\n\n平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。\n\n（二）磁盘访问原理\n\n一次I/O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n\n寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。\n\n（三）磁盘预读特性\n\n能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。\n\n### MySQL 索引\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\n#### 1. B+ Tree索引\n\n是大多数 MySQL 存储引擎的默认索引类型。\n\n查找速度快：只需要对树进行搜索。\n\n可用于排序和分组：B+ Tree的有序性。\n\n适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\n\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。\n\n主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n![image-20240319231655495](mysql/image-20240319231655495.png)\n\n辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n![image-20240319231743225](mysql/image-20240319231743225.png)\n\n#### 2. 哈希索引\n\n哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n\n- 无法用于排序与分组；\n- 只支持精确查找，无法用于部分查找和范围查找。\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n#### 3. 全文索引（没见过，韩了）\n\nInnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n\n查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n\n全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\n\n#### 4. 空间数据索引（没见过，韩了）\n\nMyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n\n必须使用 GIS 相关的函数来维护数据。\n\n### 索引优化\n\n#### 1. 独立的列\n\n在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n\n例如下面的查询不能使用 actor_id 列的索引：\n\n```mysql\nSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n```\n\n#### 2. 多列索引\n\n在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\n\n```mysql\nSELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id = 1 AND film_id = 1;\n```\n\n#### 3. 索引列的顺序\n\n让选择性最强的索引列放在前面。\n\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\n```mysql\nSELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n```\n\n```powershell\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049\n```\n\n#### 4. 前缀索引\n\n对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n\n前缀长度的选取需要根据索引选择性来确定。\n\n#### 5. 覆盖索引\n\n创建包含所有需要查询的字段的索引。\n\n具有以下优点：\n\n- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n### 索引的优点\n\n- 减少服务器扫描的行数\n- 帮助服务器避免排序和分组，以及避免创建临时表。\n- 将随机I/O变为顺序I/O（B+ Tree特性）。\n\n### 索引的使用条件\n\n跟快排差不多，数据量小的时候反而不如暴力。\n\n- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n- 对于中到大型的表，索引就非常有效；\n- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n## 二、查询性能优化\n","slug":"mysql","published":1,"updated":"2024-03-19T15:29:46.757Z","comments":1,"layout":"post","photos":[],"_id":"cltyjbi050002m0cg4a6xf5ow","content":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"一、索引\"><a href=\"#一、索引\" class=\"headerlink\" title=\"一、索引\"></a>一、索引</h2><h3 id=\"B-Tree原理\"><a href=\"#B-Tree原理\" class=\"headerlink\" title=\"B+ Tree原理\"></a>B+ Tree原理</h3><h4 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1. 数据结构\"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<h4 id=\"2-操作\"><a href=\"#2-操作\" class=\"headerlink\" title=\"2. 操作\"></a>2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>\n<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>\n<h4 id=\"3-与红黑树的比较\"><a href=\"#3-与红黑树的比较\" class=\"headerlink\" title=\"3. 与红黑树的比较\"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。</p>\n<p>（一）B+ 树有更低的树高</p>\n<p>平衡树的树高 O(h)&#x3D;O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>\n<p>（二）磁盘访问原理</p>\n<p>一次I&#x2F;O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。</p>\n<p>寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>\n<p>（三）磁盘预读特性</p>\n<p>能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I&#x2F;O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<h3 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>\n<h4 id=\"1-B-Tree索引\"><a href=\"#1-B-Tree索引\" class=\"headerlink\" title=\"1. B+ Tree索引\"></a>1. B+ Tree索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p>\n<p>查找速度快：只需要对树进行搜索。</p>\n<p>可用于排序和分组：B+ Tree的有序性。</p>\n<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>\n<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>\n<p>主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231655495.png\"></p>\n<p>辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231743225.png\"></p>\n<h4 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>\n<ul>\n<li>无法用于排序与分组；</li>\n<li>只支持精确查找，无法用于部分查找和范围查找。</li>\n</ul>\n<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n<h4 id=\"3-全文索引（没见过，韩了）\"><a href=\"#3-全文索引（没见过，韩了）\" class=\"headerlink\" title=\"3. 全文索引（没见过，韩了）\"></a>3. 全文索引（没见过，韩了）</h4><p>InnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>\n<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>\n<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>\n<h4 id=\"4-空间数据索引（没见过，韩了）\"><a href=\"#4-空间数据索引（没见过，韩了）\" class=\"headerlink\" title=\"4. 空间数据索引（没见过，韩了）\"></a>4. 空间数据索引（没见过，韩了）</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>\n<p>必须使用 GIS 相关的函数来维护数据。</p>\n<h3 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h3><h4 id=\"1-独立的列\"><a href=\"#1-独立的列\" class=\"headerlink\" title=\"1. 独立的列\"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>\n<p>例如下面的查询不能使用 actor_id 列的索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-多列索引\"><a href=\"#2-多列索引\" class=\"headerlink\" title=\"2. 多列索引\"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class=\"line\">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-索引列的顺序\"><a href=\"#3-索引列的顺序\" class=\"headerlink\" title=\"3. 索引列的顺序\"></a>3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p>\n<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>\n<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class=\"line\">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class=\"line\">COUNT(*)</span><br><span class=\"line\">FROM payment;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   staff_id_selectivity: <span class=\"number\">0.0001</span></span><br><span class=\"line\">customer_id_selectivity: <span class=\"number\">0.0373</span></span><br><span class=\"line\">               COUNT(*): <span class=\"number\">16049</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-前缀索引\"><a href=\"#4-前缀索引\" class=\"headerlink\" title=\"4. 前缀索引\"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>\n<p>前缀长度的选取需要根据索引选择性来确定。</p>\n<h4 id=\"5-覆盖索引\"><a href=\"#5-覆盖索引\" class=\"headerlink\" title=\"5. 覆盖索引\"></a>5. 覆盖索引</h4><p>创建包含所有需要查询的字段的索引。</p>\n<p>具有以下优点：</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>\n<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>\n<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>\n</ul>\n<h3 id=\"索引的优点\"><a href=\"#索引的优点\" class=\"headerlink\" title=\"索引的优点\"></a>索引的优点</h3><ul>\n<li>减少服务器扫描的行数</li>\n<li>帮助服务器避免排序和分组，以及避免创建临时表。</li>\n<li>将随机I&#x2F;O变为顺序I&#x2F;O（B+ Tree特性）。</li>\n</ul>\n<h3 id=\"索引的使用条件\"><a href=\"#索引的使用条件\" class=\"headerlink\" title=\"索引的使用条件\"></a>索引的使用条件</h3><p>跟快排差不多，数据量小的时候反而不如暴力。</p>\n<ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>\n</ul>\n<h2 id=\"二、查询性能优化\"><a href=\"#二、查询性能优化\" class=\"headerlink\" title=\"二、查询性能优化\"></a>二、查询性能优化</h2>","excerpt":"","more":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"一、索引\"><a href=\"#一、索引\" class=\"headerlink\" title=\"一、索引\"></a>一、索引</h2><h3 id=\"B-Tree原理\"><a href=\"#B-Tree原理\" class=\"headerlink\" title=\"B+ Tree原理\"></a>B+ Tree原理</h3><h4 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1. 数据结构\"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。但是B Tree的数据不只是存放在叶子节点。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>\n<h4 id=\"2-操作\"><a href=\"#2-操作\" class=\"headerlink\" title=\"2. 操作\"></a>2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>\n<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>\n<h4 id=\"3-与红黑树的比较\"><a href=\"#3-与红黑树的比较\" class=\"headerlink\" title=\"3. 与红黑树的比较\"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为B+树访问磁盘数据具有更高的性能。</p>\n<p>（一）B+ 树有更低的树高</p>\n<p>平衡树的树高 O(h)&#x3D;O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>\n<p>（二）磁盘访问原理</p>\n<p>一次I&#x2F;O能完全载入一个节点：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。</p>\n<p>寻道次数比红黑树少：如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>\n<p>（三）磁盘预读特性</p>\n<p>能预先载入相邻块：而块之间的数据的key又有顺序关系：为了减少磁盘 I&#x2F;O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<h3 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>\n<h4 id=\"1-B-Tree索引\"><a href=\"#1-B-Tree索引\" class=\"headerlink\" title=\"1. B+ Tree索引\"></a>1. B+ Tree索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p>\n<p>查找速度快：只需要对树进行搜索。</p>\n<p>可用于排序和分组：B+ Tree的有序性。</p>\n<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>\n<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>\n<p>主索引（聚簇索引）：叶子节点 data 域记录着完整的数据记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231655495.png\"></p>\n<p>辅助索引（非聚簇索引）：叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>\n<p><img src=\"/2024/03/19/mysql/image-20240319231743225.png\"></p>\n<h4 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>\n<ul>\n<li>无法用于排序与分组；</li>\n<li>只支持精确查找，无法用于部分查找和范围查找。</li>\n</ul>\n<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n<h4 id=\"3-全文索引（没见过，韩了）\"><a href=\"#3-全文索引（没见过，韩了）\" class=\"headerlink\" title=\"3. 全文索引（没见过，韩了）\"></a>3. 全文索引（没见过，韩了）</h4><p>InnoDB和MyISAM 存储引擎都支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>\n<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>\n<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>\n<h4 id=\"4-空间数据索引（没见过，韩了）\"><a href=\"#4-空间数据索引（没见过，韩了）\" class=\"headerlink\" title=\"4. 空间数据索引（没见过，韩了）\"></a>4. 空间数据索引（没见过，韩了）</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>\n<p>必须使用 GIS 相关的函数来维护数据。</p>\n<h3 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h3><h4 id=\"1-独立的列\"><a href=\"#1-独立的列\" class=\"headerlink\" title=\"1. 独立的列\"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>\n<p>例如下面的查询不能使用 actor_id 列的索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-多列索引\"><a href=\"#2-多列索引\" class=\"headerlink\" title=\"2. 多列索引\"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class=\"line\">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-索引列的顺序\"><a href=\"#3-索引列的顺序\" class=\"headerlink\" title=\"3. 索引列的顺序\"></a>3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p>\n<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>\n<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class=\"line\">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class=\"line\">COUNT(*)</span><br><span class=\"line\">FROM payment;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   staff_id_selectivity: <span class=\"number\">0.0001</span></span><br><span class=\"line\">customer_id_selectivity: <span class=\"number\">0.0373</span></span><br><span class=\"line\">               COUNT(*): <span class=\"number\">16049</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-前缀索引\"><a href=\"#4-前缀索引\" class=\"headerlink\" title=\"4. 前缀索引\"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>\n<p>前缀长度的选取需要根据索引选择性来确定。</p>\n<h4 id=\"5-覆盖索引\"><a href=\"#5-覆盖索引\" class=\"headerlink\" title=\"5. 覆盖索引\"></a>5. 覆盖索引</h4><p>创建包含所有需要查询的字段的索引。</p>\n<p>具有以下优点：</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>\n<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>\n<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>\n</ul>\n<h3 id=\"索引的优点\"><a href=\"#索引的优点\" class=\"headerlink\" title=\"索引的优点\"></a>索引的优点</h3><ul>\n<li>减少服务器扫描的行数</li>\n<li>帮助服务器避免排序和分组，以及避免创建临时表。</li>\n<li>将随机I&#x2F;O变为顺序I&#x2F;O（B+ Tree特性）。</li>\n</ul>\n<h3 id=\"索引的使用条件\"><a href=\"#索引的使用条件\" class=\"headerlink\" title=\"索引的使用条件\"></a>索引的使用条件</h3><p>跟快排差不多，数据量小的时候反而不如暴力。</p>\n<ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>\n</ul>\n<h2 id=\"二、查询性能优化\"><a href=\"#二、查询性能优化\" class=\"headerlink\" title=\"二、查询性能优化\"></a>二、查询性能优化</h2>"}],"PostAsset":[{"_id":"source/_posts/database-system-principles/image-20240319215933046.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319215933046.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319220740283.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319220740283.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319220943892.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319220943892.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221024695.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319221024695.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221039549.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319221039549.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221109092.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319221109092.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319221128098.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319221128098.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222609279.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319222609279.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222621455.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319222621455.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222801904.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319222801904.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222832886.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319222832886.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319222857283.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319222857283.png","modified":1,"renderable":0},{"_id":"source/_posts/database-system-principles/image-20240319223152453.png","post":"cltyjbhzw0000m0cgd4kp170j","slug":"image-20240319223152453.png","modified":1,"renderable":0},{"_id":"source/_posts/mysql/image-20240319231655495.png","post":"cltyjbi050002m0cg4a6xf5ow","slug":"image-20240319231655495.png","modified":1,"renderable":0},{"_id":"source/_posts/mysql/image-20240319231743225.png","post":"cltyjbi050002m0cg4a6xf5ow","slug":"image-20240319231743225.png","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}